{
  "transpiled": true,
  "noir_version": "1.0.0-beta.4+0000000000000000000000000000000000000000",
  "name": "Portal",
  "functions": [
    {
      "name": "_register_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "aztec_token",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "eth_token",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14788743618517749904": {
            "error_kind": "string",
            "string": "Function _register_public can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_register_public"
      ]
    },
    {
      "name": "get_l2_token",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "eth_token",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/+29CZBc13Ul+LM2oBIoIAmABEmAO8V9yb2q5A1aYC2kKGoxLVmypKzKTO4EBYAEKZHEr8JGkAABkgIl2ZZsS5YtS7Zly7sty2p73NMz0dMO97gnZtrtJRweT8+EIybsWRTj6ehufPDfzJMn73//Z+V9hRRRLwKon//dd+599913333L/z8XvJ5y8b8oTcA9TnJvV/y3OFwqGWIVc4qczkpoBT5xxet/p+PfY5A/bljxaUUWK/y54nxjOuivs6H8lekY06d+BNMDfnFdjPO5sIvPdYnSTNDbObDM+jhfrg9AmSh9HrClvE+9nW33ec96K20NknUlNve2MOikLt9SZa5eKc/Vy+Vmq9ho1mfb85XZYmWhVplfXCgVK7XyXHO2USkWW5XWYrXYrM/Xmq3GfK3SXmjM1wX77Sp2pbVwFqrWqM8tlNqNeru4UJ2dqzTas7PNRnO+2pqtFZulxXppsVxqz801arXGYm2+VGq35mvtuQ727tCLzsqC/8Ne8Cs1wX8H4E/YyV8U/Hf6we/4wnf5we/o/91e9N+V/64YPwjsdX+3F9lLHfz3+NFNVfDv8YNfEfz3An7OA/69fvA7tvM+P/gd23+/H/23Bf8DMX4A2KW5Srk8W5mfLc7PNYulanOxPHfW+y9Ui4vFxmK5NV8tzber5Wplsbm4MFeda5TaxXZjcb499zq4YH/Qi+yVjm3+iBfdVzrjyn2KborDpY7P/9Fk7BWrX7A/pGCXG5XF4ny72KjNNWZbc7Wzw3Xx7MXCXKtdLzcWzg7c5WapVGpVz/5XbjWr8wvNemmh3pot1xbOsuu06YdDH21aWhT8HzPGrzeK8616fVbwP2KMv7BQn22c1afgf9QYv7JYb7Ursx1/8OPG+I1atd2uVTrzjo8Z49dKxVatPNuxzY8b488vFGv1ubmO/XzCGP9s3FlpzjcWBL9hrZ+FVnGxWZqXucdCjC88oiS8F415x2lem1ePK/eEf55ktY7LcsQP5UH9yFxGdNcM+2UtKHnoYzhvXLknfDSsjxhifdQQ68cNsT5miPVxQ6xPGGJJv/bb16qdcbTpBb8yJ/gtL/jFluC3feCXurHj/YAf2MnfwX8A8HMe8B/0o/8O/kN+9NOZ1zwc4/vAfsQeuzPfe9SP3jvx3WN+8Dtzjj1+8Dvx7+N+8Dt+55N+8OcFf68f/E78u88Pfid+3O8HvxP/PuEHvyn4T3rBL3X0cwDw7fxyueM3n/KCX+ngP+0Hv+M7P+UFv9rB/7Qf/M6azTN+8Dv++Vk/+B3//Jwf/E5cddALfq0z/w694Nc79rPkB78zvi/7we/Y5yE/+B37POwHv2OfR/zgd+KHo37wO/HDMT/4nfjheT/4nfHruB/8zvj+gh/8zvj+oh/8jn874Qe/499OesGf7YzvL/nB76zvnvKD3/Gfp/3gd/zny37wO/7zFT/4Hf/5qh/8jn/7jB/8jn874we/499e84Pf8T+fjfGDlWNX+MaG4PVzPv+w5XW8jWf/bYqx72/tf+sjexYfvueJRxdae3G1O7rG0zJ4fzzoTxHqli7q2/Y8tn9vY3H/W5rNva19+5IQcoE7Rah5QH2g8eBj72oy2sTK0O5r7d334J7HGG0yI5qcWZoCesOYtShnuNaRfMh7Pdw3nI82s+yJIP88yWo8/y7liJ/Iw/rBPZFc0F3PxrIFJY/bcFrhM63wKSh5HEMPg/WSIdZhQ6wThliWdXzBEOuYIdaLhlhHDLEOGGJZ6t6yD50aUazQEMvSJix1b2lfy4ZYln3b0iaWDLEsffQrhlijOj7K3MRvbFWcn1F4S5K8PPDGmIoTR+Iod/T3n7Z0cZlO0kaQZd/Tjy3es2d/a1/gKBAlOSzP90dNefxAxIYMdQiCdMVObe3iMh3Lgw2Yp7z1StmcgqVNmNiYUefrEmRADGkrDIQNJxGVLPVA/qs1idCchDaJEP3k/einnCN8lCev6IdtmNsu+rcx/j0JWEifhzoiPV5Lebz37+O/haC/H8kDBDklb1y5J/qNJl1/TnXDtmE79dMO1VJWOxX++cBnv+naqWYX2mA2HfS3s+WhrSztqvm2jUqeYInfRDtF+g1QR6THaymP9/5j/LcQ9Ns02+lGpT54D+30b+Pr6YT67Ip/F4dKs7PaOMX9APVkeQg9az8Q/vnAp911+4HWTpo/Ed3NKLIWlDxe9JlR+MwofApKHgeiw2CdMMRaMsQ6ZIh1akSxjhlivWiIdcQQ64Ah1nFDLEu7H0V9ucbBQbGiZGmrpw2xjhpiWdqqZR1DQ6xR7dtnDLGeMsSSTViOMwU/StNBf9+znrshP6kH3kP+eZLVVp5urKTpVYtpRT+b/OinI88mRZ5Nin6kLTcreYIlD67gnAHpN0EdkR6vpTzek8YsEGaUeM6wWakP3sM5w2253rph27Cd+mwH5Cdy4z3knw989pui0y60/j8d9LezoX6KWdoV5ZW2LCh5gnVR/BvtFOk3Qx2RHq+lPN7bRXaKNs12WlDqg/fQTt9Mdoptw3bqpR1K7cx2Kvzzgc9+07VTzS42KXqcDvrb2VA/xSztivJKW16k5AmWHNdBO0X6AtQR6fFayuO9e8hO0ab5wbOLlPrgPbTTd8a40wn12RX/Lg6ValWtLe3wZ0szSj25n6Gu7ey6krmfCf980G8XPvrZFpInyQ5Ed1sVWQtKHtvIVoXPVoVPQcnjec0wWIcMsQ4YYi0ZYh03xAoNsY4ZYr1giGVpE8uGWAcNsU4ZYWn+eRi5XjKSK0qnDbEs+/YZQyxLX2jZH180xLJsx9cMsSxtwlL3Vn07MK6jpU2cMMQaVT9hKdeFEDOtjWnnT/eW/fGwIZZlHV8dUbks4wnLOvL+AM4tc/Hf6aC/7xnOs1s54if1wHvIP0+y2srTnWdret2i6FV0t02RtaDk8Tx7m8Jnm8KnoOTxmDEM1iFDrAOGWJZ1PGaI9aIh1mlDLEvdnzHEWmvHwbBeM8SytIllQ6wThliW/uuUIZal7i1t1VL3o+q/LG3V0r5eMMSybEdL+7LsQ5b29ZIhVmiIZVnHUY3lLOtoGU+MajuOaiz3qiHWqMY5ljHmWjzxxuhDln7CUi4r+8oF/euqw8j1spFcUbLUvWUMIGMtn3cT/Cj5XUMrZz5jy2toXs5gpayhaWfrpoN+OzTUTylLO6O80pYXK3mCdUn8G8+EIf02qCPS47WUx3tvjZVSIMwo8Zmwi5X64D3Rb3Qm7PvjH9MJ9dkV/y4Ol+Z4PVR4IG/Uk6HdZfpABfLPBz7trtsPtHbS/Ivo7hJF1kLQbztsD5cofC5R+KxhjRbWvUZYLh8m+VGaVspZ+1vkJ/XAe8g/H3j1CyWXXjV/KfrZ7kc/nTPK2xV5tiv6kba8VMkTrMvi3zgeIf12qCPS47WUx3ttGo8uBVruA5cq9cF7OB59Yqy3btg2bKd+2iH7Mx/CPx/47DddO9XsQuv/00F/Oxvqp5ilXVFeacvLlDzBujz+jXaK9JdCHZEer6U83ttPdoo2zXZ6mVIfvId2+lj8Y3OQ3D+z9GfE1fw26xDLcX/w0t6lVjFrfxD++cBn/+z2h0sz6lX0c5kX/TTbWewH5ZW2vFzJE6wd8W/sD0h/GdQR6fFayuO9I9QfsO9wf7hcqQ/ew/5wkPw2tg3bqZd2KBbbWe1U+OcDn36ya6eaXWjj33TQ386G8rSytCvKK225Q8kTrJ3xb7RTpL8c6oj0eC3l8d6rZKdo0/ys3g6lPngP7fQkzXe5Prvi38WhUquktaUdfqM4rejaDr/c+aD8Ti/4C3OCf4Uf/LrgX+kFf67Tvld5wa919HO1H/ym4F/jx3468l/rBb9SEfzrvOC3OvJf7wW/2sF/kxf8hU7/vcEL/nzH/m/0o59O+97kBb9dE/yb/einI/8tfuTv+P/bAN9yLULw7/CCX6yIPm4PumlcqZPwl1jkVqDPJfwVLM4TXnnC8hX3aXVD+XnedzvIgzpIwrp9QKxpJc9Hm97mqDfyn3HIyvWIEr8DZ6U6idKyIdZzhlgvGWFpse0wcj1tKNflRnJp8e8wWDsNsaaMsKLEHz0cRq4rjOSKrq8cUayrDLGuNsS6xhDrWkOs6wyxrjfCitJnQju53mQo18nQTq4bjOSKrm80xLIaO6LrmwyxbjbEusUIK0q8djoqWLKH7He9qzrvd72r0vC73lVt+l3vqlX8rndVZ/2ud1UXZ4Le8VB4oG1dA/ft5hXVzM+CCv88yWorT3d+dw3Jw/rh8zvXKrIWlDzuo9cqfK5V+BSUPD7LOwzWK4ZYoSHWcUOsY4ZYy4ZYBwyxXjDEOmSIdWpEsSxt9YghlpXutXF7VGzVsj+eNsQa1f74siGWZR8aVd0fNcSy9BOWY62lj7bUvaW+RtW+LGMTy3a01P2F4CfOGGFF1zyHHUauZwzl2mkklyVWlD4V2sl1haFcVrqP0kFDLEub4LX0YbCmjLCiZGUTUXrOEOvThliW9mUpl5WtjrIv3Gwol6WtWrajpV8dVX1Z2iqvrY5K37b0X68ZYlnGX4cNsSzXFCxjcsu5guXao8T3so59FeTl4r9+9wCKK94DuMqPPM49gKsUvWrnYQ3laWZpZ5RX2vI6JU+wZC8fz/Yj/bVQR6THaymP934ubrgCYUaJz/Zfp9QH74l+o9jyi+O9dcO2YTv10w7ZvwEr/POB135TctnFNYoeNbuQsgUlj2P6rO2ltT2ffRsG64Qh1pIh1iFDrFMjinXMEOtFQ6wjhlgHDLFOGmJZ9iHLdnzFECs0xDptiGXZty3ty7IPWfrVC0H3LxhiWfpo8YXac1SG8UdRe87JEL/zzMH1Dl0gfz6LI/naX8HiPOGVJyzjupVcdXPN3TAORx0kYV0/IJb2bJyPNr3OUW/k7/dZwFrZ77OAtbrfZwGrbbH5G0CfOdLdTV7aci7zu1SEf55k9dWnbiJ5WD88H7pZkbWg5PHZvZsVPjcrfApKHo/bw2C9YogVGmIdN8Q6Zoi1bIh1wBDrpCHWS4ZYlrofVVs9bYh1yBDL0r4sfc4JQ6wLQfcvGGJZ1vHUiGJZ9u0jhlhWuo+u+VzuqNjqqMYAllhr4/bauP29Mnasjdtr4/bauP3G1P2o2urLhliW+rL0OZa6P2qIZdmHLMftUfXRoxpPWNbRMva1bEdL3V8IfuKMEVZ0zedzhsG6zhDLap08ur7eCCtKfPZ4GLk2G8r1jJFcUTpoiPWcEVZ0zftfa7p315GfnRgGa6ch1hVGWFGy1NeNRnJZ2mqULPvQqNr9qNbxje4LLeWK0trY8b0/dkTpWSOs6NryzIOVvqLrKw3l+rShXFZjbZQsx0dLfY3i2BGl1wyxLOd8hw2xLPd0LNcBLNcnLM/n8PNteDYsF/+dDvr7S8RnV/y7OFxq5oif1APvIf88yWosT8ml15sUvYp+bvEjz2KO8FGeWxT9SFvepuQJlrwnE59vQ/pboI5Ij9dSvid/8vW/BcKMEj/fpr0rHe+JfqN1nP9/ordu2DZsp37aoZz5+Tbhnw+89puSyy60/q/ZhZTV2ovH/aztpWEdM8Q6ZYi1ZIh1whDrFUOsQ4ZYL42oXMuGWAcMsc4YYj1liPWaIZalvl40xLLsj6cNsSzt3tIXWrbjYUMsS59jaRMvGGJZ6j4cUblOGmJZ2oRlbGI5blu246j6L0v7suyPo+qjLbEs7euIIZboXuYrOL/JxX+nqVwuMJ3rVXPET+qB95B/nmS1lac719P0eoui10G+LxZdW36zyeo7XlE6YYi1ZIh1yBDr1IhiHTPEetEQ64gh1gFDrJOGWKEhlmV/PG2IZWlflvo6bohlaV+WfcjSr1rahKVfHdW+bdkfLfvQK4ZYlv3xQrCvFwyxLGMAGWs3x3kYb18b9PIZNObH8kI3o5TLxX+nSb5cYBljz2d+X4fwzys68RHz355Rr6K7OxRZC0oen125Q+Fzh8KnoOTx2DQM1iuGWKEh1nFDrGOGWMuGWAcMsU4aYr1kiGWp+1G11dOGWIcMsSzty9LnnDDEuhB0/4IhlmUdT40olmXfPmKIZaX76Jrf1zEqtjqqMYAl1qiO25a6t4wBLH20ZTwxqra6Nm6fvzFtLSYfDGstJj9/9rUWF54/+zpiiDWquh9VW33ZEMtSX5Y+x1L3Rw2xLPuQ5dgxqj56VMc0yzpaxr6W7Wip+wvBT5wxwoqu+YzTMHJ9ylCu64zkiq43G2JZ7g9Z6utKQ7kOGskVpeeMsKJrfqZ/FGwiSvxs8yjo3rJvW/dHqz4UXV9vhBUly/54IdgXv29oGKydhlhXGGFFyVJfNxrJZekLo2Tpo0fV7ke1jm/0sdZSriitxSbf+2NHlJ41wrKMJ6Jkpa/o2jIm/7ShXFZjbZQsx0dLfY3i2BGl1wyxLNcUDhtiWe5bWa4zWa5/WZ4v5PcNbYa8XPxXzvmir4v47Ip/F4dKpczvGxL++aB/rLKTp3vO97KgX6+bFb2K7i5XZC0oeTw3vlzhc7nCp6Dk8Z7vMFgnDLGWDLEOGWKdGlGsY4ZYLxpiHTHEOmCIddIQy7IPWbbjK4ZYoSHWaUMsy75taV+Wclm2o6Vcln7C0iYs2/EFQyxLfy9+VWIrjgl2xb+LQ6VaTWITjGVyQS9vjE0M47q5HPETPeE95J8nWW3l6cZ1Wruhfjiu26HIWlDyuA13KHx2KHwKSh73zWGwnjfEspTrhBFWdJ0PbLCs63jAEOsFQ6xThlhHDLEs9XXaEOszhlgnDbEOGWJZ6v6YIdayIZZlHc8YYj1liCXrfBxbRGlX/PfscFiZq1fKc/VyudkqNpr12fZ8ZbZYWahV5hcXSsVKrTzXnG1UisVWpbVYLTbr87VmqzFfq7QXGvOzfmOH2vx00O/jDWOTkuDv9INfFvwr/OBXBP9KP/hVwb/OD35N8K/3g18X/Df5wZ/1++6D0pzg3+EHv9O/7vSD3xD8oh/8puCX/OC3BL/sB78t+BUv+OWi4Ff94Hf8Z80Pfsd/1v3gd/znrB/8jv+c84Pf8Z/zfvA7/vPNfvA7/vP7/OB3/Of3+8Hv+M8f8IPf8Z8/6Ad/QfB/yA/+ouDv8oPf8f9v8YPf8f9v9YPf8f9v84Jf6fj/t/vB7/j/3X7wO/7/h/3gd/z/O/zgd/znO/3gd/znu/zgd/zbu/3gd/zbXX7wO/7tbj/4Hf/2Hj/4Hf92jx/8jn97rx/8jn+71wt+teN/3ucHv+N/3u8Hv+N/PuAHvxN/ftAPfif+/BE/+B3/eZ8f/I7//FE/+J3480N+8Dv++cN+8Dv++cf84Hf880f84Hf880f94Hf884/7we/454/5we/45497wa914s9P+MHv+P+GH/yO/1/wg9/x/4t+8Dv+v+kHv+P/W37wO/6/7Qe/4//v94Pf8f8PBN3Uxa60Fs5utdQa9bmFUrtRbxcXqrNzlUZ7drbZaM5XW7O1YrO0WC8tlkvtublGrdZYrM2XSu3WfK0915H9QRV7mNTdF3nIh15K7Y5feBjwc2byz3XwH/GCX+z0q0e96KfZ8cuPKW1brjbrC43ibHu20Zhrnx1Ey82zf+pnraZdKzfmK4uNs1bUXGg1FiqL8+XFZrlZac2d9TWtyny91eqOWXus7aZU7Oj9cS967+6HfNJc73Pn/o/2SE+tex1L3q09AbzWU73iz6p2vtcapQfDLs0E5CP9P8UHVSJ+r8b8ZqiMYERpmsrb+qnSfI74BYF+Rkv45xXd+DijNUnysH74jNaUImuB8qLEe/ZTCp8phY+G9Zoh1gFDrJOGWIcMsV40xFo2xDpmiGVZxyOGWKNqX6Eh1kuGWKcNsSzty1Jfxw2xLO3Lsg+dMMSytAlLvypnObWz5HZjc31exlqcd0iSPJ43YN7DQP/2sEvHaZx+Y52iOOySrV1cpmN5MG56CPCTYoYoiR7XUV12xb+Lw6XOHGvaD35FbGp90KtTrtN0gq4kX/srWJwnvPJBv959xIda3VB+7i8Yv6MOkrDWD4g1reT5aNN1jnoj/xmHrFo9+NkFzR9p8bfQTzvkQvrNCm8pKzrcAHmGOiy7dIh9UfhvBDmbrYUn7r97z/0BpXHSg+jtUqJ7d9jVA9vg+gSsgH5fSvfGAQ+T3znj+R0HpE6DjgM4X32I8lbq96LEvgF1Ljwjm/hHx9oClkEbyrq2IPQ/sL7L7/9Z15WZ+aH8bCtR2hX/TbKAdsYUkHzrHHXnuvxzLH9UpRu29so6MYCsSb6Ab3gekxtia/mgP0ke+j3UESetX4jckb5uXmF8tIHycEzYSHnov2YoD337JsrT1rhW2tc0O/Ldp6eIz5QhH9T3OuKzzpCPNvZ4jl86YwbGCQHVEZ/hm6A87Bvc1hshj9tnBvJYp5tAhkfCLh0nrb+JnqK/78jQ3y5k/eKYs6bf4fW7Eh0uDTAmYFvliZZjDyx/V9ilw3pOKOWjdH/YiyX0lfVduX9ia7d+7PPHgn7Zx0jeKPmNh1+fVyA/kRfvIf88yWosj3MPBfUj15H9iX3u279nb+P+1vtbjZ7XMrH6+C+bpPzm4X6cfufo9wThPBz247hSTuGjVV2mY5uDfpOXshsgH7shh+ubqCzSIy+hl1dITQEvpJGyk0T/VugWX4i7hRaiiDzTVN7WzM7vNFDqNOg0ENsRZUNMmXZx2ya1yz3QLj9D7gr5YbjB9ZDfDyj8RPaLiDZK0sZb4L7h9nDmTzAL/zzJ6su1bSF5WD+aa3tkT6P5tsbj+554pMWjRAGuEb5AcEKDtJgKIFJAKsDfm6nc3WF/OU6CM0kyPwaz/g/F11ne5lcg3F3x7+JwaTGryQj/1XqbX4HkYf2MkX48mfBCLug313GFp8grbblFyROs2Ov0uC6kvwjqiPR4LeXxXju2p0LQ3+042tO6JN4T/UZ2+gmyUy0q1GbYd1HeOkfeekcervKIDXCkHqUHqdxGBTOS7zfWd/GSbA3bm8MPtP0kX5SEtZuwsPwWwtqagnUPYWH5rYS1LQXrPYSF5bcR1sUpWI8SFpa/mLAuScF6jLCw/CWEtT0Faw9hYfnthHVpCtbjhIXlLyWsy1KwPklYWJ7fWH15CtZewsLy/IXhHSlY+wgLy/MXHXamYO0nLCzPb5m+IgXrCcLC8vxFhytTsFqEheWl7IyCxePzVXD/fIzPwj9Psvoan68K+vWK+uETf1crshaUPPZbVyt8rlb4aFjbDLEuNsS6xBBruyHWpYZYlxliXW6ItcMQa6chFvuttPH6/eHrf13jtZRD20W6caDRxmjESIoHxoPsccHdJLPGU4sxHwp783DnheNBXHXlmBxXm7dQHsaY7PdxNXgr5eFqsNQHY8xJqs9vx/f9LvcUixgLJunK1+4eLx1tNuSDWG8Pe/ms/pJLsZWlHsjf95KL6GKbQxcXe+Fdzbz8dDHpYpsnXYhfSpsX8OkoLfbfptDjctX9rf1377n/rU9/sHE/b/7yFFHEmSG6LfR7a4JYu4juYvot4UXSJjQ2jyaHa9Vf48/0eD2l3I+SNm26iHhqzYb32DVg+e0OPtuG5LNN4SNdC0MoH4dQ/bzAsXtgUZuqYp2E/4yip0FcO/LKB/1t5MMNaHVztTOGsFmm9JcNiDWt5Plo00sd9Ub+Mw5ZtXrgwTf0cx+MY6ko/68cS4c8LPk5CF+pZ7VH4b9aD81lPbSrhbZSlg8JRYk/mKYdoF2n8NGwThhivWyI9aIh1rIh1gFDLMs6WrajZR2XDLEs6/iCIdZJQ6zjhliHDLFOG2IdM8SytAnL/mjZhyxtwlJfRwyxThliWer+sCGWpe5fMsSy1JelLwwNsSz1Naq+0FJflj7nQoiZLG3Ccty20n10zR/1GRW7t9T9UUMsS7u3rKOln7CMASz1dcYQK8uLZQZ9GFdbl7pQHsatEZ3Fw7g1ujce6A/j4sOfvB4WAL3f9dhK5ocU3igf47sRrjEP+az2h+qiZPkRt5OGWMcNsQ4ZYll+xO2YIZalTYzqBwctbcJSX0cMsSz1ddgQy1JfLxtiWdrqqH7Y77AhlmU7vmSIZakvy3EoNMSy1NeojkOW+rL095b2NYofHY6SpU1YxkxWuo+uLT+sbGn3lro/aog1qh8wtvQTRwyxRvWDvLIGoz2qwkfktTns5Q4+WP7yDFjafFjotUdbXGs92qMtsvbg6RGPsqs9tMdjVrLWI3orER2v9aBv25mAFdDvEt1LWuvhc0v/bbyQJfr1dB5NPZrN5xXxzCifiyxAHcaVe2y/2mOqfus4+NsGLqI8/OAAH9V/BLDwRWucxuk31jey1y8P8CYCbI+HEjAnFdpxyhPa/2m6K8c3YjlWu+39rBWuXtvvDrt0nLS2l/pGOv/mkG3P519Rbu1xXFwjxzyRle9xO2L5LQ4+Nw3J5yaFz4xSLpfwV/jwPeajyexab18pH8QSX+F37X5w+2c9o/3z2Vz8UAq/EPhRyMN9IE5a3xBdRH3j/x3gBV5+XsC4ejosUB7qEPs2J02H+FLHLDrcHKT37Q1KPbRxgp9pGHScwPIFB5/pIflMK3xGLRbZRnloS/yYItrSJZT3KPC5L+zNe4zqinl7IG8d5T0OefzyaPzYDvuGvZA3qG/AmOmWbV1cpguIp2vcRP//MOWtV3D9PrpWqWQZX5B/nmS1lae736o9Uqu97Fx0d4kia4HyovTpsEvHeePKvTEH1jFDrFOGWEuGWCcMsV4xxDpkiPXSiMq1bIh1wBDrjCHWU4ZYrxliWerrRUMsy/542hDL0u4tfaFlOx42xLJsR0v/Zamvk4ZYoSGWpb4s+5BlPGGpr+OGWGt+9fz5VSvdR9e83zoqdm+p+6OGWJZ2b1lHSz9xxBBrVOPVpw2xJF6VcjjHxzVnz/ty5fP5jg1tj5nn9JKv/RUszuN3bFzip27Od2y47AD3oHiffph3bPB7WXy/Y2O7o97If8Yhq1aPiw11kuWjcdra0qBtq71zR8p67mOdswsXO/SE/Id5TqVMdLvDrh647bYnYAX0u0z3ks4uiB3hu11kfyuS7yfzusz4yml8p80WyEf6/xE+gP7F+Hpz0G9P8nyT9sE0eWWb34++DL7Ozx9veVipT07B0tbI8eMtg3zhAJ9l4i8cCGbSFw7WQT7Sfz3fleWnd+iYOcDEZ7r46xeyj5D09QuWQei/ATLI1y8YcyKhXusTMP8EbPGbeR0zUDC1em2gerEM0ySD0P8W1OtLcEAKaeQ3PvMnX0YRXhsVXkHCPcTGspzn4ptWNrrGr19wHtsK6wvLJ+mUbUXo/9BhK+sUGbC+3K4sA9NsSJDhjxUZ8PV+i3sefzr+GkVAiV9pxd+Y46bkJlin4CQlUUPE40/yOo78dpkfbsOuV3isT5ARy0b1EPU1W4+09rcSFDRGYFMJzMYCPbGvlHJB4P1DYpmfw+QPKq/zI4/zg8ra88raK2ylbEHJ4/39rHw2Bl3Djj5KlWQLOHZqtjCRwD+nlA+obE65FwT6B10xduE6D/px92mlPhqfi4bkc1FGPtuG5LNN4cNYWhwZpcWwm4/0fw3+9Ss7dMyxBEz5zIXQa7G9duZE6LW1iYuVOmrP118SpPNGXfJ4tH1AWdPWBi4mWbU5ZlZZd4erK+vUgLJOK7xxTD476Dz4ZGvvPXv2d97CHChiBHTN4zG7JB5m1ieImhaG8bINu7qt9HujIp+WRA5MLMt4kJ74SPL/CV30qwldNAj0Lipmz9NSLIvTUjGJTwEd6/nTVB+kR55C/wzw0UK/T1G9hf67SuhXUGQSeaapvO0QP9sUHT4b9CfJe454Y95BoH9b2KXjpE1jpU5RvacGmMZiO6JsiIlDBrZtUruMb+jKwh/qQ36fDpLrIb+nFH6sS8mPkrTxQbhv18a1Ro74Sd3wHvLPB3q77zKRpxtWHiR5WD+aG3Z8qO9ZuEb4DxOc0CAtpg+DSAGpAH9zs1+ulOMkOJMk85Vx/SLTmYmvNwf9XX8dyY0yjCv3ONpap8iv8Zkeks+0wifLB90mlbryqdIo8cfX9kEef9Btf9BfL8l7woH5pAPzgCPvKUfe00pe1OanNnZlZHesdQ3+SBy2XVI/SMLaTVhY/iBhhSlY/JE4LB8S1lIKFn8kDssvEdZyChZ/JA7LLxPWoRQs/kgclj9EWIdTsPgjcVj+MGEdScHij8Rh+SOEdTQFiz8Sh+WPEtaxFKy9hIXljxHW8ylY/JE4LP88YR1PwdpPWFj+OGG9kILFH4nD8i8Q1ospWC3CwvIvEtaJFKz3ExaWP0FYJ1Ow+INKWP4kYb3kwIquZTF7s1L+JcI6lYK1k7CwvJSdUbBy8V8Jv07Dfbtwp5T5tL/wz5OstvJ0w6/TQb9eUT+8qveyImtBycOxCPOQz8sKHw3rWUOsg4ZYoSHWkiHWsiHWIUOsw4ZYRwyxjhpiHTPEet4Q67gh1guGWC8aYp0wxDppiMVjmSuuj67ljReuuF7KoT/j5aFxKoP0iJE0bxgHmQ+myHwlybzS+UN0fR1hrXT+EF1fT1hYnn3ucgrWmwgLyw8yf4iubyeslc4fous7CGul84fo+k7CGmb+8GTYizXM/OHDhLXS+UN0XQx6sVY6f4iuS4S10vlDdF0mrJXOH6LrCmGtdP4QXVcJa6Xzh+i6RljDzB/q8XWW+YMW5yLWLGFh+dOE9XIK1hxhYfmXCeuVFKx5wsLyrxDWqylYbyYsLP8qYX0mBev7CAvLf4awzqRgfT9hYfkzhPVaCtYPEBaWf42wPpuC9YOEheU/S1ifS8H6IcLC8p8jrM+nYO0iLCz/ecL6iRSstxAWlv8JwvrJFKy3EhaW/0nC+qkUrLcRFpb/KcL6QgrW2wkLy3+BsL6YgrWbsLD8Fwnrp1OwfpiwsPxPE9bPOLCi9MGwFwvL/wxh/WwK1g8TFpb/WcL6UuCu4zuCXiws/yXC+nIK1jsJC8t/mbB+zoEVpWbYi4Xlf46wvpIi17tILiz/FcL6+RSsdxMWlv95wvqFFKy7CAvL/wJhfTUF627CwvJfJaxfTMF6D2Fh+V8krK+lYN1DWFj+a4T19RSs9xIWlv86Yf2SAytKcipps1L+lwjrl1PkupfkwvK/TFi/koL1PsLC8r9CWN9IwXo/YWH5bxDWr6ZgfYCwsPyvEtavpWB9kLCw/K8R1jdTsH6EsLD8Nwnr11Ow7iMsLP/rhPUbKVg/SlhY/jcI6zdTsD5EWFj+Nwnrt1KwPkxYWP63COu3U7B+jLCw/G8T1u+kYH2EsLD87xDW76ZgfZSwsPzvEtbvpWD9OGFh+d8jrN9PwfoYYWH53yesb6VgfZywsPy3COsPUrA+QVhY/g8I69spWA3CwvLfJqw/TMFaICws/4eE9Z0UrEXCwvJSdkbBysV/Zf/pX8B9u/2eailH/KQeeA/550lWW3m6+0//IujX63fgHu8//ZEia0HJ4zXHP1L4/JHCR8MKDbGWDLGWDbEOGWIdNsQ6Yoh11BDrmCHW84ZYxw2xXjDEetEQ64Qh1klDrJcMsU4bYr1siPWKIdarhlifMcQ6Y4j1miHWZw2xPmeI9XlDrJ8wxPpJQ6yfMsT6giHWFw2xftoQ62cMsX7WEOtLhlhfNsT6OUOsrxhi/bwh1i8YYn3VEOsXDbG+Zoj1dUOsXzLE+mVDrF8xxPqGIdavGmL9miHWNw2xft0Q6zcMsX7TEOu3DLF+2xDrdwyxftcQ6/cMsX7fEOtbhlh/YIj1bUMsXnMMFSxcc2zG165zclJuCfL4EcNxKoP0iJF0Dm8cZF5KkblFMms8BWs5BatNWFh+mbAOpWDdT1hYntfG0s7jXU5YWF7Kas/BPRT25uFzcKeoHH5dgZ+t2wd5z1IePgf3Hcp7AvIOUt6TkBdS3gHIW6K8pyBvmfKehjzRET4HJ89Hio5eie9PU93EBnfFv4tDJu1raaxHfgWP9jcI+tfYo8Q+YILqgXyeNeSDWPKYttgo2i++nQXzhA/fYz5Y/rkELHk0O0r4RbW9kI/0X4zbPno0++v0qgDtbPIk3Hu3o65SVmwqhDzL/Q7BX/aDX3H5X6wT90HU3SD2hbzyQaCOK7uMdOeqG8rPdojjQQjXSVhLA2JNK3k+2jQMkuut+VxNVq0eSX0T+WxQdOIan7X2cI3PokMcIw11WHbpUBvjV/J2TtHbDqLjL4uGUG4pASug3zvo3nigv51T820bE+QUvml+HMsLnesVFln8hsZHk1n44PsF8G2j36Jn5cXu8JUf+FzLDshH+n+/pYv5hzGm9txNUl/JAT98NwG/Kkb4Jb0qZm+CfP8NjHv8psK9Sp13OGQWTIw3UOb7Q12G/47irjDorfuu+HdxyKTFXcJrM8nL7cN10dqE7e4ZRQ9Juo0SxikYxyD9nw4Yp6B9c5yCMklZba7HetD4uMbJZzLymRmSz4zCZ9g4ROOjycxzqiihP/kP5E/irJ6+hWXlOfhJov9X4E/+2uFP+HwKx07sY9mfCL8kf8L2KfR/5/AnWmx+d5gss2CiP0GZ2Z8I/f9O/mQJyvv2J8JLGy/57bKDjpebFD34Hi83EZ/QkE8IedJXtFiO/c8S8eF7Lv+zRPVJ6q/f3ajz1Por2u4k0Z+G/vrP1F/R3kXnmt2ElBcqfLnPBEH//CxKLl8WJmBlHaOEfix2itoYFQb98qFvds2lQyqHNoJ0SBPC/SWq37iDB9ptT92C/rFzL9EuEW3ooA1JJpTxwfja79x+riJ94VDQnyTvsCKz5OEzvx8Iu3Scxuk31imylV/Z0cVlOpYH9XQ4AVPzFw+HvbRS5zEFd5lw0QewvuQ9W9z/r40rE/X/7TM6HttJlOTrun7nr3NVbl9M3L6sH05a+4rcUfv+5QDti214hPLQZ0sMwPM5xIh0f1vMdFT70kr6y18O2V80ffIegTZ2oj4nCeO9YO93kL0LDY8XUZL+I31W9DehlI8Sx35CX4ax5+adOn9XfwsC3S+gHvidjIcDXRatzkJ7N9kj9jE7e6yWpB2PkszI+5gn3jniFwT6Oq/wn1HkEbnzSt7EELLWSrOz5Xq1WWsv1OdqtVaO8EVWvsdrlNq7ILYo9KLr4150XWlKVxsPu/jPg16jNAF5xyhvEvJExqgP3bazV/7nPcmfRf/Iv6DQ7w67dIO0ZUHhw3OOYbDCFWJtCXr7gDYWLkE5HgsxfsH3gD6c4Jez+Drxbez3sZ7sBx8gX4fjn6ENVbV4lH3dUU+8s/o64T8TJLdtXskbxtc1a9VStT1fW2i2K63mbDsX9I8J48o99nWa3V6k0Hv2FUXN17E/m4C8o5SHvk5k1Hydn3GxUsyif+RfUOjZ12Vty4LCh33dMFjhCrHE12EcxHHqEpTjOHVZqQ/6Op6XPUY+yc+r7/U1QvapKG+UcA69DHpi/TIO3sO4Gcvwmo3QPwlx+74ZXT6pw12KfNqZIqzXUzPJdMsKXbRUtjm+f39r/wceaOxtNT/QWtzb2j8e6OJxFbn6PJ0KiC5KE3TvAP3m5ZtJwpEheCJIT2gSiKU1HWLz0PsMTHlmyYXtJV674r/FIZM2deShNoT7dl2qnHlaIfzzQb/J+Tg+EpI8rB8eHpf86KcYDcm89B2ldtivG5ZD7IWPAUq+9lfqy/d4mEBbZLtxucAkl/V5cFkvzHTp2QdkObKVZSse7yH9w5QXQl1yDnxeBjkN/fhLtLSDoY7Uo/PRSciz7GeRHG/e2ZWD7QnDqCT71z7fIPRLCj1iyFaD62iRZltoS2IjWjtLGW07vECyDrr1X1D4+O5TBaoP2jGHeINuPWr2m7aF9pWEPpm0hVaBfKRfgi20r1J7YnnU87l6hd28Veoz5UH7jNYOrj4TKvTaazm1LdYfCXvztD6j6ZVtZ1KRQRvnNNsRuizxA8pn10alzPGD8F+t+GFvRr2Kfp7zo59iFh+h+bVQyWNfj30f6Z+DOrKvXwI5eBr3R3Fndx0pcPUdvCf6PXf8j6YrvuMgV39YKR/Eks+2yD2ZS/xriKH++5nk8vKplikoox1H4PqgDeHY8Kc0NuA2iWtbnuc+74Sx4d+ucKz3ecwvzb/zJ3CwfFIcukGRK7p+PL4W3cgSyV9CG/9FwjQ8Stg+f0Ptg75Qax/hrU3vpSzisox/BzL+raPvoYx/n0AXXX8y6KdjXxQEehzCbYjLExo9+jak/z8yxvNiD35jk5Iaz2P7c2ySdTxiPSE9YogPKhA96zBKYhe5+PxZpPv/i/q35kdX2oeT4sgk3+952XA+i89H/vnAZ8zUjVG0T/S5bGJJkX8hTKZPsyGhj9Y42M/jnEv44tdOl+kej1GumCZK6HsmNukYWD8tLpLX0yNGFt8/qD1rdRqFfpPFrjU+rpjpGUM+2J/D+Nrzo3VV0f0hkFOLkZF/9O8w1GGcMDT6JZKf8fm1elJ+ItCP2Up/4HHvHeCzt2/qxXTVMUryOcacItO4QrNEMh8Jurw1md9DMgv9zlhO7dg6jk2s5yjxUX2hvwow+QPxuEWdxY9q22i4VSbyaMenj1I53K7jNtewectcwzlCOFzPMbi3VcHWtoyjf7vi38Uhk+DJluoE8HhekWeS6G8nO36BdOrSWfTvuMIXX3+4lfgeJ76RDd27sxdTZMP5ALY7t8kS8WA5H6F8oa9Afy7RuIfjNY6P85t03jh/OOaQ9agiK/aZA2FvvtDPgr4+sFOXFeVBWc/fuqEem4uM5+oZ9upH8x9Iv1L/oW3pL1MejsVLxEdbGwyBhv0NtoNGz8cnhX43tLPMrVzrjRH+OyjeCoGO1wA6X2wP3ONU2rb3XZt0XG0NPEqtsLe+Qj8P6xz3bNJ5Rwn74L0D8t6dwPsfL+pifoB0qK19WMZ/WltdHPTWKyQsvscxHpYPSebQQOaCQ2ZtfOZYfynor8+Sgw+WX6L6LCn18RzPZp67Cv+8ohMfc1dtbunaazmk0D/noD+s0GvthnNX9K0B8cW562G65/LFaX7hoQH9Aq4dI/2fgF941DGXjYurPuOSQJclCNxtVFDK82uKfM0LL6H6POeoz6D7rFh+tR7xvIT4JNnNM2Q3cdbAjzD/PNjNQYfd8J6ktgettUGWNXhXG+zNyOfgkHyyPv75RrapU0Y29RmwqVcccd4bXc9LhnwQS9pMe31dCNeYJ3z4nitOSjpOijJEbfyzm3SeWe1G6J8Bu/m5DHajtUFIeUsK39U6k7Na/tCFFSpYQr+k0LtisKz7Adpjl2Lbfh87yX6eRPjnSVZbebrxrrZGcEjR3cagu/bRaO0rlefe3lrc+/Tj+7kxBLAQ9Cr5MAEKfUC/uVwk1ATRPKfwiBK+JwQNiQ/qcUDN+FlkSqNNy9c64aGEegZBtk6I5Qd95yE/nyr034JFlCzvaUDjGeQ9DWGC7ONKHfIJ5XDRGPOwzu921Fno/9hR56XAXefdYW+dQ5BpicotQV6YUGe5vz7QD1UIhqbj7UGv7IPaE5ZfrWBlO/FJGtz/NGHxOOng6KOQj/QPwuD+b2lw14Jv3/VPeicT1utRoAmJXuo1oWBGSQ51sR7+Iq6754Uf9VmnpIAO6xe1z19uSteNq82F/iPQ5n+Toc1d/Ud715jLV3xPBzKlVjGLjSP/7/lA5q9zvUrOGshwOVcgw7Qh0YkhDRvIaDIl0Q4ayOAMgAOZQU+MYHmh83uaqtx3ohl3dbAzJb3oEE9YuGZwfPqK8XkAwIc1Nd3xCQuh/78hiLkv3jXU2urSBPmCIFtbYfnVOt1zKfHxsYobJV7RWO1gPckG5QmOtCBpfHMvbtqAyU+dCf0GGDCnYkzXKsJKV2rZ5oMg2wq/q79l7T+sowkFM0ocQAn9tbFe/D7ZWiuev127WubBnwM67VRFXskb6mU9s+1SsV6frbTLjblWrc5jpMjK97Ls6F2t0PtdMaqqL+s5BHqN0gTkLVPeJOThziC/wMJPYFZtZtE/8i8o9PzC2UFXjS2w5KUTSyBzDHXefFnSIg6/wFvob4p9U9YXQmsv/XW9QJgnQ1xH9olR2hX/TbOkdkoSftI+6xRZQtKL0N4Jerlha29dQqUu4qPGHTwC5V4uSNYd8xhTyj4W9Mq2lEE2LL8EvMaVciFhrNYJFI3PVUPyuUrh43PnC3mmxWNvoXgsbUfqibCbj/T/X6GL+XaKx7SnjoSftrDq+mCAlJeTd0zD/kbo3wX9Ku2DAVhPl51hPOb6YIDQ30Px2PlY0OI6TwTd073oH98R9tZB6HdCO79v82CY70zAfG5zF/ODA2K+KwFzD2D+qMMeLwt6+WknQbUT7gWlPJ66RVmM27fz0aT9fvA7H9jZp+gC6yT8h30KGHmt1lPrWt1c7Ywfj+OdaQ1r34BY00qejzZ1PR2J/Gccsmr1CEknGp/LFJ0I/RMOuZBe+jDavpQVHeJH+Qx1WHa1N34kUPiv5KNJorftRMcfTULd70/ACuj3dro3HugfTTr3BprYz2vrJpsTZBYZ+B7bP5Zn+/fjM+eK2klpSRyLsYycxuk3yh219z9t6eIyHWKwHSd9gFTzuUkY2lpuWr+PEm5GbIuv9+3fs7d1794Hn2zsb+1+svXYfsV+1we99Run3/wmOpQV5ZohOt7M3Ee/n6LfTyvycGKdYJpR6JJSWv+4Ba5X0j+wvGv98toh+Vyr8HFh3aJgufz3tQr9heK/ryM6mXMN47+vo3tJ/nu1nphmLJw/7Q67NLyGL/RfpvmQn9hnvvNxA/SdojPh/YQn3jniJ/rGe8h/RpFH5M4recOsT5fnKqXS3Nkt9FaxWmw0i66+jPe47z+p0N+m0Iuun/Kja/UFy0+CXqM0AXlPUN4k5ImM2vq0H/80n0n/yL+g0PN6Sda21LB2rxBL1qfRx0vfXi3f5NenDB5P8tsfcD2GD3IdAixcS+ekxaFS38huv7y1i8t0LKv2RNbmoF+H3FaDzn21uabf9YzVayvse5y0tpL6DtpW2B4it1/ftHo6RJ/DSdOh1DfS4TcH0CHa2hLloa8VuUdNv+OUh/uEbw+7dJzSdHjJADrU1vXHg349TSpYPH97QJFHfMzTQa/82H5R4v1ALP80YT2TgrWbsLB8lidfEOsewnLtyYYpWO8hLO3gumAtpWA9SlhYfomwllOwHiMsLM97DodSsPYQlrYnL1iHU7AeJywsz29zOJKCxW87xPJHCOtoCtZewnK9feVYCtY+wtI+wqGtEWHMNqPck77u94MipYE/tKXNf3zsDWh61+Jc0d3ziqwFJQ/HbcxDPs8rfDSsvYZYBw2xnjTEetoQ6xlDrOcMsUJDrCVDrGVDrEOGWIcNsY4YYh01xNpviHWAsLS5tebbNsb/onRuH+Btjcf3PfFIK6DE6/38+6kE/gWlfEBlc3Qvy9cNMNbktRDxv0lvxOWzI0J/Ucx4fdB9a5OrfJSyvIXV015vOeu4ynvuvt/C6jpPECUeV7X1o4KSx2sSkxn5WNh4lN4e6vxzSvmAsHLKvShpe0zYl64hjKdIXr7HPgLLC53G59oh+Vyr8HFhXaNgCX2o0Lv2mFxvRV2CPOu+F/3T5qwh8BT+K9ljEr3tIDreY9LmrowV0O8ddC9tjwnbdH+CnMI3zVawvMsmJ4fkM6nwYaykB7R5L0vo3x73VbEv1L3hOlHF9XyR3+c85jLvZQn/GUUefvM35g2zl9WeKxcXK+1WsVZZWFgsNl0+A++xj1lS6G9Q6D1/kF3dy1oCvUZpAvJCypuEPJFR28vy4wfniln0j/y1L6Fw/ObCitKYByzZy8KxRPr2avkmzz5lZPey8EzPIPsj2B4it7aey22ljdl4z9VWTzv43DQkn5sUPjNKuVzCX+HD95iPJrM2j8HnBz5S6JbBfoLPD2DZ/WE3H+n/NzhX/jHH2SpeE+I+gTYYJe73+JbbLOO70C/CHJCfH9CegdofJsssPLI+zyn0D1CMEQa9dd8V/y4OmbYAbkC8XG/QZX0EQbdNXM+Xac/keo5lStrzN5I0v8Zn3XFNi8/u4BrVk5SHew33hb15/MZ6zMM1+KcoT1vLlbzjkMfPwuOb3NFGOWm+OYyvo/5wy7YuLtMFxBPtZpnytGfZtfOCN8M15omsfI/tDcvvTyjHfsTz2cSS5z7dOf+vPVuJdRL+rn2hLOML8lqtfRutbq6zTrjvwfsWGtbBAbGmlTwfbfqko96aT9Bk1erB83mtn92s6EToQ4dcSK+96EjKrtZ6jabDEHgK/5Ws14jebiU6fqYDbfBgAlZAv2+le0nrNWnPgZ4p6DJnfS+H0P8biOM+B9e8lolYEgdtpt/R9bPxtd8189lFbV2Fdfcs8OY50HNKfbKOpXhmb2qFZ/ZQNsTE9vs00CTtdfw8xLk/vUPHzAV6bM+xtthE1md1hf5rjlhbaCYS6rUvAfM7YIu/nGDrgYKp1esJqhfLsJ9kEPpfU/aRgiBQx9kJ+P1w2CvbkwqvIOEejwVPJuS5+KaVja4/Bdecx7bC+or+yT5lkk7ZVoT+9xy2oj0L5TorzTIwzRMJMnxbkSEaJzbE+Yt7Hn86YWsJ1c3uWWtKboK9Ck5SEjVE1ftOQceR3y7z07blgoR73AxSFt9512w90tqftPc2RmCTCczGAj2t7cN20or3YZ9QZC0oeRwvZuWz0n1YtoWJBP45pXxAZXPKvSide9v/utevtbkor30MOhfVOgdjJb2LYzHs5iP9n4M/4i/47Qc5NEw5syr0WlzsemFo2vxS+IsutXmKi7d27lfowwFlXVLoQ6B5kmRF+ZYGlHV3uLqy7h9Q1qR+KWPYWSf94JOtvffs2d/CrsJiBHQ9TfeSjgfJ7ycSRN1IdLzsza8u4nGTx6QDinxaEjkwsSzjQXri93n/HXTRryZ00SBwH2vSjuFjyH2GplzaFpbLHLO8hgddE2Lwa4KE/h8crmk5cNebu8QhhR6XbMP4WjuaLmW1bdbV+bB5sal9PBF1MBlmr6+mH+2IPC5b8+s8cNl6ifLQXnjZVvtoFm4Nacf52SVpdXMd5cP35I8rGK2wm4/0/9lhf9pjAK4Ppw36cVvUr5TV7A8fOYrSBOQZ2l9Lsz/UAdufq76afrRj9LjFIe1bIHrUlfZqM+Gp+T/ROb7aTNveziX8FVn5nutowV1hL58lQz6IJduC7C+1UC66rgS99PhBZc1fMr3oGZdatPabJPpL4lfz4sd/eek5Srj8eOlFOm/s3wcVWZl3FV4LvCO+doVv/MrcK0H2D+9MLh8GvXkh5PErO9B2+TGEZaWe2Obsx4T+epDzo6DjKKEviS99+5L2oGOZ5mtdY1mar+XxCu006fsViIU6T5pWaB9nRzyO8e6ENuKP/eKYuUyyPzOg7Fljw4NYD3olnjZuudpK8/vaa8SPZMBadtT3KMqs0KOfQPrvU3TPmJOBbkuHEzB/EDC/PiDmowmYbwFMjke08RNjHO4j2mMi2sfKtccFn6c8lD0EXMQcU2j3EH/t8cZA4Rs45OUxN03epfiax4YPwdhwd3w9TXjGfrHiastblfpkbcuDjvozlpSbCPrtVetDxxR9feAiHXNyQMz7lPFVi3UeCru8P5QQG0SJY4MosQ88qMiFMYfr1cIcH3xM6a+uo7pex91Sq6iNu6gLHne1Obbre0Fpc2yO4ZH+gbA3L8s3pZDPSsa1v6RvJ2lt6tIF4u4geqkb+njUxUOQj/SPOXy8Nkd3tYdm+zivFHm0x95x3nSufNjNO5/26ooTNf0sD6Eftlct7tHsdZn4LCl8stqrlMVvxmlrJPxx1EMKhktPh5R6s56mEug5BhL65QxxFcoQwr2Vrg9oY9yxQOeNfRN1wh/SFfrnM/rz1VmTKZW0/oF65f7h0mGUBo0Red1Fe1xa6x9HKQ/tk+cTaeu8rr4jZfFjyq4PHw/aX1lGbV6u+Xqh/7zD12tjqcvXp/VpkUfzHVL2/K0J6LaMOsji613znWF8Pc+5taPHab77lMP+ktZ5UNa9jrpljbsG3duIL89L26/m3ga3vba3kSOdIJbmG7T1GY63EHuQeDNKMkaxTpLiTV4DFfrfGTDedNnh93S8uQI7HLV4U/NBYXwd+aBnyAdpn75z2Z9rf8vCB40rci0BrvYYbZR2xX+LQybXnozfz40VazniJ/rAe8g/r+jRUJ6Sq11RP2Okn8N+5Dm3VcO2H6V22K+bJL+To/KyFxal9wCO2Kp2zBv3of4drTVpcSCWFR4cB/4FrJ39z4SpPR6XNf7Fxxcfcswdw6CXp9bmrs+6HQY+Gj2OTUj/N475oeYrNbsT+rQ9H/58p7a/zry18wLaWCr0fz9S88Ny6Xzv2fOY5Zo7hpDH+0DaWIT9gvuAFnNp/RU/Waf1LX6NZgi4PF4ukYxRaoVdmsmEOiX5CnklJfuK7w44Z9wG9waNi7nPaHNGF2+tjVw+A9styWf8Z4fPSDvnwzrt1GFLFzPLOR+XTi3O+WTV6e5QlzWrToV+PdQ/yQ9n1anQb3DoVNORS6dZ/UyWtb80nfKRZm1P2aVTod/i0Kn22gOXToX+4vOoU6wzvy4WfQb6iPGg39/lE8ptdWAeTsB0zb8YI6ktNZ/GbXmVoy21eh3OWK8jRvU6MmC9hP5Nnur1TEK9nhmwXodT6vUM1Uvob81QL22tNkq89i/0dyh970JeMxOdaWtmz1Cedn7JZRMrmd/cS/Mb1ytHYsjER2XYBoT+BzLawOqcCddtIOxWo88G0M7HFXq2AS3uXgIaXq9CepknazYQEh8rG7hrUy8d1jeX8Fd48j3X2Vp8NRXWG+cRuEbxHqI/DHy1vsj00u8mAt0X8/kTob8X7JXP1k4q9Yl0+P4tOu+kvsJrGkLf2tLF/JH4Wnucn8+/us79LymyoJ653wr9j2XstyLX+ei3aF9ZfDfSD+q7RWea72b/PKlgaa/M0vq5yKi99kBwz51rmEmXX1tLFvqVxj8PDjjvQT1VEzAfA7t/ZEtv/bEd5bxTRPfkFhvenxxwfuB6hDBtfiDyuOZcXG9uqyfJL7j23aRc1ngU85A/xqNavzqi1JF1OBW45/Y8f3hWsbMsZx80+bKOi4dA1veTnl37PksKT5edZI0RtDU03Lc6Vz7s5omMntdIy4P6Yld9Nf244m7Uj3YePiQs7RNCrr1nly9GWxHcyFa+EjeGtkf7TIa64T2OoVzrJiLfGegrfG5+CcpkiduF/nMOv5i2HrTSswTaPudhRzm0oWmF1674b7HYHioJP/Fb6xRZksbLnwE93rBVlzXXJ+9wSRs7c6QnXkex4V0u5ohfEPTPFXhs0sabXSbydPdktTVprd+Jfo56kafUxj1ZtF/ck8W20eIHbe0C5yNfo9hI8wHoT8uQj/S/CnHZLydgBsHg46yUjXC/u7EX1/qMmuv80BHK0+aHrud1RIa0Z5P4LKPQ/w74BtczhiKX37Pj7fN+NlZ0luXTS5r9oS1k2Ts7ouDzuugfO+JQ1/nccEDZlxXZuZ9z3/kaxagh0B3MwFPrrzniqa35Rtc7IB/p/4dVjBtEnrXzubrvc52N4/O5aC/CM813/4fYd2vPb2f5/KZrrxv7I6+7Rtc7IR/p/9phf2nnQwedh4Tx9aBnhEVPnu2vfL73O3hPw/X+E9fZTO0zQ5H9fSu2P596nJ0rdmJaaUOxSU4TkI/0/xjbZB7qIX8nhpCzPdsotSuNdqPWaDari40thB8labPoNVORPfzDlq7ORE/WOouS4E/6we889zsBdR1X6sTnEseAPpfwNwj0OYvwyhOWcd1Krrqh/LxWMEHyyHUS1sSAWNMJebts6t1p03FHvZl/Er3WB+T+lAMf6bW9lynSxTo/uii72m0KeAr/lbw2W37vJDr+zBnqezIBK6DfO+neeKC/Npv90kzQX28p49mnZH6dqPDPB177Q8cPaPtJWt/F1wk+sqfRjN/yyS6Pmw7ViXBcbW66zrBI99gcxqichHraEMpy5hQMTQX8hfqcwl9zJeMJfIOga67sPtKw5HrcIUsSRo4wZhwYa11nresoaa3rZOs61tF4rVEst6qlhYVaqdWYn28PEo27olPPkXo1a9eVe6sV/bqiQNQluz0sy9FslORtgjklb5DI2BfWTNBff7YFT24z8xN1PBPyZJvOmdC4oldtxUrK8kcFo8Ttpw0X2grR9woW+j8tPLg/7M3TfCX7JtS9Zqsye2AfJ+PLlIIjeTib4lmezG7w/rqgvy6TRH8P7bpOE/9d8e/ikEn7qN801WEd1IFnc+dkDXvrIPQPxHWIaN+3tVdnU8QD81CfPKtdT3rAPJSb20HGTVyZFSytDkL/oVjutBOFOMOO0kTYK+eu+H5xuFTVVkdF1nPyh7313gB54wo9xyIbFfoNQCM6KxC91n+1/o8659Vz0eGUQo94k0S/CG3Eu11o13mSHeu+jvK01ThtlWkaZA6pz7LP2BX/Lg6XZmeCfj8iaUbRG/tS7CfsL/MkM+ahHaAOOGkxtugikuvjtGscKFiWfmIi6OU3Kv0WvzLA/Rb76LhCz/02rZ/zKX1sS7ZvbSwYpM9EiU+oob1I22CfSRp3tZiI/YW20hclHluF/hj1U0+roerYKrw8L23UZ6jOmGaUerOPwP7DPoJjEcxD/zGojxBdDOojtLhR8x/sI7jdo6T1Ae4f2AemKA/HDe4fGMPKm0xzhBkEeoyVZb3Dx/pAsdxcrLfKZzcUZ+ul8nwzbX3Amn95bq4+X14oVmebi+1mtbLa/BcX6gvV1sJivVStV6rF5iDrI7mgt90x9kQ7GYN8pP8FiGv4hOyYAzNK/KUVof+aEs+ynEHQv5aF9ZT7rmVKlGdz0N9veIdztex5tjG3ML84X21U68XFszY9SHu6/I1LJ645r+ZnXFjYxvvCXnotftbiWB4Pf0+JnxkTTw88EabLjHaAfozHZKH/NsjwWccTbKIvzzH2Yo74BYG+piT884HX8bzE7SHyJNmX59hmIUf4KM86RT9aXMGxvcQV2hwdcceIHq+lPN7717FtFQgzSrxmtV6pD94T/Uay/8utvXXDtskl/BVcvsd+AXXDvhL9NJ6g/jP60Cn2d21dV/wH98W/gXWbP6d1G832efzIBen7JcgvyV/xuCj0/wv4Cv64K4+LWE+WEflNKHyjxP5K6P+K5hCe+r06h0g6HYT1i8Yu10kQV/91ncjBuZtGL3i8nvm/OsaY9VBmXJGLYxmh/4+OWGZaqZfW3+S+a76N8mjrC1L2/D1pXFzU1hdQh5Nhun7WDaEf3q/AuI3XDLWTQOwTkI+276vtn6E/+TOwjSxr+a7xFe+xn8byQueae7r6HdIn7SNMJdAn9bv/MmBstz/sx2QZssZ2Qj++rSvDT2R8O8HkNres7NdwjoX0G7d1MdfH19I+3PZR0uJyXhvQ1sDQ37rWLLV1FVef1Na/uU8mrZdjPIX0W6A9xCY2B/39djyBH8qn7SVofSOfgKW1Z5Q4NhH6S0F29vnaGqi23yr0aXsdIo+mm42Bzhvrg+25n+oj9Fcq9TmP69Tq10dRrzyOuHQYJdb5jEKPuuT15hnI4/0b7KMbKA/58l5I2hzK9RQgzrEnoe34TAzqQOScVupr13aLpRzxk/rhPeSfD/pt3secNauNiH5m/Oin6LLBGUU/Is8mL/IUK2IrBYW3yBq/BLPHryD9DOgQ6fFayuO9H4ptV2TYDOUEv0B5UeL5MuaNK/fGzhNWQcFCvUmbRv24SrrgL3lrfwWX77GM2J5i8y4fsVI+iCVxlNafon+74t/FoVKlLPXYpNRDeKNd2fWd2mxWXyf884HXvlxy2TDqh/fSCoqshaDfhj8VdunS7Bv5aFinRxTrkCHWC4ZYJw2xLPV1zBDrRUOsI4ZYBwyxLOt4whDLUq4lQyzL/mjZjsuGWJZ96JQhlmU7WtrqK4ZYlvb1kiHWZwyxLO1+VH2OZR3PGGI9ZYj1miGWpb4sYxNL+xrVuNDS7kc1lgsNsY4bYl0Isdyo2r1lbLI2pg2GNaqx3Kj6QstYztIXWrajpb5GNf562hBrVOOvw4ZYln3bsg9Z6styHLLsQ6Oqe0v/dcQQa1TXhiztyzL2HdUYcxTHjuia96wsxo7NCdh47dob1vjkFJm1PWU8Uzod9NfXcl9Z8Ld4wpd6X6ToCusk/HmPWfK1v4LFecIrT1jGdSu56ubai8Z9d9RBEtZFA2JNK3k+2rTgqDfyn3HIqtVjxlAnk4ZYfFZP6//a/q3Qb1HoNTvZrPCWstK2WyHPsG3LrrZFHyH8V/JWPtHbfUQn71UYC/r7xkUJWAH9vo/ujQMeptXy7/yb33sRJTmPop0hiv7tin8Xh0r1ssu3+h1n6pUc8ROdBqQ34b9avtvlw6LEZzCy+LAoPRN26YbxO1F61RDrpCHWIUOsJUOs04ZYlnVcNsQ6YIhlaROhIZalTTxviHUh2MSLhlgnDLFGtW9b6t5SX4cNsSzreNwQy7IdLe3+iCGWpd0fNcSytIkzhliWNrEWf70xfLTlWHvQEOtC8IWvGWJZ+Zzomufaw8j1cmiHZdmHLH205Zg2qnHhqI5pozq3stS9ZR+y1Jelj14bO773x44oHTbEsvSFLxlira0pnL8+ZKl7yzp+xhBrVOdDlro/Zog1quuFlnHOmp84f/HEmp84f7ofVT+RJf7S3tUve+zaPr5gbUnB2k1YWH4LYW1NwbqHsLTzDFJuWwIffLcGnsHYpvDW8AVDO8cR/dsV/y4OlWYb00o97PDLTdkPvxjqnYv/Cu9L4L7d3n018/tWhX+eZLWVp3uW4BKSh/XDZwm2K7IWKC9Kz4VdOs4bV+6NObBOGGKdNsQ6ZIh1wBDrqCFWaIh1yhDLUl+WdbSSS/Ozo2KrLxliWfZtS5t40RBrzX+t+S+fdbTU/ZIhlqXdv2yIZdm3R7U/WvroUR1rLdtx2RDrQhiHLoQ6Wspl6VdHcdyOrnnePir2ZamvVw2xjhliWcYmozqmrfXH81fHUR23L4R5mqWP5rNjb0S7P2mINaprHa8YYvnw0fxcYJR2xX+LQ6VKVdaice8kF/TyxVjEcN28lSN+oiO8h/zzJKuxPJ11fG0vB/UzRvrxs89RbOYIH+W5RNGPtq/AceSl8W/cx0L6S6COSI/XUh7vvRYXtPST0fPWp2PcAfpAebFdqtRas7VivVGtNeuVcrM8W2xWa+1Saa5Unq/OVSrtxepcc65caZdny4szQX+7cx/w1MbVrH2A97I89UnnXtY2pY0G3ct6OOzSjdL4e3/YWx/Xe+r92EJlYaW24Ps99ZotuN5Tn9UWng27dMO2n2VMbTmXPG6IZRlbjOoanWWsP6prdKO6L/CCIZblvMFyv+JC2PMbxT34KK3tA58/3a/tA58/3R82xLK0+1Hd11zzE+dP95Z1/IwhlmU8Maq6P2OItdaHBsM6aIi11ofOn+4t5+6Wc2R5hoLXkKK0K/5bHC6VpxW+RthVwb50eOwm3xDsy+zlbgv25Qp2qVIpnRVnttRutiu12fnyQqleqdfb1fZsfa7abNeqjeZsq1RtVMrzrdliuzTXOruqXFmcrbfnm4v1DvYOc7krNVlLw29m4zfPr4sbWWwTv2k+TmWj6zHIR/rj27uYN8TXM4AbAEaUpgkvF1iuOZaLOeIXBPoaqPDPk6y28nTXQMdIHtYPr4GOK7IWKC9Knw67dJw3rtxzYR0zxDpliLVkiHXCEOsVQ6xDhlgvjahcy4ZYBwyxwhGV67QhlqXdW8plqfvjhliW7Wip+8OGWJZ1PGOI9ZQh1muGWJb6etEQa1T7tuXYIfGEPHuN8aN8935z0B87baC8CchDDMxD+SYc8mH5iYRyXA+Jf6cof1f8uzhcKgn+ej/4nW83rFN0hXUS/hLPTgJ9LuGvYHGe8MoTlrXuXHVD+dkO1oE8/I0HDWvdgFjTSp6PNp1y1Bv5zzhk1eoxQTrR+llO0YncX++QC+k3K7ylrOhwGvIMdVh26RD7ovBfyXcvRG9XEZ28L2Ms6LfBdQlYAf2+iu6NAx6mzYSh+VHuz0ntW0goH6UZB58ZpZzUbwPIeCXkryceVyoyXumQEcsLncYnNySfnMKHsbQ1migtht18pH8lXpeJ6vCVHb2YVynyufri1Qr9VUAj8mi6kbIzgW5z2l/hEwRuG0IZ2E9dbcjnaqCZJD7XGPK5Bmg2Ep9rDflcCzQboFz0+zrIQzsTX3oT5Nv50vK81PPmoD9J3i1w77NhVw5O4/Qb5Y76w81bu7hMxzyvh7xbKO9NkHcr5d0AebdR3o2Qdzvl3aTIs9J2xra6PqFeFnxQR28iPm8y5IP6voH43GDIB9tO2mo66G+782X/2LaSdyvkcVvfBnncPrdDHuv0DsjD88uctP4meor62zsy9LcLXb+aXUpa0283b6X6xXGN05p+u3lZ9LsSHS4NMOZiW0mdJL6V8n8Pe5B/S3uQONe8P+zN2wl5d1HeFUpehP/teCNY4lvUA88xcBwaV+655hg3JGBNANY0YMm7CSeJfjzecPdrk/VZV8wivG/2xDvL2I78ZxR5RO68kjcxhKztxblipVivN1v16kKt2s4F/X13XLnH865bFHrtO4Oi61v96Lrc+e5w2MXHWDhKE5B3M+VNQp7IGNn9bTt75b/Fk/xZ9I/8Cwr9PVCHQdrSJxb6AwusdSvE2hL09if0OZ7HxTnNB0nS+nyB8tDmLqI87E/8rWkcM3HtjVPauPiFnV1cpuN64PhwcwKmjAXXQb6MZZNEuzUeJyL5C5f28sL54XvD3jychwmfCOOWS7v3kY82HkfpoQS5bqTxy8+aQ7WpxVQ8ft3iiXfW8YvXHFAekTuv5A0zfi2U2pVWcWGhWl5o1ur1ums8wns8ft2q0GvvthVd3+ZH1wva+IXrNVGagDwe23D8Ehm18cvP+FtdyKJ/5F9Q6B+EOgzSluLbtbhJ8xUPhL15uP6DMfUt1Mf9xInlhrZ2GJD82G48PqBN8viAcyMeH3DuOej4ILoYdHxAP4l1QswJuKf5+Emin4cxYpbGCBzThXdE9/vUtqgnw7Ztsa4DRSd3wr1B14xF7kHXjNGW76Q87K9FysM2K1Ee2mGZ8m5X5MkyvkSJ40Fsq6S5kwUfLe7W+uqwfDT/yPq24INtJ23ld1wbzP6xbSWvCHnc1iXI4/YpQx7rtAJ52+Gak9bfcGwdZM3tQtUvntPgtKbfbt5K9YvjKac1/Xbzsuh3JTocZM0Y2wrrNEzs82mKY/zMBYvFLVQv5LUWQ63FUEl81mKoN/YYFKVHwi4dp7UxqJu30jEe1zI5rem3m7cWQ/WnCyGGyrrWkzXWel/4+l+Otb4D60zfvjRZrhuB91vjh7/XYqS1GCmJz1qMtLbOhGltjFlbZ8I0CvrFsZXTmn67eaMQI2FbDbrOlBT7jFEccz7XmTzZSFOLIVi3aD+DxlDYnit9vuMOyvMZX6E8K40FsK1W6/mON2qs5vcMx2D2j22r+U9u62H9Z5QGXWfCc5yDjEEXon6j60HXmVaqX+RzIel30BhK9DQiz3eMlH6z6nClz3egjfKYi2s9QodrPYyBPPy2UfZvDwn/fOCzT3bfXXEjycP6kfFvY9B9Nvv+1v57n1h45MHFu1pP73vLY817G3v3P9h45C3N5t7Wvn1YG+Qwo9SWrYVp5Lqg3EeMm1NqIW882Bz0t/LNhHVLCtZuwtIiD8G6NQXrHsLSogspd1sCH6TRVnhQnttS5HlPmCzPbYR1ewrWo4SF5W8nrDtSsB4jLCx/B5W7M4EP0qA3vFPhreGz3RZTZN4T9sqMchUJq5SC9ThhYfkSYZVTsD5JWFi+TOUqCXyQBkdS3H3MKfc0efaGyfJUCKuagrWPsLB8lbBqKVj7CQvL16hcPYEP0tTgfh345JR7mjxPhMnySNksIxzKajiiZH4qQfiv1giXpld+S8ysImtBycMxBPOQz6zCR8O62RDrVkOsWwyxbjPEusMQ605DrKIhVtkQq2SIVTHEEp8oPg3bdSvx0WKEOxx8sDzPFLBcLuGv8OF7zEeTWVtJezB8/e+5r0xe1i2DNohvasKyMhZNEv3JHV3MV2NM0aU2U5IxAG3Lzud23yKOY2tAOsHxB7/2yUmbNYrcg67UYhvxWIn9f5bysD/PUR72qXnKKyvyrNS+sK1Wy455xfpOQz5aHMz6tuCjxchajIn9BPOED99zvVmIV+yT+v83LtN5JvV/if0mif5Z6P/fpJ0gjDcN+3id+zEmLYbikyBzkMf2PA95bINvhjxsW06a3xBdDLrahGOd1GmU9BulQXe7UBcr9aHsJ7FPs5/Etkryk9i+2hgyrC/Atlrzodn5YNtJW3mOIQb2LzXKs/Qvkvd9kHcZXHNKi1kG2S24UPWLPpfTmn67eSvVL69PYbLUL7bjG1W/WXUouhg0/kAbnQV8HgOQDmPIpHXuQMFgHB4Xpc5jSln52pW21r2NeGjr7XiPx6BtiryuMdVv/3797efIT+qB95B/XtGJj3XOcka9arFtmXSOebzWpq3nVxQ+Ghb7JS32mg76+5ihvqpZ20/45xU9+Gg/bT9pm6LX1bDvpHa+0yFP1Y88nTewafs12vpf9KaVqSBIjF/ZJpP2deReUtsgb95fdu31lVOwdhNWUh2S2gixeH9Z08Ek5dVjZx7pcOflvTS3xzR3AM2V8bVr3uZ57ylzn+a9Jz9zePfeE+oHbXZd4LYdbLukffnblbqyLd+WIhPb8qBnABCLbdl1BuDOFCy2ZSzPcQH6aj75VVHqI3lVRb7IxsuXJ+Pf6cAvOvDLDnzXyWJcb6xQHq5rVgH/zQ5815vpb3Pg367gM6b4DTy/cz3lCe0PxBhRjPzu+HW604HPsbdS1tbrA6oz+thB19pE7mFOlnMbY3+sUh72L573aL7B9xrYap0sX60T39wffJ3Il7by+3TqYPav+SL0Z9zWOLZy+2AcwDpNOmPBSetvoqfROJk7+vrFcyec0k7truk3Xb+DPlm2Uv36eQPmaOk3qw7xDZgrfTpP6hSdet4eX9/f2n9X6+n7Go882Gzsf3DPY+9vffKJ1r79EwR7fYI48puHJjERxAkc4kZpjPJupHx5WepYoCcxGz9LUv7DKpF70LBKa2ItdOKwCodfDquyHC1BeVYaHmBb3ZhQLws+qKPVDndY3xZ8sO34GNQoTCuwbTW3yW2NbpPbB90m6xSHpR1wzSltGjPIsHSh6nfQFxetVL9+Xm4/+vodNKzCD/id/wdOR0u/WXWID5Wu9MVQPOZizCMfdJC8nVCOP851BeThC6X4Y0u4RCAf/NxMv6Prq+PrSZLr38V400RnbA9NXnoTHsj7Bk+8s4yrWhugPCJ3Xskb5mMS5dbCYr3RaFcW28XFRvvcQ5SIL7LyPf6YhPaQ4yaF3rNfbUh/wY9J8OORE5B3A+VNQh76NP6YhKfpdiOL/pF/QaF/N9RhkLYsKHywfw+CtSXotVvs2377W3lWi9klsc+M0qBzI5F70LkRfnSdP9JxNeTxQ+DDfuQW5cnii6LksomJhHpZ8EEdXU18rjbkczXQrPbHdz2/DGIg+9fGHVzq4rbGpfqrKS/rRywHfSHcSl8GcaHqF+MuTpb6RT4Xkn4xbuak6Vf0tGa/3Tz0i5zSbHSQuRHaqNRpLf5Yiz+S+KzFH29s/x2lQV+mthZ/DDY+XgfXnNb02827mvJGLb5biz+6NJbxB8s+qdBeSXlC+0F4HPlT8fXmoH/suibozbsS8q6lvKsUmSTvakWmHPHAx2GEPkqLYW8dhP4jsdyRLj+6U8ccS8CUI6raOp/UYzr+OwF5dva7WIrkfjN8+BN1eq6+YW+dcDwfV+h5LfVNCj3aq+hIezz+OsK6SsG6Bu7JWqGmT5HxfOgTZWR9XpdSJ9anpn/Uk+hIi5l2EtZOBQt17NKnyHg+9Ikysj6vTakT61PT/7VAIzoqBP26voKwNH1eDfd4LVvKTyn0iDdJ9AfA53xpR6986DfZFq5UsNH35ggD65FX6jFDeVg2wr1uey9u2qvduG20R3hwn1NsW3tNh5T1/HjpwK+w4ddbaK+pkjx89JT3dPHRU35sAB895dfwYUp79DRLfJUjPoLLvopt5npFRnzVifZoFD9aWMzIU+jTXnXI9qfZKz5W47I/fu2VlMP4AuXnV7YI/Rno61+JrzV/LHry64+LLc0fo17ZH7t0GKVB+7zoTHtVR4ny0F64312vYOKrttCnyd+h9qabzVapWpqdn2tVq8352hbCR11s8MC/WmvMLjZmS6X5aqlVLa06/8VafWHxrBDFVumcOlabf625MFecLTfmm4v1ZqW2uNr8WwvV+dmF+cVasVmcL81X0vhH/ewfYiKfa4NRejh8/a+MlVNQ3vLRXMFfR/IZ4ZdET5NBv56E93ovdWu3s7QD8s+TrMa67jxSup7kYf3wWZZpP/ppRY+siu2hz59SdMNyrCMZ855k1MZVkUk7byNyRDTvoUcQxzzJ6LePtjtnyzA2fDB8/W/E849priBtg3EN2v0Y5CP9v4K1n39Jaz/sc6O0AfLXKfnyW9prTKHFa/4tsrNekV5sciqhrlNUV6H/NxDDfWGrjon6Q7nGEjD/TIkLBRPnaq4+L/QbFHrsYyLP5qC/b26gcij7dNCb8J7WPjmi5TFYxiksl/R7WsFJkmG9gqPNp6dJVuTJ9hAlnvOMK3ywT+GYP63wNxwfatpYKUnypqi+mId1/9GwS8dJm2NKnaL6/grNaZCO5dH6mmVsJPcn4T7zHSfaKaLF8Zx1NmkgY0HhM0W46xzy5whnQik3E+j9UfubVd6cIq821gzLB7E+FPbywXbGMe275D/Rj48rZZ8Mu/lI/59gTPvnjGMa+xKsw4fD7j322RzHcp/ktQ8eu5gGx/EeXxfP9XHsYv+AWOfwaR9EixG0uI9jhOt2djGn4mtXDLA56NcN2/A08cL4WMYX1sEmkGPDzmReotcZRx2je4WdOh3KgHSMoY2dgqH1aym3WZGL+x77jikHD20803hMUt6w7aON2xhraDGMlo/jOfLhe2MKfVr8kU/A1nCnFBzNz6+nvJySxz4M64s+jGMTbU6GvlHrd0lt54q9NdmzxFVTDtk1/aEfsl7LKc4VS8XF2Vq7XWrWGwvVtLUcub8u7K3Xub9wbxLqFaX1SE9505A3Efbyz8e/J4APYokck0RfB98WpSkoI+ULCv8p4t8jt3IPbY2xxpV7Qh+16Z2xjD7W6Mq1+bnG/EKxVG6Xy5W5elq7anrCtYMoia6xLaaUuk0S/Q/CmLMLxotztAq/iO69Drpcwt9zGMq9ibD3ntZGaLtCL7zzYb+MkrcB8iaJz8b4N+oLsUSOSaK/m2wX7U3KFxT+64l/j9zKPbbdDQr9BoU+ap/d5I+w7tZrf+d4Ej7eY9ne67Ff1av10txcY26xvtiery4urPrew3y9PV+pLJQq883WfKm+6mv/1cpCu9Q+u/5faRcrc6VV518qldr16sJcfbF8dolv1fc+qu3ZRr09W6yVm9VWudlYyd4Hzp1x7rZAcw1t7oZl5cwVz92eBn/bohhfm9Nrce4Y5WlzOi0G5vkLxkO8BuOKY4Ogfz6M5YVuRinX8fNBf/xque6UZfxB/nlFJz72SbQ10ylFr6KfDX7kqYo8GxV5tHaO9lU2Bf1thvIJFq6Ryac7tXhc7F3br5mmPG0O6JqD4jq+a61dWzPQ1ry43weB3u9lzsBrDM9Bvz/jWGPgfo/9l/s92yrmaWelXG2Oc0deA5pR6DcCDc+70SZmMmCtc/DepNDPOHijXFiWeSfZrmtvzvOZl5p25gX3TDCOS2pHpM+iS60dC0SPutP6MfdH5LuB8rD/cR9HOxX7xf7CYzT2RxyjreOKxmxrvlqvlBcr7fnGXHFuteOahWZ9sThfKTUbjdnibH1uJXENr91HSTsnYT3GsJzaGCz884Hur3fZyFNiny/yJI3BojvXvp22xpgL+n2qy89qWGOGWPy8B7YH24Kf8wTZ4zHhnw/6derDFsYUvWr9ivf/ckG2s045JW9cufe9jKXte+US/gofvsd82P6RT9Ic7fdpjiblss7RhH7uii7mtylW09qf+06UdsV/i4OlKt/we16q2OCz9Zg4BuF24aTtwYvcgz53jWP8BsrD8WEj5eFYNkN56BM3UZ4v251MqJcFHy0Oco33K+Wj7Xto5zOG5YNtx3uJ2ni20rFRmy9qYyP6lr/YqfNE34JlZd7L+4s3gW/5K3o/lqczOHNs/5h4jQbtV3vuhu0ZfQPbIM4t+CwuprSzO4M8O4q2Nw343C+Rp+c4eCD9R2nQd1uI3IP6WG0upsU5ecob1jejPBa+YjyhXhZ8kGa13qGx2mOG5/P4A/sfHmN4jRjz0P9w+2hrG5KH/QNjYk5afxM9DfpugAtRv+yTOVnqN0f12BX/Lg6XRl6/g8bkQjeofj2tDYyUfrPqUHRhEZ/g+Uxt302bjwu9tp/E55yipMXRUnZU55iD9gOOP3H9mm1mM+ShTjilzWkHeXZZm6cgHZ83yyky4lxEO/PL9qGt72j7VS4ZtbVRl72iPnl/Rntug3njnErbS+Q51a54TpX27LLo6Xzs46BeJ0kmlw6jNGifF50Vgn7/6Nqr4bnwpIKJ62zW+xyz5cVao1KbLy62arON+mzaPkfnrHnYpTNsx7LwlfYaD7r+YCLsyiT8tfOUQieyTvuRtSiyyhky6UPIE+syRvR8zWc2P35FV26so9QD7yG+0Gvn1/Bcn8ionXXcEA6GtZ6w1g2BJXJpZ/rWrVAuDYvPtg5yVvV9cdtEfeK/AoIsaqDMrAQA",
      "debug_symbols": "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13Atew3XstdwLXsN17LXcC17Ddey13Atew3XstdwLXsN17LXcC17Ddey13Atew3XstdwLXsN17LXcC17Ddey13Atew3XstdwLXsN17LXcC17Ddey13Atew3XstdwLXsN17LXcC17Ddey13Atew3XstdwLXsN17LXcC17Ddey13Atew3XstdwLXsN17LXcC17Ddey13Atew3XstdwLXsN17LXcC17Ddey13Atew3XstdwLXsN17LXcC17Ddey13Atew3XstdwLXsN17LXcC17Ddey13Atew3XstdwLXsN17LXcC17Ddey13Atew3XstdwLXsNL7LXun3D0FVxO6e92mt020m4Pm3j+cdpe883a/T05NtwvK3hBFvDEVvDibaGk2wNJ9saTrE1nGpqOK/WJLSGY+uqXGxdlYutq3KxdVUutq7KxdZVudi6KhdbV+Xy6atyWo91y+K/j6cuxsbjjI3HGxtPMDYeMTae/Q3UXVn3GfHexZPxuJSXbfgpf9u9IOyv97Z+k/yJNylN3iSkx5uk8PQmO7/IK2HdGOi2SBxOXjsty7bn2hKeNl1b3NcEqvEJxE2AdMu6v01A9tfXe5qA630CvvcJhN4nIL1PIPY+gdT7BHLvE7B+Jz6dQO93Ytf7ndj1fid2vd+JXe93Ytf7ndj1fid2vd+JXe93Ytf7ndj1fif2vd+Jfe93Yt/7ndj3fif2vd+Jfe93Yt/7ndj3fif2vd+Jfe934tD7nTj0ficOvd+JQ+934tD7nTj0ficOvd+JQ+934tD7nTj0fieW3u/E0vudWHq/E0vvd2Lp/U4svd+Jpfc7sfR+J5be78TS+5049n4njr3fiWPvd+LY+5049n4njr3fiWPvd+LY+5049n4njr3fiVPvd+LU+5049X4nTr3fiVPvd+LU+5049X4nTr3fiVPvd+LU+504934nzr3fiXPvd+Lc+504934nzr3fiXPvd+Lc+504934nzr3fiUvvd+LS+5249H4nLr3fiUvvd+LS+5249H4nLr3fiUvvd+LS+5249n4nrr3fiWvvd+La+5249n4nrr3fiWvvd+La+53Y/B5bpxPo/E4ce99jK/a+x1bsfY+t2PseW3Hp/E4ce99jK/a+x1bsfY+t2PseW7H3PbZi73tsxd732Iq977EVe99jK/a+x1bsfY+t2PseW7H3PbZi73tsxd732Iq977EVe99jK/a+x1bsfY+t2PseW7H3PbZi73tsxd732Iq977EVe99jK/a+x1bsfY+t2PseW7H3PbZi73tsxd732Iq977EVe99jK/a+x1bsfY+t2PseW7H3PbZi73tsxd732Iq977EVe99jK/a+x1bsfY+t2PseW7H3PbZi73tsxd732Iq977EVe99jK/a+x1bsfY+t2PseW7H3PbZi73tsxd732Iq977EVe99jK/a+x1bsfY+t2PseW7H3PbZi73tsxd732Iq977EVe99jK/a+x1bsfY+t2PseW7H3PbZi73tsxd732Iq977EVe99jK/a+x1bsfY+t2PseW7H3PbZi73tsxd732Iq977EVe99jK/a+x1bsfY+t2PseW7H3PbZi73tsxd732Iq977EVe99jK/a+x1bsfY+t2PseW7H3PbZi73tsxd732Eq977GVzO+x9XjplKv7ZQJ7R6/DTiU9jq3yNVnrd+2mk7V+h286WZlpstY7h6aTtd5lNJ2s8Y7k1rSWx2T9yWQl13UgUkLZjg5L3h23y9uwgzyOlvIFx3i3owvHeCelCsf6/ms5iv86Ot8ueCdwQlgPDvI0ar9HPcV1zDEvTwfL3tG+1u2Vl6X8cvSdo/FmsRuOxvvQbjgab3G74ShwbMLReGPeDUfjPX83HI3biW44Gnce3XA0blJ64Wh9F8tuOOJn2nDEz7ThiJ9pw1Hg2IQjfqYNR/xMG474mTYc8TNtOOJnmnC0vhdwNxzxM2044mfacMTPtOEocGzCET/ThiN+pg1H/EwbjviZNhzxM004Wt9RvRuO+Jk2HPEzbTjiZ9pwFDg24YifacMRP9OGI36mDUf8TBuO+JkmHK0/l6IbjviZNhzxM2044mfacBQ4NuGIn2nDET/ThiN+pg1H/EwbjviZJhytP92nG474mTYc8TNtOOJn2nAUODbhiJ9pwxE/04YjfqYNR/xMG474mSYcrT8jrRuO+Jk2HPEzbTjiZ9pwFDg24YifacMRP9OGI36mDUf8TBuO+JkmHK0/abIbjviZNhzxM2044mfacBQ4NuGIn2nDET/ThiN+pg1H/EwbjviZJhytP6+3G474mTYc8TNtOOJn2nAUODbhiJ9pwxE/04YjfqYNR/xMG474mRYcs/WnnnfDET/ThiN+pg1H/EwbjgLHJhzxM2044mfacMTPtOGIn2nDET/ThKPDz7ThiJ9pwxE/04YjfqYNR4FjE474mTYc8TNtOOJn2nDEz7ThiJ9pwtHjZ9pwxM+04YifacMRP9OGo8CxCUf8TBuO+Jk2HPEzbTjiZ9pwxM804RjwM2044mfacMTPtOGIn2nDUeDYhCN+pg1H/EwbjviZNhzxM2044meacBT8TBuO+Jk2HPEzbTjiZ9pwFDg24YifacMRP9OGI36mDUf8TBuO+JkmHCN+pg1H/EwbjviZNhzxM204ChybcMTPtOGIn2nDET/ThiN+pg1H/EwTjgk/04YjfqYNR/xMG474mTYcBY5NOOJn2nDEz7ThaNzPxBrLyrG4esYxl/XoUJ7GHeruuMWvI3GSHxrVvPfSrizrS7v6ONjnvZcOi9+4O3lwD39M4dvRxSX5Orr4J5V8DTtHS17C19GS/6iR9bVT/NLUuLdC0wuaGvd5aPr7mmbjnhNNL2hq3P+i6QVNjXtxNL2gqfFcAE0vaCpoOpymxvMSNL2gqfHsBk0vaEqONJ6m5EjjaUqONJymhRxpPE3JkcbTlBzph5qKq+tLS/EnmsbFbSuii+THsNMXdqIeFewCdg3sBCYq2Mk0VLATO6hgJxlQwY5518Be8dcq2LHAKthxqSrYcakq2MUS9vuQTDm4+5BMuZv7kEx1/vchmeqK70My1TH+MaSymOqm7kMy1Wnch2TqLnwfkqk71H1I5q7eZTF39S6Luat3Wcxdvcti7updFntXb2fv6m3rEfT3Idm7ett6MPp9SPau3rYe130fkr2rt62HSN+HZO/qbevRxn8OydZTgu9Dsnf1tvXs2vuQ7F29bT1R9T4ke1dvW8/5vA/J3tXb1tMn70Oyd/W29UzE+5DsXb1tPanvPiR7V29bz4+7D8ne1dvWU83uQ7J39bb1rK37kOxdvW09Aeo+JHtXb1vPJboPyd7V29bTcu5Dsnf1tvUMl/uQ7F29bT1Z5D4ke1dvW8+7uA/J3tXb1lMY7kOyd/W29WyA+5DsXb1t7Vh/H5K9q7etfdTvQ7J39ba1u/d9SPau3rb2nL4Pyd7V29ZOyPch2bt629qf9z4ke1dvWzu13odk7+pta5/M+5DsXb1t7VJ4H5K9q7etPeLuQ7J39ba1Q9d9SPau3rb2R7oPyd7V29buNPch2bt629ob5D4ke1dvW3tK3Idk7+ptay+C+5DsXb1t/Yb9PiR7V29bv32+D8ne1dvWb2bvQ7J39bb3W8ti77eWxd5vLYu931oWe7+1LPZ+a1nt/day2vutZbX3W8tq77eWdTF39a72fmtZ7f3Wstr7rWW191vLau+3ltXeby2rvd9aVnu/taz2fmtZ7f3Wsjb6TdOSH0Ny+WlI9zf57evx/bR87bRy7bR66bTf/z3I/TR37TR/7bRw7TS5dlq8dtq1KgnXqiRcq5JwrUrkWpXItSqRa1Ui16pErlWJXKsSuVYlcq1K5FqVyLUqideqJF6rknitSuK1KonXqiReq5J4rUritSqJ16okXquSdK1K0rUqSdeqJF2rknStStK1KknXqiRdq5J0rUrStSrJ16okX6uSfK1K8rUqydeqJF+rknytSvK1KsnXqiRfq5JyrUrKtSop16qkXKuScq1KyrUqKdeqpFyrknKtSsq1KqnXqqReq5J6rUrqtSqp16qkXquSeq1K6rUq2V+fkbSd9ssjch6n1f3T3OM0v/zncSZQlu2hPeGxT62vfufY22fn69jbW/9y7G04adlfP9EbjrM1HG9rOMHWcMTWcKKt4SRbw8m2hlNsDcfWVdnZuio7W1dlZ+uq7D59Vd4e2eduN6id8Yix8URj40nGxpONjacYG89vX5v/PM0v105z105r80WNo6W+25ukT7xJ/sSblE+8Sf3AmzTasu7kTdp8KUHc401ifXqT31sJvw/J2xtSsDck+fSQxNX1uTTidyopWhtQsjagj3+Z7OwG+Pnd505HVK2N6PN7z52OyJkbkTc3omBuRGJuRNHciJK5EZm7Zou5a7bClnNxWdbXjlLPXrvG7aVva6BPEwj3CShsUPd7Eyg1rEffOvZfJrDjkL3bLLKPZ0fnKutXTXOt/uToEP3a4Lj0ONbtHetdffBb6i9H37E7sGtg92DXwB7AroFdwK6BPYJdA3sCuwb2DHYN7AXsGtit+70xsSdcqgp2XKoKdlyqCnZcqgp2AbsGdlyqCnZcqgp2XKoKdlyqCnZcqgb2jEtVwY5LVcGOS30Hdl/qOurw/I2TDTsuVQW7gF0DOy5VBTsuVQU7LlUFOy5VBTsuVQN7waWqYMelqmDHpapgx6WqYBewa2DHpapgx6WqYMelqmDHpapgx6VqYK+4VBXsuFQV7LhUFey4VBXsAnYN7LhUFey4VBXsuFQV7LhUFey4VAXsbsGlqmDHpapgx6W+A3t2KxCfw7KDHZeqgl3AroEdl6qCHZeqgh2XqoIdl6qCHZeqgd3hUlWw41JVsH/+2l7COtmwuHDy2n88fH0FudSnoxf3NYHa+QT80vsEnO0JpLg92SjFsDcB3/sEQu8TkN4nEHufQOp9Arn3CRi/E59PwPid+HQCwfid+HwCvd+JQ+934tD7nbjR0wIVJ9D7nTj0ficOvd+JQ+934tD7nVh6vxNL73di6f1OLL3fiT//GMjWE+j9Tiy934nF+J34KVpMJe9NoJ90+sUE+kmn9ycQ+0mnX0zA+J34fALG78TnEzB+Jz6fgPE78fkEjN+Jzydg/E58PgHjd+IcZV1UzmlJv0xgZwU6rAcHeRq13yOTtkcqx7w8HSx7R/vb6vc26KX8cvSfHJPxa4kRjmGp65fTwy9Ado/O25DzdqR8fT8gGb/2jQfc+LV6PODG7y3jAede+GHgxl30eMCNu/7hgGfjKcV4wI2nKuMBN54CjQccp/lh4ALwzwLHaX4YOE7zw8Bxmh8GjtP8MHCc5meBF5zmh4HjND8MHKf5YeDW20Jf0jb6p2fb7gO/ZXHra98a3qejZe+147L+qDrK8suxdzTWGzhFNNZbLUU01psiPTTVevuiiMZ6o6GIxnpLoIjGekysiEZA8wqN9ehVEc3M3XBaNw2KtZwcKz6uHMUX+cV//AHSLxPfz8p28C/fxt091ge/HuxFutnY6davbDo+0Vs3dvLLxPds5PfLxH0J8vtFkH9m+SfuL5HfLxP30Mjvl4lTc+T3y8QrA8jvl4lXP5Dfu4lXeJDfO1K/qeUn9ZtaflK/qeUX5J9ZflK/qeUn9ZtaflK/qeUn9ZtaflK/meW3/hAx5H+v/KR+U8tP6je1/KR+I8vvy/pDUx8WvyO/IP/M8pP6TS0/qd/U8pP6TS0/qd/U8pP6zSy/9QcWI/975Sf1m1p+Ur+p5Sf1m1p+Qf6Z5Sf1m1p+Ur+p5Sf1m1p+Ur+p5Sf1m1l+IfWbWn5Sv6nlJ/WbWn5Sv6nlF+SfWX5Sv6nlJ/WbWn5Sv6nlJ/WbWn5Sv5nlj6R+U8tP6je1/KR+U8tP6jey/Nmt9HwOy478gvwzy0/qN7X8pH5Ty0/qN7X8pH5Ty0/qN7P8idRvavlJ/aaWn9RvavknTv2qXydZYzw5Ni55e266W56L5etR6EkA2QbkxElUW5ATZzptQc6cjpSwHrws6ewe6dJ2j/Qh93KPPNv7Ns0cj6C/TzPnI+jv88wBCfrfPBT6T63/zBEJ+t+CE/SfWn9B/6n1n/m7Uejv88xfjkJ/n8n/5taf/G9u/cn/pta/kP/NrT/539z6k//NrT/539z6C/pPrT/539z6k//NrT/539z6k//NrT/539D6n+2MU8n/5taf/G9u/cn/5taf/G9u/QX9p9af/G9u/cn/5taf/G9u/cn/5taf/G9m/cNC/je3/uR/c+tP/je3/uR/c+sv6D+1/uR/c+tP/je3/uR/c+tP/je3/uR/U+vvyP/m1p/8b279yf/m1p/8b279Bf2n1p/8b279yf/m1p/8b279yf/m1p/8b2j9T56RFzz539z6k//NrT/539z6k//Nrb+g/9T6k//NrT/539z6k//NrT/539T6h7H8f/Ky6Z9PJa3LerSvMZwcLcuyloss8lxb/gvlWLfS30IZlsVtIymn4G9t58pExPXyWTrZSzOEse6lFMBvF8BYN1MK4LcLYKzVNArgdwtAxlpOowB+uwAm7qcpgD8KYKwFNQrgtwtgrBU1CuC3C0AogLkLYKw1NQrgtwuAJHDyAiAJnLwASAInLwCSwLkLIJIETl4AJIGTFwBJ4OQFQBI4eQEIBTB3AZAETl4AJIGTFwBJ4OQFQBI4dgGc7bARSQLnLoBEEjh5AZAETl4AJIGTFwBJ4OQFIBTA3AVAEjh5AZAETl4AJIGTFwBJ4OQFQBI4dwFkksDJC4AkcPICIAmcvABIAicvAKEA5i4AksDJC4AkcPICIAmcvABIAicvAJLAuQugkAROXgAkgZMXAEng5AVAEjh5AQgFMHcBkAROXgAkgZMXAEng5AVAEjh2AZw9f6uQBM5dAJUkcPICIAmcvABIAicvAJLAyQtAKIC5C4AkcPICIAmcvABIAicvgJmTQLeUdSQu5pOjJdd1JFJkeTr660HsdeZMrSlKWWZOpxqjnDnnaYxy5sTE5Q2l92covUvbzdKH3MvN8mRTXVlmTkwogFsBCAUwdwHMnJhQALcCmDkxoQBuBTBzYkIB3Apg6sSEApBl6pyHAhA3dTpFAYibOlOjAMSRBE5eACSBkxeAUABzFwBJ4OQFQBI4eQGQBE5eACSBkxcASeDcBeBJAicvAJLAyQuAJHDyAiAJnLwAhAIYugBONtMRTxI4eQGQBE5eACSBkxcASeDkBUASOHcBBJLAyQuAJHDyAiAJnLwASAInLwChAOYuAJLAyQuAJHDyAiAJnLwASAInLwCSwLkLQEgCJy8AksDJC4AkcPICIAmcvACEApi7AEgCJy8AksDJC4AkcPICIAmcvABIAucugEgSOHkBkAROXgAkgZMXAEng5AUgFMDQBXDygD2JJIGTFwBJ4OQFQBI4eQGQBE5eACSBcxdAIgmcvABIAicvAJLAyQuAJHDyAjCeA8QaV5FycWcFEHLZJC1P4w51d9wh5HXYt8O3o2veOVjCKqiUJyCxfnE0bqe74WjclXbD0bi564VjNu6RuuFo3Gp0w9F4x26GY4zrFGPa42i88e2Go8DxZxzzsnLMdYej8QXZbjjiZ37Isa73mbSEHY74mTYc8TO/zdG5HY74mSYcC37mZxxTXomksuxwxM+04Yif+SHHso46VdnhiJ9pw1Hg+COOt9WYdRyu7HDEz7ThiJ/5bY4+7XDEz7ThiJ9pwxE/80OOdR11WXbu1xU/04YjfuZnHMv2uS579+uKn2nDET/zQ44hrBzF73AUODbhiJ/5bY5xJ++p+Jk2HPEzP+NY3Xps3evDK36mDUf8zA85hpVIle/rM3HBz7ThiJ/5Icft+z01pR2O+Jk2HPEzv80xyw5HgWMTjviZn3F0S1y/cOaWtOyQxNG0IjmzpxG/jsTJ00/XdkkGV1aSwdWn34DlvZcOS3pM8uk7k+GPKewMe1m/QBTyU2f1x9F3lWZ2TP2oNLMf60YlN7Pb60elmb1kPyrN7FT7UWlmH9yPSoJKHag0s4fvR6WZ84F+VCJ76EElsoceVCJ76EAlT/bQg0pkDz2oRPbQg0pkDz2oJKjUgUpkDz2oRPbQg0pkDz2oRPbQg0pkDx2oFMgeelCJ7KEHlcgeelCJ7KEHlQSVOlCJ7KEHlcge3qOS99vRUk5UKi49nkOzPI7ef7KM5GX90blk99gFIaT4pSlJxXiakmuMpykpyHCaCpnJeJqSsIynqaBpd5pumyPe/kw7mtL3dqdpWdafpsvt8B1N6XsNaGrlOamuPmR/es7s+pzUKHTUVMuPqyXSq1MtP68WXADV8vNqYb2Xavl5tbDuTLX8vFqEaqFaflwtrMNTLT+vFr4PQLX8vFpIXKmWn1cLWS7V8vNqIculWn5cLYksl2r5ebWQ5VItP68Wslyq5efVQpZLtfy8WoRqoVp+XC1kuVTLz6uFLJdq+Xm1kOVSLT+vFrJcquXn1UKWS7X8uFoyWS7Vsknjw0N28TvVQpZLtfy8WshyqZafVwt5C9Xy82rBE1EtmzTZrTr6HJadasETUS0/rpaCJ6Jafl4teCKq5efVgieiWn5eLXy/hWr5ebUI1UK1/LhayFuolp9XC99voVp+Xi18v4Vq+Xm1kOX+sFq8X3fwC6GUk2rp5jsIhXR2av0reevc+pOgzq0/mejc+pNyzq2/oP/U+pNEzq0/2eLc+pMWzq0/+d/c+pP/zax/Wsj/5taf/G9u/cn/5taf/G9u/QX9p9af/G9u/cn/5taf/G9u/cn/5taf/G9q/R3539D6+1JXIcPid/Qn/5tbf/K/ufUn/5tbf0H/qfUn/5tbf/K/ufUn/5tbf/K/ufUn/5taf0/+N7f+5H9z60/+N7f+5H9z6y/oP7X+5H9z60/+N7f+5H9z60/+N7f+5H9T6x/I/+bWn/xvbv3J/+bWn/xvbv0F/afWn/xvbv3J/+bWn/xvbv3J/+bWn/xvav2F/G9o/U+e/5SE/G9u/cn/5taf/G9u/QX9p9af/G9u/cn/5taf/G9u/cn/5taf/G9q/SP53w/1l7DpL8Wd6B/csh3t5AngHhGXZaXtcno6eG8cN8f2dWyK4fnQu5zEeUPJSTrXmZybMunpHrHJSdjWm5zLymPZ+XQKcv5QTlcfcvoTOeOy9Sxxkfws5x07kZUKdpIiFewENCrYyUVUsBNHaGBPpAAq2HHrKthx1SrYcb8q2AXsGthxqSrYcanvwC61lg17rP95GLFJrGuoLUmW7xphae1rhP+1rxFm2bxGGWdtXyNsuH2N8Oz2NcLg29dI0Mi8RkQH9jUiZzCmUfiuETmDfY3IGexrRM5gXqNCzmBfI3IG+xrR113RKJ1o5GT7iraTUI41SousL52Wuhwf7G5HrEff/o7pu6S0gcNJStc4nKQ0maNJWulJh5OUFnY4SVlZ61vS+l1SFuKGk1SQdDRJWeYbTlLSo+EkJT0aTNLspr6XLuWFpHc2U9+UTthMfXU/YTPWZbJE2djk5YyNW9ZtYpx7JvnH+3w7Wty2fZvI49hl79g3bgzn6kOZpf5y9F3QsSJ2BHVjBewI6seK1xHUjxWuI6gfK1pHUD9WsI6gXhB0LEHHyi8Q1I8VuiCoJykaTFCSosEEJSkaS9BAUjSYoCRFgwlKUjSYoCRFgwkqCDqWoCRFgwlKUjSYoCRFgwlKUjSYoCRFfQnqy/rVaB8W/11QISkaTFCSosEEJSkaTFCSosEEFQQdS1CSosEEJSkaTFCSosEEJSkaTFCSorEEjSRFgwlKUjSYoCRFgwlKUjSYoIKgYwlKUjSYoCRFgwlKUjSYoCRFgwlKUjSWoImkaDBBSYoGE5SkaDBBSYoGE1QQdCxBSYoGE5SkaDBBSYoGE5SkaDBBSYr6EjS7FbXPYfkuaCYpGkxQkqLBBCUpGkxQkqLBBBUEHUtQkqLBBCUpGkxQkqLBBCUpGkzQwZKiur129XIiaNheWp7Gsf8I191DXSx3imWseKaG9WMhSzqjWLxbjy4+upPiVdySq4wVuQwq0lgxyqAijRWNDCqSIJJ9kcaKMAYVaaxYYlCRxooaBhVprPhgUJHGigTGFKmSOHQgEolDByKROHQgEolDByIJItkXicShA5FIHDoQicShA5FIHDoQicTBvEhlIXHoQCQShw5EInHQF+nkJ5RlIXHoQCRBJPsikTh0IBKJQwcikTh0IBKJQwcikTjYF8mROHQgEolDByKROHQgEolDByIJItkXicShA5FIHDoQicShA5FIHDoQicTBvkiexKEDkUgcOhCJxKEDkUgcOhBJEMm+SCQOHYhE4tCBSCQOHYhE4tCBSCQO9kUKJA4diETi0IFIJA76Ip1sN1wCiUMHIgki2ReJxKEDkUgcOhCJxKEDkUgcOhCJxMG+SELi0IFIJA4diGSqu7sPyVQvcx+S7p07nJWyK1txuttgt6PFf42/9j3+uHQ+ftf5+H3n4w+dj186H3/sfPyp8/Hnzsff+f03dn7/TZ3ff1Pn99/U+f03dX7/TZ3ff1Pn99/U+f03dX7/TZ3ff9PH77/BhfVBy8HV5eS1ffDrbL3IWVzUzSaheQG7BnYHdg3sHuwa2APYNbAL2DWwR7BrYE9g18Cewa6BvYBdAzsuVQN7waWqYMelqmDHpapgx6WqYBewa2DHpapgx6WqYMelqmDHpapgx6VqYK+4VBXsuNR3YD/bCKPiUlWw41JVsAvYNbDjUlWw41JVsONSVbDjUlWw41IVsNcFl6qCHZeqgh2XqoIdl6qCXcCugR2XqoIdl6qCHZeqgh2XqoIdl6qB3eFSVbDjUlWw41JVsONSVbAL2DWw41JVsONSVbDjUlWw41JVsONSNbB7XKoKdlzqO7CfbERfPS5VBTsuVQW7gF0DOy5VBTsuVQU7LlUFOy5VBTsuVQN7wKWqYP+8S/U+rNh98WfYXdqw+5B7wX7yc+D6+Qe0g/0P7AHsGtgF7BrYI9g1sCewa2DPYNfAXsCugb2CXQH75x8YDvY/sONSVbDjUlWw41JVsAvYNbDjUlWw41JVsONSVbDjUlWw41I1sEdcqgp2XKoKdlyqCnZc6juwn/2sIArYNbDjUlWw41JVsONSVbDjUlWw41I1sCdcqgp2XKoKdlyqCnZcqgp2AbsGdlyqCnZcqgp2XKoKdlyqCnZcqgb2jEtVwY5LVcGOS1XBjktVwS5g18COS1XBjktVwY5LVcGOS1XBjkvVwF5wqSrYcakq2HGpKthxqe/AfrZFWxGwa2DHpapgx6WqYMelqmDHpapgx6VqYK+4VBXsuFQV7LhUFewKLrWuB4fwtDX4H699H1KyN6Rsb0gf74VkCetryxLPPi9HR98nULueQF6WxfYEUonrNSiV7J5e+T581/fwfd/DD8aHX5f1lvTHI22+DV/6Hn7se/ip7+Hnvodv/M57Nnzj992T4Tvrd92T4Vu/654M3/pd92T4fd91Xd93Xdf3Xdf1fdd1fd91Xd93Xdf3Xdf3fdf1fd91fd93Xd/3XffzT41uO/y+77q+77uuN3/XlS2mqvH78M3fdY+Hb/6uezj8YP6uezx883fd4+Gbv+seD//Nt637m3z88uZLWK+3YXHh5LVjjeXr6FzcY19et7i9Rbdc1qNDeRp3qLvjlu0Zx07yYyW25r2XduXp8clPy7Z576XDreXbjpbyGMgfU/h2tJnF5rCsC+o+OPfL0fdqKVQL1fLjaqlUC9Xy02r5/LMGqRa71XL845xbtTiqhWr5cbV4qoVq+XG1BKqFavlxtQjVQrX8uFoi1UK1/LhaEtVCtfy4WshyqZafVwtZLtXy82ohy6VaflwtkSyXavl5tZC3GKgWlx7VspQT/SXXddi3Px8jCenrt5Wff24rmv5VTct2vZBnJA9NyS7603TbIkFK8DuakjCMpyk5wHia4tbH0xRPPZymCec7nqZ816g/TZe8aeqXHU35RtB4mpIjjaepoOlwmpIjjacpOdJ4mpIjjacpOdJwmu4/zOA2w+2sp+Evy9dJ5cpJ9cJJ+9ugR7dWXPThl5P2SuixdXMpT3vplq93cG9/B//2dwhvfwd5+zvEt79Devs75Le/Q3n7O9Q3v4Nblre/g3v7O/i3v8N+LW27PkTJ3y6Xbn9/zJi3rSJk2TnJX3mn/UvOdgOOSXZO2r+KlPX2F2vYOSleOSldOSlfOalcOaleOGl/G7azk/Y/Clt/EuuOTvtbjp2dFK6cJMcnpWVvTvsVket2Utk5abciklvppVB3Tson77T3edrfNunkQ7i/WdHJSeHKx31/a5gb1HVSN1Q7KEK8dlq6dlq+dlq5dlq9dNr+rgPnp7lrp/lrp4Vrp72okpK3056/6LmdFs9PSzunpWun5WunlWun7VfJzb6tp4W9C8/+95nPT3PXTvPXTgvXTpNrp8Vrp6Vrp73QLW1yh7xzl9lf5XOPHu82+51PQHqBpG6fN1nizmnx/LSdj2lK107L104rl07L7tpp+ySfg5jgdk6L107bJylp2U5LOxeF/Ye43459zC3v3ITLi7ltX42/XaR2arLEa6ela6ftV4lU2T4By97cyrXT6qXT9hOi89Pci0/3plv0Ox/T6q+dFq4NUq6dFq+dlq6dli9dJ/eTjPPT6pXT/H7mcH5auHLl8sulK5df4rXT0qXT9m8dWdZrQpZff5xzP2kX/+PnP7cE/vtJeblykrtykr9yUrhyklw5KV45aV/ex6KBuy2K75yWr51Wrp1WL51WlmunuWun+WunhWunybXT4rXTrlVJuVYl+/fqk2vH/p26bgtU1e+ddOUysH/fPHuneOWkdOWkfOWkcgXEhct1WJYrJ+3rlNaKqDnunOSvnBSunHR2ud49KV4Bka6clK+cVK6cdKUi3JWKcO7KSf7KSeHKSXLlpCsV8eIhBsWVbf0nPa3M7379oIStmyvhyYfuH3226h9ePJhAdUjF3pCquSG9eCiA6pCcvSF5e0MK9oYk9oYU7Q3J3tU7tLh6+23duIjLZ0f/5gYP23bdclvZ3JlA6X0CtfMJyNL7BFzvE/C9TyD0PgHpfQKx9wmk3ifQ+51Yer8TS+934tj7nTj2fieOvd+Jo/n7wPGGbyFavwqdObL4+auQlQ0aXX38+ut5LXxNP9MCmldoHGheofGgeYUmgOYVGgHNKzQRNK/QJNC8QpNB8wpNAc0rNHTDr9BkuuGXaOiGX6KhG36Jhm74JRoBzSs0dMMv0dANv0RDN/wSDd3wSzR0w6/QFLrhl2johl+imbcb9uGBRvwOmnm74VM0AppXaObta87Q1HnvUNmtOzP6HJYdNPPeoU7RzHuHOkUz7x3qFM28d6hTNPPmNado5s1rTtHM29ecopk3rzlFM29ec4JG9ncGCMuybocTluf9y3cn61xy69dZb3/7Mzjeb3tR3Lr1+Dha5GtQrsWg4mMvLJeetuPtOyuR/R0WgHOHE4DzGo4A5zWcCJzXcBJwXsPJwHkNpwDnNZwKnJdw3AKc13DokA/g0CEfwKFDPoAjwHkNhw75AA4d8gEcOuQDOHTIB3DokF/D8XTIB3DokA/g0CEfwJm5Q/ZlnaUPi9+BI8B5DWfmDvkUzswd8imcmTvkUzgzd8incGbukM/ghJk75FM4M3fIp3Bm7pBP4dAhH8AR4LyGQ4d8AIcO+QAOHfIBHDrkAzh0yK/hCB3yARw65AM4dMgHcOiQD+AIcF7DoUM+gEOHfACHDvkADh3yARw65NdwIh3yARw65AM4dMgHcGbukM9+lRsFOK/hzNwhn8KZuUM+hTNzh3wKZ+YO+RTOzB3yGZw0c4d8CmfmDvkUzswd8ikcmXbXmrA9HtEH53bQzLt52CmaeTcPO0Uz8aaoJ2584kcfnaKZd/OwMzQTP/roFM28W+meopl4s/czNBNv9n6GRkDzCs283fApmnm74VM0dMOv0Cg8xOb3Hl6f64rm9udjuuvD60XhUTO/N4GyVcLtz7ozAW99Aj5sEwh+ZwKh9wlI7xOIvU8g9T6B3PsEivUJLHmbgF92JlA7n0C1fic+nYD5O/HZBMzfic8mYP5OfDYB83fiswmYvxMfTOA/b//5//+nf//bP/3Xf/nn/3U76Y9//d//+t/+42//9q9f//kf/+//XP/lv/773/7lX/72P/7L//z3f/tv//zf//e///N/+Zd/+29//Ns/LF//839n79M/Zi/5huaPa0OOi/vHHF29/Xf489+dv/2793/8+x8n3Dox+cfb//xxwJ/bvmafltsRyd/Gdhvf/wc=",
      "brillig_names": [
        "get_l2_token"
      ]
    },
    {
      "name": "claim_shielded",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "eth_token",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "message_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17288131482828810359": {
            "error_kind": "string",
            "string": "Message not in state"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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HXP66Omzi0IfPX+d00fPx5y+2L/OoS92z1Glj56+d1X66PmY0xf734voi/1zJORo+t5FHz0fc/ro6bOLSh89f53TR8/HnL7Yvc5p9MX+OaKPnr53Nfro+ZjTF/vfi4QcueeIPnr+3kUfPR9z+ujps4tGHz1/ndNHT8dc6Ivd6xyhL/bPEX30/L2LPno+5kLM3e9F9MX+OaKPnr930UfPx5w+evrsQuijp6/zlT56Pub0xe51zkpf7J8j+uj5e5cQ8+mY0xf734voi/1zRB89f++ij56POX309NnFRh89fZ1v9NHzMacvdq9zNvpi/xwJOZq+d9FHz8ecvtj/XkRf7J8j+uj5exd99HTMO3309NlFp4+ev87po+djTl/sXud0IUfuOaKPnr930UfPx5y+2P9eRF/snyP66Ol716CPno85ffT02cWgj56/zumj52MuxNy7zhn0xf45oo+ev3fRR8/HnL7Y/15EX+yeo50+evretdNHz8ecPnr67GKnj56/zoWYT8ecvti/zqEv9s8RffT8vYs+ej7m9MXe96K20Bf754g+evbe1Rb66PmY00fPnl20RYj59HVOHz0fc/pi/zqHvtg/R/TR8/cu+ujpmBf6Yvd7UaEv9s8RffT8vYs+ej7mQsxnzy4KffT8dU4fPR9z+mL/Ooe+2D9H9NHT965KHz0fc/pi93tRpS/2zxF99Py9S4j5dMzpo6fPLip99Px1Th89H3P6Yv86h77YPUeNPnr63tXoo+djTl/sfy+iL/bPkZCj6XsXffR8zOmjp88uGn20jnm9bcy/Hq5l1AMU6Yz/wcpdy/I46Nb1AEV6VwMUhe7SAkX6RQsU6QAtUKRHs0BRiKIBivRFFijS6VigSO9igSK9y/RJh9DpTMd8pS9yP+le6br8c0RPN3/vogOcj7kQc/d7Ed2of47odefvXXTG8zGnj57+9nqlj56+zjf66PmY0xe71zkbfbF/juij5+9dQsynY05f7H8voi/2zxF99Py9iz56Pub00dNnF50+evo67/TR8zGnL3avczp9sX+OhBxN37voo+djTl/sfy+iL/bPEX30/L2LPno65oM+evrsYtBHz1/n9NHzMacvdq9zhpAj9xzRR8/fu+ij52NOX+x/L6Iv9s8RffT0vWunj56POX309NnFTh89f53TR8/HXIi5d52z0xf754g+ev7eRR89H3P6Yv97EX2xd45koY+evXfJQh89H3P66NmzC1noo+evcyHm0zGnL/avc+iL/XNEHz1/76KPno85fbH7vajQF/vniD56+t5V6KPnY04fPX12UYSYT1/n9NHzMacv9q9z6Iv9c0QfPX/voo+ejnmlL3a/F1X6Yv8c0UfP37voo+djLsR89uyi0kfPX+f00fMxpy/2r3Poi/1zRB89fe9q9NHzMacvdr8XNfpi/xzRR8/fu4SYT8ecPnr67KLRR8/HnD56Pub0xfMxp8+djrnQ587HnD53Pub0rfMxpw+dj7kQcxXzehuc/Hq4llEPUKSztECRXtECRbo/CxTp5yxQpEMzQHGl57JAkS7KAkX6IgsU6XT+AYrrkDuKW90PUBSiaIAivYsFivQuFijSu1igSO9igSK9iwGKG72LBYr0LhYo0rtYoEjv8g9Q7I/fotWh/kZT/eXaJsR8Oub0ReaYW/9yeaPr8s8RPd38vYsOcD7m9Ivu96JON+qfI3rd6XtXpzOejzl9tDnm2q8duxDz6eucPno+5vTF/nUOfbF/juij5+9d9NHTMR/0xe73okFf7J8j+uj5exd99HzMhZjPnl0M+uj565w+ej7m9MX+dQ59sX+O6KOn7107ffR8zOmL3e9FO32xf47oo+fvXULMp2NOHz19drHTR89f5/TR8zGnL/avc+iLvXO0LvTRs/eudaGPno85fbH/vYi+2D9HQo6m71300fMxp4+ePbu4bTjEfPo6p4+ejzl9sXudU+iL/XNEHz197yr00fMxpy/2vxcJOXLPEX30/L2LPno+5vTR02cXhT56/jqnj56OeaUvdq9zKn2xf47oo+fvXfTR8zEXYu5+L6Iv9s8RffT8vYs+ej7m9NHTZxeVPnr6Om/00fMxpy92r3MafbF/juij5+9dQsynY05f7H8voi/2zxF99Py9iz56Pub00dNnF0IfPX2dC330fMzpi93rHKEv9s+RkKPpexd99HzM6Yv970X0xf45oo+ev3fRR0/HfKWPnj67WOmj/wHme1vvmO9DNMz3sT7qWET78FJaeRwANxj2A5JovAOQROcdgCQhSf5JolcPQBLNfQCS6O4DkER7H4AkzgN0kmTpdzikNPmM4kaHb4EiPbsFijTVFijS9VqgKETRAEX6RgsUaewsUKTzskCR1sgCRXoXAxQ7vcs/QLFI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",
      "brillig_names": [
        "discover_new_messages",
        "build_msg_block",
        "attach_len_to_msg_block",
        "debug_log_oracle_wrapper",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "build_msg_block",
        "get_l1_to_l2_membership_witness",
        "notify_created_nullifier_oracle_wrapper",
        "storage_read",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_to_radix",
        "directive_invert",
        "directive_integer_quotient"
      ],
      "verification_key": "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\n0wjG1j0HkTruZrSFZmQJ4zJievrMBCtdWDUY"
    },
    {
      "name": "is_registered_l2",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "aztec_token",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "is_registered_l2"
      ]
    },
    {
      "name": "get_l1_portal",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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yrUqKdeqpFyrknKtSsq1KinXqqRcqhK3LNdOc9dO89dOC9dOk2unrddOi9dOS9dOy9dOu1Yl17JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17dS+y17I/YXgbjzs47UWV7Fv6uVL8L6cdbeXb6EUht+FkW8MplobjX2XQWsNxtobjbQ0n2BqO2BrOams40dZwTF2V/WLqquwXW1dlZ+uq7GxdlZ2tq7KzdVV2tq7K7tNX5dN3XN3GE42NJxkbTzY2nmJrPH4xNp7jDdRvqcfXabcj1sp4biHh403KMf1194Lbl/hPfEn4xJdIky8J8fElMTx9ycEv8nLYNgYKy/O+T+54O9Vl33NtCc+vtHZfE1iNT2DdBYhrCAcTiL1PIPU+gdz7BErnEzh+DqOnCbjeJ+B7n0DofQLW78TVCfR+Jw6934lD73fi0PudOPR+J5be78TS+51Yer8TS+93Yun9Tiy934ml9zux9H4nlt7vxNL7nXjt/U689n4nXnu/E6+934nX3u/Ea+934rX3O/Ha+5147f1OvPZ+J46934lj73fi2PudOPZ+J46934lj73fi2PudOPZ+J46934lj73fi1PudOPV+J06934lT73fi1PudOPV+J06934lT73fi1PudOPV+J86934lz73fi3PudOPd+J86934lz73fi3PudOPd+J86934lz73fi0vuduPR+Jy6934lL73fi0vuduPR+Jy6934lL73fi0vuduHR+Jw5L53fisHR+Jw5L53fisHR+Jw5L53fisHR+Jw5L53fisHR+Jw5L53fisPR+J3a934ld73di1/ud2PV+J3a934ld73di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3mKgWlx8VMuSK/pLKtuwb/98jCTEr99WZlKR7jTN+/VCnpE8NCW76E/TfYsEycEfaErCMJ6mgqbDaYpbH09TPPV4muJ8x9OUZ43603RJu6Z+OdCUJ4KG07SQI42nKTnSeJqSI42nKTnSeJoKmg6nKTnSaJqW45cZ3Ga4n/U0/GX5Omm9clK8ctJhJLK6reJWH3456aiEHls331YWH0WRv74hv/0byru/4Xgf56bf4N7+Df7t3xDe/g3y9m9Y3/4N8e3f8Pa/af/2v2n/9r/p431S133Xh1XS98vl8f6Ya9q3ipDl4KRy4ZuON1Nc9xvwGuXgpOOrSN5uf2sJByf5KyeFKyfJlZPWKyfFKyelKycd/yns/clajnQqF0463uirdpI7PykuB3M63tRqTWU/KR+cdFgR0W30YigHJ0nlm47+no63Tar8ER5vVlQ76cqf+/HWMM6v26Scjwcoor92Wrh2mlw7bb12Wrx2Wrp2Wr52Wrl02vEPUuunvaiSnPbTnh/03E/z9dMO2vwUrp0m105br512XCU3+7adFo4uPMfPM9dPy9dOK5dOO36Mtn6au3aav3ZauHbaC93iLndIB3eZ41U+9+jx3CoHfwHlBZKy/73Jsh6c5uunHfyZlnDtNLl22nrttHzhtLQsxySfg5jgDk7z1047Jilx2U+L8eC0+OK0x9zS8v0092Ju+6PxtyAoHJzmr50Wrp12XCVSZP8LWI7mtl47LV47LV07Lb/46951W/16cFq5dNpxQFMdpHfXTvPXTgvXTpML18nbaeu10+K109Kl08Jy6coVrl25wrUrVwiXTivH5sFvU1u/vzHudlK+clL5/ZPcslw5yV05yV85KVw5Sa6ctF45KV45KV056bgiytZcxaellcdJ5cJJbrlykrtykr9yUrhyklw5ab1yUrxyUrpy0pWKcFcqwl+piBe3gsci3O2P5+i0fO2044bh5lS2056X/PbTXtx4qqe5a6f5a6cd33hc3JG4fIAkvPBj5eHHytG3pWun5WunlUunyXLtNHftNH/ttGPdVr88mqF0cJpcO229dlq8dlq6dlq+dlq5dNpxVO7Wh2lcczk4zV07zV87LVw7Ta6dtl47LV47LV077VW4tp8W/MHfW1yuneauneavnRaunSbXTluvnRavnZaunZavnXatStK1KnkR1Id9+daF9eAS9CKor54Wrp0m105br50Wr52Wrp12rcFI1xqMfK3ByNcajBe/HD1/r/zttGMB4iNLjeno29K10/K108ql045/KHIrnu13YDdl/cFp7tpp/tpp4dppcu209dpp8dpp6dpp+dpp5cppflmuneauneavnRaunSbXTluvnXZcJeVxWyz+6LR06bTjjMlntz3X5HN8eor28FHhHPbkNYenNaPjoytP6N6G5OwNydsbUrA3JLE3pNXekKK9ISV7Q8r2hlTMDcnbu3r7Fldvvz/jmcWl2tG/uRnb/moduaXVBxPwvU8g9D4B6X0Ca+8TiL1PIPU+gdz7BErnEwhL7xPo/U4cer8Th97vxKH3O3Ho/U4cer8TB/P3gdPNmZMX61ehmiOTz1+FrGymfluF2Obol+/r214ENK/QrKB5hSaC5hWaBJpXaDJoXqEpoHmBZl1A8wqNA80rNB40r9DQDb9EI6B5hYZu+CUauuGXaOiGX6KhG36Jhm74FZpIN/wSDd3wSzR0wy/R0A2/RCOgeYWGbvglmnm7YR8eaOTgUfM4bzdcRTNvN1xDk+bta6po5r1DVX6Q59O8d6gqmnnvUFU0896hqmjmvUNV0cyb19TQ5HnzmiqaefuaKpp585oqmnnzmioaOUITlv0H0GF5ftfQ4WSdi27/dbaLvgbH+303tFu3vj6OFvka1NpiUOtj31oXn16d0XlWcrxrBnDucBJwXsPJwHkNpwDnJZzj3WyAc4fjgPMajgfOazgBOK/hCHBew6FDPoFDh3wChw75BA4d8gkcOuSXcMJCh3wChw75BA4d8gkcOuQTOAKc13DokE/g0CGfwJm5Q77loBuc253pAM7MHXIVzswdcg2Om7lDrsKZuUOuwpm5Q67CmblDrsIR4LyGM3OHXIUzc4dchUOHfAKHDvkEDh3yazieDvkEDh3yCRw65BM4dMgncAQ4r+HQIZ/AoUM+gUOHfAKHDvkEDh3yaziBDvkEDh3yCRw65BM4dMgncAQ4r+HQIZ/AoUM+gTNzh1z5VW4IM3fIVTgzd8g1ODJzh1yFM3OHXIUzc4dchTNzh1yFI8B5DWfmDrkKZ+YOuQpn3s3Dwv56RB+cO0Az7+ZhNTQTv/qoimbiTVErbnziVx9V0cy7eVgVjYDmFZp5t9Ktopl4s/camok3e6+hmXiz9xqaebvhGpqJX31URUM3/BKNGH95fSobmts/H9PdXl4fFF4183sTyHsl3P5ZDiYQrU/Ah30CwR9MIPU+gdz7BErnE0hL7xNwvU/AW5/AkvYJ+OVgAqH3CVi/E1cnYP5OXJuA+TtxbQLm78S1CZi/E9cmYP5OfD4BOd4RKMk2oiTxm4mQ4/1OHqamrPngJHflJH/lpHDlJLly0nrlpHjlpEOd3LK/bsItN0m/n5avnVYunXb8K9/6ae7aaf7aaeHaaXLttPXaafHaadeqxF+rkuOfrFSuHcc/5Sj7Zar4o5OuXAaOH+CufVO8clK6clK+clK5AEKuXK7lyuX6+EG7EreKKOmgjI4fQKudJFdOql2uD0+6crmWdOWkfOWkKxWxXqmI9UpFrFf+ctcrN/D1yg18vXIDX3+3Iv7z9j/////073/7p//6L//8v26n/PFf//e//rf/+Nu//evX//yP//d/bv/lv/773/7lX/72P/7L//z3f/tv//zf//e///N/+Zd/+29//Ld/WL7+z/+dljX8Y1qS3Ibzhygp5PUfb71cuP3v8Od/D+X236X88d//OEFSjv94y1PdH/+PP89YcrodkcttbLfx/X8=",
      "brillig_names": [
        "get_l1_portal"
      ]
    },
    {
      "name": "claim_public",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "eth_token",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "message_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17288131482828810359": {
            "error_kind": "string",
            "string": "Message not in state"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "build_msg_block",
        "attach_len_to_msg_block",
        "debug_log_oracle_wrapper",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "build_msg_block",
        "get_l1_to_l2_membership_witness",
        "notify_created_nullifier_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_to_radix",
        "directive_invert",
        "directive_integer_quotient"
      ],
      "verification_key": "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\n0wjG1j0HkTruZrSFZmQJ4zJievrMBCtdWDUY"
    },
    {
      "name": "_log_claim",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "eth_token",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "message_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "11430482739715627628": {
            "error_kind": "string",
            "string": "Function _log_claim can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBIJwAABAMnAgUEBCcCBgQAHxgABgAFgEQdAIBGgEYGLgiARAABLgiARQACLgiARgADLgiARwAEJQAAAF4lAAAAXygCAAEEgEgnAgIEADsNAAEAAiYlAAACOB4CAAYAHgIABwAzOAAGAAcACCcCBgEBJAIACAAAAIglAAACYR4CAAYBHgIABwAKOAYHCCQCAAgAAACkJQAAAnMcDAMGACkCAAMAIxDODy0IAQcnAggEBgAQAQgBJwMHBAEAKAcCCC0MCAktDgEJACgJAgktDgIJACgJAgktDgYJACgJAgktDgQJACgJAgktDgMJJwIBAAAtCAECJwIDBAYAEAEDAScDAgQBACgCAgMtDAMELQ4BBAAoBAIELQ4BBAAoBAIELQ4BBAAoBAIELQ4BBAAoBAIELQ4BBC0IAQEAAAECAS0OAgEnAgIEACcCAwQFJwIEBAEtDAIFIwAAAWQMOAUDAiQCAAIAAAHuIwAAAXYtDQECJwIFBAUGKAUCAScCBwQDADgFBwYtCAEEABABBgEnAwQEAQAoBAIGLQ4FBgAoBgIGLQ4FBicCBwQDADgEBwYAKAICBy4EAAeAAy4EAAaABC4EAAWABSUAAAKFACgEAgYtDQYFJwIHBAIAOAYHAjcNAAIABSYAKAcCBgA4BgUILQ0IAi0NAQYuBAAGgAMoAIAEBAAGJQAAAssuCIAFAAgAKAgCCQA4CQUKLQ4CCi0OCAEAOAUEAi0MAgUjAAABZCgAgAQEeAANAAAAgASAAyQAgAMAAAJgKgEAAQX3ofOvpa3UyjwBAQImKgEAAQW+Hj//PqT2+jwBAQImKgEAAQWeoTt9j/vabDwBAQImAQCAA4AFgAcuAIADgAguAIAEgAkLAIAIgAeACiQAgAoAAALKLgGACIAGLgKABoAJAQCACAACgAgBAIAJAAKACSMAAAKZJi4BgAOABgsAgAYAAoAHJACABwAAAuYjAAAC8S4AgAOABSMAAANYLgAAAYAFAQAAAYAEAAEBAIADgASACS4AgAOACi4AgAWACwsAgAqACYAMJACADAAAA0QuAYAKgAguAoAIgAsBAIAKAAKACgEAgAsAAoALIwAAAxMoAYAFBAABAwCABgACgAYjAAADWCY=",
      "debug_symbols": "7ZzbbuMgEIbfxde+YJjhMH2VVVWlrVtFipIqTVdaVX33xd3gOAHVq9aKjeEmMtEQ/vnAgRlj3qvH5v7t+W69fdq9Vje/3qvN7mF1WO+2rvT+UVf3+/Vms36+639difYDhPis8Pqy2rbl18Nqf6huACWpumq2j+01WuF+5Gm9aVxJ8Ecd2gspvbkg2bPWEWtiYY7WxKA7a0MRY0tkj8aWNPWNb2unX42jn9mbA/AV9cNI/JXt+Nsh/qCM1w8a8Wv9rJCOxuzqBfrt2PpBnutvW5F4jVYQrtKKjrYCzOirSQEw0IoSVhzN3aUdGIMKvAdWobjsQ4r77VSYkyI0A4rGvCvofxghnylq6yn4Zj3+Xj1NsXpWal/Nojz1jVLR4SK6NgRQrwmMccMOm+rZsojYSva2CDhgC8Z1mZdhWJ7GCArzz1WesatKg78ZWJ/ZttKNTVa6lelKN8lK53Spc7LUpUiWuhQ6WenxBWga0lW60pOdTaWkdKUnuxCQiOlKT3dKonSnJJrzlKSlj0c12QFba31gwr2oOBpVohH+d9HIU8yD9BmuyXh4mDmTOU+iEzHRc14TTcWkjJOAiSnjJGRSxknIZM6r/YmY2DkvaKdiMuf4ZCIms87FTcVkzhHVNExQlLV9yKTEgAGTWec7p2JS1mwhk7JmC5jIsmYLmZQ1W8BE5TjvWOFt3aUJmBjKkAkLv0kJGSJMFnjvyMvtVbjESDfiZRZ9yVn0JefQlzTr/SbjebnAXEHoJWTRl5BFX8oFZnIiXi5wjRx6iQvMtkS8XGD+JPSSsuhLyqIvl7gTJuJlFvOlziEmIb2YmMSIzsuhd++M9BrYKL5EYhbT8eMhWcwdPxqSWb9CNBGSMkoukTDlmLLH7jGG7b21fkxPE+f4CPBrJkqUcRIyyfERoO3eP3eXEDBZYkLuh4+7FOQ4TgaYyBy3ngwwWWLS7MdMctxSMMCEctzyOMSkjJOAiSr/JyETKkzOmHy44u/Vfr263zTHY8Oe3rYPvVPEDn9emosDxV72u4fm8W3ftEeLnU4Va8cboK5BGce6zVKB8whQ3bYndrVFwBrAtkX4LHINEpwGp+Mv",
      "brillig_names": [
        "_log_claim"
      ]
    },
    {
      "name": "withdraw_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "eth_token",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "from",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "withdrawNonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "burnNonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "939615093317106671": {
            "error_kind": "string",
            "string": "Invalid response from registry"
          },
          "1149705418984161792": {
            "error_kind": "string",
            "string": "Invalid nonce"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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CoBGAAkAKAkCCS4KgEcACQAoCQIJLgqASAAJACgJAgkuCoBJAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkC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",
      "debug_symbols": "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",
      "brillig_names": [
        "withdraw_public"
      ]
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "parameters": [
          {
            "name": "l1_portal",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "token_contract_class",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "shield_gateway_beacon",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "8459146718181593566": {
            "error_kind": "string",
            "string": "L1 portal address cannot be zero"
          },
          "8606784891595333955": {
            "error_kind": "string",
            "string": "Token contract class cannot be zero"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "constructor"
      ]
    },
    {
      "name": "register_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "eth_token",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "aztec_token",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "name",
            "type": {
              "kind": "string",
              "length": 31
            },
            "visibility": "private"
          },
          {
            "name": "name_len",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "symbol",
            "type": {
              "kind": "string",
              "length": 31
            },
            "visibility": "private"
          },
          {
            "name": "symbol_len",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "decimals",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "message_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "8998099065237381256": {
            "error_kind": "string",
            "string": "Expected address did not match supplized token address"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17288131482828810359": {
            "error_kind": "string",
            "string": "Message not in state"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18159344801564042747": {
            "error_kind": "string",
            "string": "Token already registered"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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MQPMMYPA8SIBjplgjpkEjhcLcLwIzPEiAsdLBDheDOZ4MYHjpQIcLwFzvITA8TIBjpeCOV5K4FhbgONlYI6XETjWEeBYG8yxNoFjXQGOdcAc6xA41hPgWBfMsS6BY30BjvXAHOsRODYQ4FgfzLE+gWNDAY4NwBwbEDg2EuDYEMyxIYFjYwGOjcAcGxE4NhHg2BjMsTGBY1MBjk3AHJsQODYT4NgUzLEpgWNzAY7NwBybETi2EODYHMyxOYFjSwGOLcAcWxA4thLg2BLMsSWBY2sBjq3AHFsROLYR4NgazLE1gWNbAY5twBzbEDi2E+DYFsyxLYFjewGO7cAc2xE4dhDg2B7MsT2BY0cBjh3AHDsQOHYS4NgRzLEjgWNnIMdiXh+tvBYTHGRXb7zdvNbdaz281tNrvbzW22uXe62P17K8lu21HK/lei3Pa1d4ra/X+nntSq9d5bWrvXaN16712nVeu95r/b12g9du9NpNXrvZa7d47Vav3ea12712h9fu9NoAr93ltbu9do/X7vXafV6732sPeO1Brz3ktYFeG+S1h7022GtDvPaI14Z6bZjXhntthNdGem2U1x712mivjfHaWK+N89p4rz3mtQle+9SDMtH7Oclrk732uNemeG2q16Z57QmvPem1p7w23WszvPa0157x2rNee85rz3vtBa+96LWXvPay117x2qtee81rr3ttptdmeW22197w2hyvzQ3+/8/zfs732gKvLfTaIq8t9toSry312jKvLffaCq+t9Noqr6322hqvrfXaOq+t99oGr2302iavbfbaFq9t9dqbXtvmtbe89rbX3vHadq/t8Nr+uEDgXe/ne17b6bX3vbbLax947UOvfeS1j732idd2m/F67TOvfe61L7z2pde+8trXXvvGa9967Tuvfe+1H7z2o9f2eO0nr/3stV+89qvXfvPaXq/VTQgEzHe8m+8nN9+tbb4X2nynsfk+XvNdsuZ7UM13eJrvnzTfnWi+9898Z535vjXzXWHme67MdzSZ7xcy341jvtfFfCeJ+T4N810Q5nsMzDv4zfvjzbvPzXu7zTunzfuSzbt+zXtqzTtWzftBzbstzXsZzTsFzfvwzLvczHvIzDu0zPufzLuLzHt3zDtjzPtOzLs6zHsmzDsSzOf7zWfTzeeqzWeCzedZzWcxzecIzWfgzOe3zGePzOdmzGc+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",
      "debug_symbols": "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Qd13Z1D33RnUfXcGdd+dQenuDEp3Z1C6uwqlu6tQursKpburULq7eiH14gqlu6tQursKpburULq7CqW7q1C6uwqlu6tQursKpburULq7CqW7q1C6uwqlu6tQursKpburULq7CqW7q1C6uwqlu6tQursKpburULq7CqW7q1C6uwqlu6tQursKpburULq7CqW7q1C6uwqlu6tQursKpburULq7CqW7q1C6uwqlu6tQursKpburULq7CqW7q4b0fXE1pO+LqyF9X1wN6fviWpG+L64V6fviWpG+L64V6fviCqW7q1C6uwqlu6tQursKpburULq7CqW7q1C6uwqlu6tQursKpburULq7CnXfXYW6765C3XdXoe67q1D33VWo++4q1H13Feq+uwqlu6tQursKpburULq7CqW7q1C6uwqlu6tQursKpburULq7CqW7q1C6uwqlu6tQursKpburULq7CqW7q1C6uwqlu6tQursKpburULq7CqW7q1C6uwqlu6tQursGpbtrULq7BqW7a1C6u3Yh9eIGpbtrULq7BqW7a1C6uwalu2tQursGpbtrULq7BqW7a1C6uwalu2tQursGpbtrULq7BqW7a1C6uwalu2tQursGpbtrULq7BqW7a1C6uwalu2tQuruWkb4vbt+su/OiSVDRZKhokL4vbt+tu3OiqVDRNKhooHoxlO6uQenuGpTurkHp7hqU7q5B6e4alO6uQenuGtR9dw3qvrsGdd9dg7rvrkHdd9eg7rtrUPfdNaj77hqU7q5B6e4alO6uQenuGpTurkHp7hqU7q5B6e4alO6uQenuGpTurkHp7hqU7q5B6e4alO6uQenuGpTurkHp7hqU7q5B6e4alO6uQenuGpTurkHp7hqU7q5B6e4alO6uQenuGpTurkHp7hqU7q5B6e4alO6uQenuGpTurkHp7hqU7q5B6e4alO6uQenuGpTurkHp7hqU7q5B6e4alO6uQenuOpTurkPp7jqU7q5D6e76hdSLO5TurkPp7jqU7q5D6e46lO6uQ+nuOpTurkPp7jqU7q5D6e76N+vunn8J3hOSl3xPSF7yPSF5yffv1t09/RK8ZyQv+Z6RvOR7RvKS71C6uw6lu+tQursOpbvrULq7DqW761D33XWo++461H13Heq+uw51312Huu+uQ91316Huu+tQursOpbvrULq7DqW761C6uw6lu+tQursOpbvrULq7DqW761C6uw6lu+tQursOpbvrULq7DqW761C6uw6lu+tQursOpbvrULq7DqW761C6uw6lu+tQursOpbvrULq7DqW761C6uw6lu+tQursOpbvrULq7DqW761C6uw6lu+tQursOpbvrULq7DqW761C6uw6lu+tQursOpbvrULq7DqW761C6uw6lu+tQursOpbvrULq7DqW761C6uw6lu+tQursOpbvrULq7DqW761C6uw6lu+tQursOpbvrULq7AaW7G1C6uwGluxtQurtxfW8vfv7N/riQtB7jQtJ6jAtJ6zG+W3f39Jv9cSFpPUZC0nqMhKT1GFC6uwGluxtQursBdd/dgLrvbkDddzeg7rsbUPfdDaj77gbUfXcD6r67AaW7G1C6uwGluxtQursBpbsbULq7AaW7G1C6uwGluxtQursBpbsbULq7AaW7G1C6uwGluxtQursBpbsbULq7AaW7G1C6uwGluxtQursBpbsbULq7AaW7G1C6uwGluxtQursBpbsbULq7AaW7G1C6uwGluxtQursBpbsbULq7AaW7G1C6uwGluxtQursBpbsbULq7AaW7G1C6uwGluxtQursBpbsbULq7AaW7G1C6uwGluxtQursBpbsbULq7AaW7G1C6uwGluxtQursBpbsbULq7AaW7G1C6uwGluxtQursBpbsbULq7AaW7G1C6uwGluxtQursBpbsbULq7AaW7GxNK6zGhtB4T6V6P8c26u+fRzG/W3c3xUFfM2T5Hk6Ciyd8czfUeTf8cTYGKxqCiqVDRNKhoOlQ0AyqaiRRNuqCiSVDRQPXiBNWLE1QvTlC9OEH14gTVixNUL05QvThD9eIM1YszVC/OUL04Q/XiDNWLM1QvzlC9OEP14gzViwtULy5QvbhA9eIC1YsLVC8uUL24QPXiAtWLC1QvLlC92KB6sUH1YoPqxQbViw2qFxtULzaoXmxQvdigerFB9eIK1YsrVC+uUL24QvXiCtWLK1QvrlC9uEL14grViytUL25QvbhB9eIG1YsbVC9uUL24QfXiBtWLG1QvblC9uEH14g7ViztUL+5QvbhD9eIO1Ys7VC/uUL24Q/XiDtWLO1QvHlC9eED14gHViwdULx5QvXhA9eIB1YsHVC8eUL14QPXiCdWLJ1QvnlC9eEL14gnViydUL55Q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e/GY9bGKU/4cTYaKpkBFY1DRVKhoGlQ0HSqaARXNRIrmm3V3XjRQvThB9eIE1YsTVC9OUL04QfXiBNWLE1QvTlC9OEP14gzVizNUL85QvThD9eIM1YszVC/OUL04Q/XiDNWLC1QvLlC9uED14gLViwtULy5QvbhA9eIC1YsLVC8uUL3YoHqxQfVig+rFBtWLDaoXG1QvNqhebFC92KB6sUH14grViytUL65QvbhC9eIK1YsrVC+uUL24QvXiCtWLK1QvblC9uEH14gbVixtUL25QvbhB9eIG1YsbVC9uUL24QfXiDtWLO1Qv7lC9uEP14g7ViztUL+5QvbhD9eIO1Ys7VC8eUL14QPXiAdWLB1QvHlC9eED14gHViwdULx5QvXhA9eIJ1YsnVC+eUL14QvXiCdWLJ1QvnlC9eEL14gnViydSL24XUi9uULq7BqW7a1C6u3Yh9eIGpbtrULq7BqW7a1C6uwalu2tQursGpbtrULq7BqW7a1C6uwalu2tQursGpbtrULq7BqW7a1C6uwalu2tQursGpbtrULq7BqW7a1C6uwalu2tQursGpbtrULq7BqW7a1C6uwalu2tQursGpbtrULq7BqW7a1C6uwalu2tQursGpbtrULq7BqW7a1C6uwalu2tQursGpbtrULq7BqW7a1C6uwalu2tQursGpbtrULq7BqW7a1C6uwalu2tQursGpbtrULq7BqW7a1C6uwalu2tQursGpbtrULq7BqW7a1C6uwalu2tQursGpbtrULq7BqW7a1C6uwalu2tQursGpbtrULq7BqW7a1C6uwalu2tQursGpbtrULq7BqW7a1C6uwalu2tQursGpbtr333fXXqPJo/P0UD1YijdXYPS3TUo3V2D0t01KN1dg9LdNSjdXYPS3XUo3V2H0t11KN1dh9Ld9QupF3co3V2H0t11KN1dh9LddSjdXYfS3XUo3V2H0t11KN1dh9LddSjdXYfS3XUo3V2H0t11KN1dh9LddSjdXYfS3XUo3V2H0t11KN1dh9LddSjdXYfS3XUo3V2H0t11KN1dh9LddSjdXYfS3XUo3V2H0t11KN1dh9LddSjdXYfS3XUo3V2H0t11KN1dh9LddSjdXYfS3XUo3V2H0t11KN1dh9LddSjdXYfS3XUo3V2H0t11KN1d/2bd3azpEU2rn6PpUNEMqGgmUjTf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",
      "brillig_names": [
        "discover_new_messages",
        "debug_log_oracle_wrapper",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "build_msg_block",
        "attach_len_to_msg_block",
        "debug_log_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "storage_read",
        "debug_log_oracle_wrapper",
        "storage_read",
        "debug_log_oracle_wrapper",
        "build_msg_block",
        "get_l1_to_l2_membership_witness",
        "notify_created_nullifier_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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\n0wjG1j0HkTruZrSFZmQJ4zJievrMBCtdWDUY"
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [
        "aztec::macros::functions::utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "7f3drvM4l6WJ3kse54FITvGnb6WxUciqyi58QCKzkJW1gUYh770d4SXZ77dkcb0K2nOSfE4CKyIkm3zGtDTHoE39n3/47//8X//3//gvf/vX/+ff/tc//F//9//5h3/5t//2T//xt3/719u//Z///Md/+K///rd/+Ze//Y//8vyf/2H54x/OpT9P+F//85/+9Y9//1//8U///h//8H+5RVz4x3/453/973/+nfztRf6fv/3LP//xb+U///Hb8SnHr6PzIvuxKR4cuvr169B1XR4vu7r//P/94204ucVwckjbcNZyPhwJ5etQifn7cEqT4WTZhlPy+XDistGJPn4bjl9aDKd4/3V0CWtlOHn5OjQt38Xy7nA4IS8bfhdKjJXh+LK4r8PD8ny0+3oX/5F3CR95F/nIu6wfeZf4kXdJH3mX/JF3KZ94l7B85F0+8tkPH/nsh4989sNHPvvhI5/98JHPfvjIZz985LMfPvLZl4989uUjn335yGdfPvLZl4989uUjn335yGdfPvLZl4989uUjn/31I5/99SOf/fUjn/31I5/99SOf/fUjn/31I5/99SOf/fUjn/31I5/9+JHPfvzIZz9+5LMfP/LZjx/57MePfPbjRz778SOf/fiRz378yGc/feSznz7y2U8f+eynj3z200c+++kjn/30kc9++shnP33ks58+8tnPH/ns54989vNHPvu5yWc/LGvc36Wkp3eR+7vIR95l/ci7xI+8S/rIu+SPvEuTz364reVt7+J9+eVdvh99s2bbmG59+tMSoMtHq555WzBcw9M44v0zUhaF8ed95fN2vcmV8a8x7avIMYf96LjeJ+B6n4DvfQKh9wlI7xNYe59A7H0CqfcJ5N4nUPqegF86vxP7xf6dOMnWOK1plecJHLiLdf+mlV+TOz84r9swcnqaoRzaFrd/Zc3/8fWq7WjxRwfnh8X55dA/idtvHUYjbr/XGY24QPzDxO13k6MRt9/+jkbcfr8+GnH7BmM04vYd0WDEnX0LNxpxPOenieM5P00cz/lp4gLxDxPHc36aOJ7z08TxnJ8mjuf8NHE854eJezznp4njOT9NHM/5aeJ4zk8TF4h/mDie89PE8ZyfJo7n/DRxPOeniffgOd2DeD6H6PL+ixNXfKi89A3utqmdW5+2g/v6TmbowR1qsenBx2mx6cFxabHpwRtpsRHYvGTTg9/QYtODM9Bi00MPr8Wmh25biw198Us2Ql/8mg198Ws29MWv2dAXv2YjsHnJhr74NRv64tds6Itfs6Evfs2Gvvglm5W++DUb+uLXbOiLX7OhL37NRmDzkg198Ws29MWv2dAXv2ZDX/yaDX3xSzaRvvg1G/ri12zoi1+zoS9+zUZg85INffFrNvTFr9nQF79mQ1/8mg198Us2ib74NRv64tds6Itfs6Evfs1GYPOSDX3xazb0xa/Z0Be/ZkNf/JoNffFLNpm++DUb+uLXbOiLX7OhL37NRmDzkg198Ws29MWv2dAXv2ZDX/yazcx9sS9xYxMWt1RJJtlJuqfXLkcjiUv+Ojj6J3zlzyex+g6eZDok9pm7eUXsMxsFRewzexBF7AJ2DewzOydF7DObMkXsM/s9RewzW0lF7LhUBeyhg6d8D4kdl6qCHZeqgn1ml3qbfdqxl9pAnEt+f3FXlqdX9+7dMgky9SDTzC64I5lmds0dyTSzy+5IppldeUcyzezi+5GpiwfDI1MXT5NHpi4eQY9MXTy3Hpm6eNg9MjlSiC5kIoXoQiZSiB/L5Jd1G8lNmEUqMvmbrF+He5efoJR0dHRa9qOTf/ou9V0mUoguZCKF6EEmTwrRhUykEF3IRArRhUykEF3IJMjUg0ykEF3IRArRhUykEF3IRArRhUykED3IFEghupCJFOLnMoWcd5lEagsZPu5j8fGP0X4d7Rd/iNBvL35bBHw+ejk6OqR95KGEX47+U1ZSiyFlJeUYUlZB1hFlJUUZUlZSlyFlJaUZUlZSnSFlJQUaUVYhNRpSVlKmIWUlZRpSVlKmIWUVZB1RVlKmIWUlZRpSVlKmIWUlZRpSVlKmEWVdSZmGlJWUaUhZSZmGlJWUaUhZBVlHlJWUaUhZSZmGlJWUaUhZSZmGlJWUaURZIynTkLKSMg0pKynTkLKSMg0pqyDriLKSMg0pKynTkLKSMg0pKynTkLKSMo0oayJlGlJWUqYhZSVlGlJWUqYhZRVkHVFWUqYhZSVlGlJWUqYhZSVlGlJWUqYRZc2kTEPKSso0pKykTEPKSso0pKyCrCPKSso0pKykTEPKSso0pKykTEPKSso0oqyFlGlIWUmZhpSVlGlIWUmZhpRVkHVEWUmZhpSVlGlIWUmZhpSVlGlIWUmZBpRVFlKmIWUlZRpSVlKmIWUlZRpSVkHWEWUlZRpSVlKmIWUlZRpSVlKmIWUlZRpRVkfKNKSspExDykrKNKSspExDyirIOqKspExDykrKNKSspExDykrKNKSspEwjyupJmYaUlZRpSFlJmYaUlZRpSFkFWUeUlZRpSFlJmYaUlZRpSFlJmYaUlZRpRFkDKdOQspIyDSkrKdOQspIyDSmrIKsNWb2sO8Jck1XKLuu6LOW7rKRMQ8pKyjSkrKRMQ8pKyjSkrKRMI8oqpExDykrKNKSspExDykrKNKSsgqwjykrKNKSspExDykrKNKSspExDykrKNKKsKynTkLKSMg0pKynTkLKSMg0pqyDriLKSMg0pKynTkLKSMg0pKynTkLKSMo0oayRlGlJWUqYhZSVlGlJWUqYhZRVkHVFWUqYhZSVlGlJWUqYhZSVlGlJWUqYRZU2kTEPKSso0pKykTEPKSso0pKyCrCPKSso0pKykTEPKSso0pKykTEPKSso0oqyZlGlIWUmZhpSVlGlIWUmZhpRVkHVEWUmZhpSVlGlIWUmZhpSVlGlIWUmZRpS1kDINKSsp05CykjINKSsp05CyCrKOKCsp05CykjINKSsp05CykjINKSsp04Cy3v4bso4oKynTkLKSMg0pKynTkLIKso4oKynTkLKSMg0pKynTkLKSMg0pKynTiLI6UqYhZSVlGlJWUqYhZSVlGlJWQdYRZSVlGlJWUqYhZSVlGlJWUqYhZSVlGlFWT8o0pKykTEPKSso0pKykTEPKKsg6oqykTEPKSso0pKykTEPKSso0pKykTCPKGkiZhpSVlGlIWUmZhpSVlGlIWQVZR5SVlGlIWUmZhpSVlGlIWUmZhpSVlGlEWYWUaUhZSZmGlJWUaUhZSZmGlFWQdURZSZmGlJWUaUhZSZmGlJWUaUhZSZlGlHUlZRpSVlKmIWUlZRpSVlKmIWUVZB1RVlKmIWUlZRpSVlKmIWUlZRpSVlKmEWWNpExDykrK9HNZ4+J2WdPzwA9lvb2k26E8yfqqCPKyFUFypXa0X8p2tPfpl6P/lJWUaUhZSZmGlFWQdURZSZmGlJWUaUhZSZmGlJWUaUhZSZlGlDWRMg0pKynTkLKSMg0pKynTkLIKso4oKylTl7JKCNvRkmtLhFH818ExPkogpKNZlsfi4/I0jOODo9uPjn5dKke75OJeVbc5htqrl513LO6pdo8Ozrel0q+Ds4/++eA/65zYjTqfoc7JIanzGeqcYJY6n6HOSaqp8wnqPBPdU+cz1DlrGdT5DHXO4g51PkOds9pFnc9Q50KdU+cT1DnrodT5DHXOeih1PkOdsx5Knc9Q56yHUucz1DnrodT5BHVeWA+lzmeoc9ZDqfMZ6pz1UOp8hjpnPZQ6n6HOhTqnzieoc9ZDqfMZ6pz1UOp8hjpnPZQ6v17nfk17nefaS7sc91H/8bf8cvyf1ciqJdVopxpZW6QarVRjXFgBpBrtVCPrdFSjnWpkNY1qtFONrHlRjXaqUahGqtFMNbJ+RDXaqUZWeahGO9XIWgzVaKcaWYuhGu1UI2sxVKOZanSsxVCNdqqRtRgj1Zj271rd/vz16D+FYpmiE6FI8DsRShCqD6HIfTsRiki0E6FICzsRiiCtE6HImPoQyhO/dCIUyUQnQpFMdCIUyUQnQglC9SEUycSPhQoh+R2KrL6C/vYq67504XJ6/BA6Hgq1+F0o75+O/VMmcokuZCKV6EImMokfyyRL2sctTlJFprg8tn54AljkDp6MQQd8IDNQAk8GoAQeT68EHo+uBF4ArwMeD60EHlesBB6fqwQe56oEHueqA15wrkrgca5K4HGuPwcfpezgY/VHLT6kjbwP5Wk1rOTfDpEFn9uFTIJMPciEh+5CJhx3FzLhz7uQCTffhUx4/x5kWkkKupCJXKELmUghupCJFKILmQSZepCJFKILmUgh3iaTuH1LKZHlF5n+RE+yoIaetEANPQmAFvqIq1dDj1NXQ4/7VkOPo1ZDL6DXQo/zVUOPm1VDj5tVQ4+bVUOPm9VCn3Czauhxs2rocbNq6HGzaugF9FrocbNq6HGzauhxs2rocbNq6HGzWugzblYNPW5WDT1uVg09blYNvYBeCz1uVg09blYNPW5WDT1uVg09blYLfcHNqqHHzaqhx82qocfNqqEX0Guhx82qocfNqqHHzaqhx82qocfNKqFPC25WDT1uVg09blYNPW5WDb2AXgs9blYNPW5WDT1uVg09blYNPW5WC73Dzaqhx82qocfNqqHHzaqhF9BrocfNqqHHzaqhx82qocfNqqHHzWqh97hZNfS4WTX0uFk19LhZNfQCei30uFk19LhZNfS4WTX0uFk19LhZLfQBN6uGHjerhh43q4YeN6uGXkCvhR43q4YeN6uGHjerhh43q4YeN6uFXnCzauhxs2rocbNq6HGzaugF9FrocbNq6HGzauhxs2rocbNq6HGzWujXqd1skB19SLF2dMwb+XAL25/AL3eUU7vTtiindpttUU7tHtuiFFC2Qjm1u2uLcmq31hbl1O6rLcqp3VRblFO7o6YoI26nGUrcTjOUuJ1mKHE7zVAKKFuhxO00Q4nbaYYSt9MMJW6nGUrcTiuUCbfTDCVupxlK3E4zlLidZigFlK1Q4naaocTtNEOJ22mGErfTDCVupxXKjNtphhK30wwlbqcZStxOM5QCylYocTvNUOJ2mqHE7TRDidtphhK30wplwe00Q4nbaYYSt9MMJW6nGUoBZSuUuJ1mKHE7zVDidpqhxO00Q4nbaYQyL7idZihxO81Q4naaocTtNEMpoGyFErfTDCVupxlK3E4zlLidZihxO61QOtxOM5S4nWYocTvNUOJ2mqEUULZCidtphhK30wwlbqcZStxOM5S4nVYoPW6nGUrcTjOUuJ1mKHE7zVAKKFuhxO00Q4nbaYYSt9MMJW6nGUrcTiuUAbfTDCVupxlK3E4zlLidZigFlK1Q4naaocTtNEOJ22mGErfTDCVupxVKwe00Q4nbaYYSt9MMJW6nGUoBZSuUuJ1mKHE7zVDidpqhxO00Q4nbaYVyxe00Q4nbaYYSt9MMJW6nGUoBZSuUuJ1mKHE7zVDidpqhxO00Q4nbaYUy4naaocTtNEOJ22mGErfTDKWAshVK3E4zlLidZihxO81Q4naaocTttEKZcDvNUOJ2mqHE7TRDidtphlJA2QolbqcZStxOM5S4nWYocTvNUOJ2WqHMuJ1mKHE7zVDidpqhxO00QymgbIUSt9MMJW6nGUrcTjOUuJ1mKHE7rVAW3E4zlLidZihxO81Q4naaoRRQtkKJ22mGErfTDCVupxlK3E4zlLidRijLgttphhK30wwlbqcZStxOM5QCylYocTvNUOJ2mqHE7TRDidtphhK30wqlw+00Q4nbaYYSt9MMJW6nGUoBZSuUuJ2fopSw+K+jJazxF5QHI5G0IXGrexpJORp3XPLXwdE/vXKRu0j4qA5EwqF1IBLerwORcJX2RfL41Q5Ewgl3IBIeuwORcO8diCSIZF8kEocORCJx6EAkEocORCJx6ECkuROHvB0dxK+/HP0HnDC306/AmdthV+DM7WwrcOZ2lBU4ApzXcOZ2UBU4czuXCpy5HUMFztydegUOHfJrOEKHfAKHDvkEDh3yCRw65BM4ApzXcOiQT+DQIZ/AoUM+gUOHfAKHDvk1nJUO+QQOHfIJHDrkEzh0yCdwBDiv4dAhn8ChQz6BQ4d8AocO+QQOHfJrOJEO+QQOHfIJHDrkEzh0yCdwBDiv4dAhn8ChQz6BQ4d8AocO+QQOHfJrOJM/2b4Chw75BA4d8gkcOuQTOAKc13DokE/g0CGfwKFDPoFDh3wChw75NZzJn4ZegUOHfAKHDvkEDh3yCRwBzms4dMgncOiQT+DQIZ/AmbpDlvCAU91Tw6Vt3wu/PF7ZF39wbN555FAqx5ZdoVJ+PfZPgabu0jsQaO4nifcg0NRupQeBpnZMPQg0tWvrQSBBINsCTe1eexBoagfdg0BTu/geBCJJMC4QSYJpgdyyzB0l5H2D2yyuppDP+5a1IcjT0YdIVrerv+bll6Pv5OfOCDTJz23+NcnP7eo1yQvklcjP7cM1yc9tsDXJz+2cNcnPbYk1yc/tdRXJOzysFnk8rBZ5PKwWeTysFnmBvBJ5PKwWeTysFnk8rBZ5PKwWeTysEnmPh9Uij4fVIo+H1SKPh9UiL5BXIo+H1SKPh9Uij4fVIo+H1SKPh1UiH/CwWuTxsFrk8bBa5PGwWuQF8krk8bBa5PGwWuTxsFrk8bBa5PGwSuQFD6tFHg+rRR4Pq0UeD6tFXiCvRB4Pq0UeD6tFHg+rRR4Pq0UeD6tEfsXDapHHw2qRx8NqkcfDapEXyCuRx8NqkcfDapHHw2qRx8NqkcfDKpGPeFgt8nhYLfJ4WC3yeFgt8gJ5JfJ4WC3yeFgt8nhYLfJ4WC3yeFgl8gkPq0UeD6tFHg+rRR4Pq0VeIK9EHg+rRR4Pq0UeD6tFHg+rRR4Pq0Q+42G1yONhtcjjYbXI42G1yAvklcjjYbXI42G1yONhtcjjYbXI42GVyBc8rBZ5PKwWeTysFnk8rBZ5gbwSeTysFnk8rBZ5PKwWeTysFnk8rA55t+BhtcjjYbXI42G1yONhtcgL5JXI42G1yONhtcjjYbXI42G1yONhlcg7PKwWeTysFnk8rBZ5PKwWeYG8Enk8rBZ5PKwWeTysFnk8rBZ5PKwSeY+H1SKPh9Uij4fVIo+H1SIvkFcij4fVIo+H1SKPh9Uij4fVIo+HVSIf8LBa5PGwWuTxsFrk8bBa5AXySuTxsFrk8bBa5PGwWuTxsFrk8bBK5AUPq0UeD6tFHg+rRR4Pq0VeIK9EHg+rRR4Pq0UeD6tFHg+rRR4Pq0R+xcNqkcfDapHHw2qRx8NqkRfIK5HHw2qRx8NqkcfDapHHw2qRx8MqkY94WC3yeFgt8nhYLfJ4WC3yAnkl8nhYLfJ4WC3yeFgt8nhYLfJ4WCXyCQ+rRR4Pq0UeD6tFHg+rRV4gr0QeD6tFHg+rRR4Pq0UeD6tFHg+rRD7jYbXI42G1yONhtcjjYbXIC+SVyONhtcjjYbXI42G1yONhtcjjYZXIFzysFnk8rBZ5PKwWeTysFnmBvBJ5PKwWeTysFnk8rBZ5PKwWeTysDnm/4GG1yONhtcjjYbXI42G1yAvklcjjYbXI42G1yONhtcjjYbXI42GVyDs8rBZ5PKwWeTysFnk8rBZ5gbwSeTysFnk8rBZ5PKwWeTysFnk8rBJ5j4fVIo+H1SKPh9Uij4fVIi+QVyKPh9Uij4fVIo+H1SKPh9Uij4dVIh/wsFrk8bBa5PGwWuTxsFrkBfJK5PGwWuTxsFrk8bBa5PGwWuTxsErkBQ+rRR4Pq0UeD6tFHg+rRV4gr0QeD6tFHg+rRR4Pq0UeD6tFHg+rRH7Fw2qRx8NqkcfDapHHw2qRF8grkcfDapHHw2qRx8NqkcfDapHHwyqRj3hYLfJ4WC3yeFgt8nhYLfIC+beQF5/K19ESVl852knaX3t1T+MuR7OMS/46OPonaYp8aYo7Hk9TfPd4muLox9OUrGA8TUkhhtM0kW+MpynJyXiaksmMpylpz3iaCpoOpyk50niakiONpyk50niakiP9WNOwD8TFJVRU8n5Zvo72En7V9E6etEeJfCaT0SJPcqJFnnxDizwphBZ5gbwSeRy9Fnl8txZ53LEWeTysFnk8rBL5gofVIo+H1SKPh9Uij4fVIi+QVyKPh9Uij4fVIo+H1SKPh9Uij4fVIR8WPKwWeTysFnk8rBZ5PKwWeYG8Enk8rBZ5PKwWeTysFnk8rBZ5PKwSeYeH1SKPh9Uij4fVIo+H1SIvkFcij4fVIo+H1SKPh9Uij4fVIo+HVSLv8bBa5PGwWuTxsFrk8bBa5AXySuTxsFrk8bBa5PGwWuTxsFrk8bBK5AMeVos8HlaLPB5WizweVou8QF6JPB5WizweVos8HlaLPB5WizweVom84GG1yONhtcjjYbXI42G1yAvklcjjYbXI42G1yONhtcjjYbXI42GVyK94WC3yeFgt8nhYLfJ4WC3yAnkl8nhYLfJ4WC3yeFgt8nhYLfJ4WCXyEQ+rRR4Pq0UeD6tFHg+rRV4gr0QeD6tFHg+rRR4Pq0UeD6tFfmoPm9edfFnkl6P/pJOm9plVOlN7wSqdqf1alc7UnqpKR6BzQmdqb1KlM7V/qNKZusev0pm6D6/SoVc+oZPplc/o0Cuf0aFXPqNDr3xGR6BzQode+YwOvfIZHXrlMzr0ymd06JVP6BR65TM69MpndOiVz+jQK5/REeic0KFXPqNDr3xGh175jA698hkdeuXXdGShVz6jQ698Rode+YwOvfIZHYHOCR165TM69MpndOiVz+jQK5/RoVc+oePolc/o0Cuf0aFXPqNDr3xGR6BzQode+YwOvfIZHXrlMzr0ymd06JVP6Hh65TM69MpndOiVz+jQK5/REeic0KFXPqNDr3xGh175jA698hkdeuUTOnM/u71Kh175jA698hkdeuUzOgKdEzr0ymd06JXP6NArn9GhVz6jQ698QmfuZ0RX6dArn9GhVz6jQ698RkdmplPcutOJtaNdyl8H+6cdVH3xB8fmnUcOpXJsyduQS/n12LtCU/frXSg0tWfoQqGpfUtJ27DFyVI52qfgN4lSeT46Hml0Y7uJ5F385eg7+ak9kSr5qf2WJvm5n5WsSn5qn6hKfmoPqkp+an+rSl4gr0R+bk+sSX5ur6tJHg+rRR4Pq0UeD6tEfu5nJauSx8NqkcfDapHHw2qRF8grkcfDapHHw2qRx8NqkcfDapHHwyqRn/s5zKrk8bBa5PGwWuTxsFrkBfJK5PGwWuTxsFrk8bBa5PGwWuTxsErk534+uip5PKwWeTysFnk8rBZ5gbwSeTysFnk8rBZ5PKwWeTysFnk8rBL5gofVIo+H1SKPh9Uij4fVIi+QVyKPh9Uij4fVIo+H1SKPh9Uij4fVIb8ueFgt8nhYLfJ4WC3yeFgt8gJ5JfJ4WC3yeFgt8nhYLfJ4WC3yeFgl8g4Pq0UeD6tFHg+rRR4Pq0VeIK9EHg+rRR4Pq0UeD6tFHg+rRR4Pq0Te42G1yONhtcjjYbXI42G1yAvklcjjYbXI42G1yONhtcjjYbXI42GVyAc8rBZ5PKwWeTysFnk8rBZ5gbwSeTysFnk8rBZ5PKwWeTysFnk8rBJ5wcNqkcfDapHHw2qRx8NqkRfIK5HHw2qRx8NqkcfDapHHw2qRx8MqkV/xsFrk8bBa5PGwWuTxsFrkBfJK5PGwWuTxsFrk8bBa5PGwWuTxsErkIx5WizweVos8HlaLPB5Wi7xAXok8HlaLPB5WizweVos8HlaLPB5WiXzCw2qRx8NqkcfDapHHw2qRF8grkcfDapHHw2qRx8NqkcfDapHHwyqRz3hYLfJ4WC3yeFgt8nhYLfICeSXyeFgt8nhYLfJ4WC3yeFgt8nhYJfIFD6tFHg+rRR4Pq0UeD6tFXiCvRB4Pq0UeD6tFHg+rRR4Pq0UeD6tDPi54WC3yeFgt8nhYLfJ4WC3yAnkl8nhYLfJ4WC3yeFgt8nhYLfJ4WCXyDg+rRR4Pq0UeD6tFHg+rRV4gr0QeD6tFHg+rRR4Pq0UeD6tFHg+rRN7jYbXI42G1yONhtcjjYbXIC+SVyONhtcjjYbXI42G1yONhtcjjYZXIBzysFnk8rBZ5PKwWeTysFnmBvBJ5PKwWeTysFnk8rBZ5PKwWeTysEnnBw2qRx8NqkcfDapHHw2qRF8grkcfDapHHw2qRx8NqkcfDapHHwyqRX/GwWuTxsFrk8bBa5PGwWuQF8krk8bBa5PGwWuTxsFrk8bBa5PGwSuQjHlaLPB5WizweVos8HlaLvEBeiTweVos8HlaLPB5WizweVos8HlaJfMLDapHHw2qRx8NqkcfDapEXyCuRx8NqkcfDapHHw2qRx8NqkcfDKpHPeFgt8nhYLfJ4WC3yeFgt8gJ5JfJ4WC3yeFgt8nhYLfJ4WC3yeFgl8gUPq0UeD6tFHg+rRR4Pq0VeIK9EHg+rRR4Pq0UeD6tFHg+rRR4Pq0M+LXhYLfJ4WC3yeFgt8nhYLfICeSXyeFgt8nhYLfJ4WC3yeFgt8nhYJfIOD6tFHg+rRR4Pq0UeD6tFXiCvRB4Pq0UeD6tFHg+rRR4Pq0UeD6tE3uNhtcjjYbXI42G1yONhtcgL5JXI42G1yONhtcjjYbXI42G1yONhlcgHPKwWeTysFnk8rBZ5PKwWeYG8Enk8rBZ5PKwWeTysFnk8rBZ5PKwSeZnZw4rbjxZX4i9H3+nM7DPrdGb2gnU6M/u1Oh2BzgmdmX1Pnc7M3qROZ2b/UKczc49fpzNzH16ls9Irn9GhVz6jQ698Rode+YyOQOeEDr3yGR165TM69MpndOiVz+jQK5/QifTKZ3Tolc/o0Cuf0aFXPqMj0DmhQ698Rode+YwOvfIZHXrlMzr0yid0Er3yGR165TM69MpndOiVz+gIdE7o0Cuf0aFXPqNDr3xGh175jA698gmdTK98Rode+YwOvfIZHXrlMzoCnRM69MpndOiVz+jQK5/RoVc+o0OvfEKn0Cuf0aFXPqNDr3xGh175jI5A54QOvfIZHXrlMzr0ymd06JXP6NArv6aTp34ufJ3O1L2yuLDRSW45oDN1r1ylM3WvXKUj0DmhM3WvXKUzda9cpTN1r1ylM3WvXKUzda9cozP186frdOiVz+jQK5/RoVc+oyPQOaFDr3xGh175jA698hkdeuUzOvTKJ3Smfs5tnQ698hkdeuUzOvTKZ3QEOid06JXP6NArn9GhVz6jQ698Rode+YTO1M/TrNOhVz6jQ698Rode+YyOQOeEDr3yGR165TM69MpndOiVz+jQK5/Qmfu5fVU69MpndOiVz+jQK5/REeic0KFXPqNDr3xGh175jA698hkdeuUTOnM/t69Kh175jA698ms6pYPUPabt6DXm8EznPoMOuv3loe8Sv8+gTVflw1YYIaRcmUGIZdmOzsvzD4bj16CSxUFli4MqBgfVKF1qPChncVDe4qCCxUGJxUGtFgdl8YouFq/oYvGKLhav6KvFK/pq8Yq+Wryirxav6KvFK/pq8Yq+Wryirxav6KvFK/pq8YoeLV7Ro8UrerR4RY8Wr+jR4hU9WryiR4tX9Gjxih4tXtGjxSt6snhFTxav6MniFT1ZvKIni1f0ZPGKnixe0ZPFK3qyeEVPFq/o2eIVPVu8omeLV/Rs8YqeLV7Rs8UrerZ4Rc8Wr+jZ4hU9a1zRc9qPLov7PqiyWByUszgob3FQweKgxOKgVouDihYHlZQH5fzBoDSu6Hn/ulgofvllUN+PzvtXpnJ4fGPKF39w7O1W/nVsKb8ee59smWayflmWmSbrZpqsn2myYabJykyTXWeabJxpsmmmyc7TQd0mO1MH5WbqoNxMHZQbq4OK27Hu1hsezHasFqo2W5lqtmM1UbXZjtVF1WY7VhtVm61GH1V82me7pspsz38jeJtB6X0Gful+Bq77GfjuZxC6n4F0P4O1+xnE7meQup9B9/fk0P0dLdi/o53uPHCbgf1rUW0G9q9FyT9m4NP3Gdi/FtVmYP9aVJuBfX9QmYHYv5rWZtDB1VTiPoNVnmfw/WAv+0C8iHyfrn0z0XS69p1H0+nKXNPtoI9oOd0Omo6W0+2gQ2k53Q7amZbT7aD3+a3p+vyY7nfDsHbQKLWc7mhdVWW6g3VV67r1zH6N4fzguCzbzzHi4r5/0NfBWrDfYbOWVE7ZyGBs9rVCvyZ3fnBethfO8lgqdLe/72gG6+1aohmsD2yJZrCesSWawfrLlmgG60UboomjdTa/g2bd1mFyir+gOXhhF7Yxe7c+XliOvvni89ZChOWXQ+/IR2uYOkAuIP808pn7OyXkM/eNSshn7keVkM/c5yohn7l/1kGeBsuTe0A+WKbdA3Lc58eR4z4/jlxA/mnkuM9PI89U+c+QL8XvyJ++enyIPOdtEL9s5nT4wu723tsr3/5Oj+PDkr404mNhXyNSHPsaEfvY14icyL5GBEvmNSokUfY1IrqyrxFZl32NCMfsayRoZF4jcgb7GpEz2NeInMG+RuQM9jUiZ7CukVvIGexrRM5gXyNyBvsakTPY10jQyLxG5Az2NSJnsK8ROYN9jcgZ7GtEzmBeI0fOYF8jcgb7GpEz2NeInMG+RoJG5jUiZ7CvETmDfY3IGexrRM5gXyNyBvMadfBoPTQiZ7CvETmDfY3IGexrJGhkXiNyBvsakTPY14icwb5G5Az2NSJnMK9RBw88RiNyBvsakTPY14icwb5GgkbmNSJnsK8ROYN9jcgZ7GtEzmBfI3IG8xoJOYN9jcgZ7GtEzmBfI3IG+xoJGpnXiJzBvEbryJ+jfH5wituxKf1C/U5m5Or9a2RGzqb+GpkeEiH3IFOZ7NlL3+fbQ7rScr49JBUN5xt7cP0t59uDg2453x7caMv59uDsfj5fWUL5OliWUiovHWRvBoPkp2FH90VHoHNCp4d+UI9ODz2hHp2x+sLWdMbqIlvTGavnbEwnjdWhtqYzVj/bms5Y3W9rOvTKZ3RkGjr3+c7T/d7nO08/e5/vPB3qfb7z9Jz3+c7TRf453zxYX+j2BQ0JTiovnRf5OjiHBxtfjtYTS95euJRfj71zHKyDVOM4WK+pxnGwrlSNo8CxCcfB+mI1joP122ocB+vj1TgO5g/UOA7mO7Q4FvxMG474mTYc8TNtOOJn2nAcrX902/qDOH+Qb3XxbPiW8x2tH6vNd7S+6Xy+vovnf7ec72h9SG2+o/ULtfmOdl+vzVcmm+9ouV9tvnP1V76LZ+K2nO9c/ZXv4lmtDefbxXNPW853sv6qi+dxtpzvZP1VF8+JbDnfyfqrLp5f2HK+k/VXXTxXr+V8J+uvunjeW8v5TtZfdfEcspbznay/6uL5WC3nO1l/1cVzm1rOd7L+qovnCbWc72T9VRfPuWk538n6qy6ev9JyvpP1V108F6TlfCfrr7p4XkXL+U7WX3XxHIWW852sv+pif/+W852sv+pi3/mW852sv+piP/SW852sv5LJ+iuZrL+Syformay/Wifrr9bJ+qt1sv5qnay/6uI5GS3nO1l/1cUzLVrOd7L+arAnVdTnO1l/NdiTKurznay/GuxJFfX5TtZfjfbsiep8J+uvRns+RHW+k/VXoz3DoTrfyfqr0Z6zUJ3vZP3VaM9CqM53sv5qtOcVVOc7WX812vMKqvOdrL8a7XkF1flO1l8N97yC2nwn66+G2/+/Nt/J+qvh9tOvzXey/mq4/elr852svxpuv/fafCfrr4bbP70238n6q+H2I6/Nd7L+qshk852sv5ps/3Y/2f7tfrL92/1k+7eHyfZvD5Pt3x4m2789TLZ/e1hksvnO1V+FyfZvD8Pt3/625yrF7Vi3LP6Xg+8geRBiI5A8CbENyOG2slcDybMQG4HkYYiNQMo0IO/znefp4ff5zvOU7/t85+lC7/Odp1m8z3eenu7P+Q63y31tvvN0SPf5ztPI3Oc7z9OX7/OVyeY7WX813C73tflO1l8Nt8t9bb6T9VfD7XJfm+9k/dVwu9zX5jtZfzXcLve1+U7WXw23y31tvpP1V8Ptcl+b72T91XC73NfmO1l/Ndwu97X5TtZfDbfLfW2+k/VXw+1yX5vvZP3VcLvc1+Y7WX813C73tflO1l8Nt8t9bb6T9VfD7XJfm+9k/dVwu9zX5jtZfzXcLve1+U7WXw23y31tvpP1V8Ptcl+b72T91XC73NfmO1l/Ndwu97X5TtZfDbfLfW2+k/VXw+1yX5vvZP3VcLvc1+Y7WX813C73tflO1l8Nt8t9bb6T9VfD7XJfm+9k/dVwu9zX5jtZfzXcLve1+U7WXw23y31tvpP1V8Ptcl+b72T91XC73NfmO1l/Ndwu97X5TtZfDbfLfW2+k/VXw+1yX5vvZP3VcLvc1+Y7WX813C73tfnO1V/JcLvc1+Y7V38lw+1yX5vvXP2VLDLZfOfqr2S4Xe5r852rv5KJNqO/z3ey/mqird3v852sv5poo/T7fCfrrybbv10m279dJtu/XUbbvz2Gss03L6Hy0r/1YIe8zbCUX4+9cxysb1PjOFg/qMVxtH3s38fx/IEtMtoG+XogB+uM9UAO1nLrgRRAtgE5mEnQAzmY+8j7S0uWGsgUw9fBKT2mKBuawYxKSzSDeY+WaAazEydo/pzvaI9XqM53sO68Ot+xmujVybod7OJBPDXY4xXq85XJ5jtW51if71gNXn2+Y3Vt9fmO1YrV5ztWf1Wd72CPV6jPd6z+6nm+3vmD+Y7bXx3Pd9z+6ni+Mtl8x+2vjuc7bn91PN/B+qvk0n5wLgfzHay/qs53sP6qNt/BHq9Qn+9g/VV1voP1V9X5DtZfVecrk813sP6qOt/B+qvqfCfrrwZ7vEJ9vpP1V4M9XmHNYdkOLjFXXlrKDuf5q9DFHRzr0+K/DvbJP5zXxnGwvk2N42D9oBrHwfrMRhzvbAQ2L9kM1r82ZTNYr9uUzWB9cVM2g/XQTdkM1m//FptbhL8dLPk7m8EezdGWzcz9do3NzD10jc3MfXGNjcDmJZuZ++Iam5n74hqbmfviGpuZ++J13fvifNAXD/aYlKZsBnukSls2U/fFFTZT98UVNlP3xRU2ApuXbKbuiytspu6LK2ym7osrbOiLX7OZpy/+c76DPd6mPt95+tf7fOfpSe/znafPvM9XJpvvWP1gXJZtIDFEdzDfsXq8+nzH6tvq8x2rF6vPd6z+qjbfdbDH29TnO1Z/VZ/vWP1Vfb5j9Vf1+cpk852rv1oHe7xNfb5z9VfrYI+3qc93sv5qsMfb1Oc7WX812ONt6vOdrL8a7PE29flO1l8N9nib+nwn668GewxNfb6T9VeDPdalPt/J+qvBHpJSn+9k/dVgjxypz3ey/mqwB3jU5ztZfzXYozbq852svxrs+Rn1+U7WXw32/Iz6fCfrrwZ7fkZ9vpP1V4M9P6M+38n6q8Gen1Gf72T91WDPz6jPd7L+arDnZ9TnO1l/NdjzM+rznay/Guz5GfX5TtZfDfb8jPp8J+uvBnt+Rn2+k/VXgz0/oz7fyfqrwZ6fUZ/vZP3VYM/PqM93sv5qsOdn1Oc7WX812PMz6vOdrL8a7HkU9flO1l8N9iyI+nwn668Ge2ZDfb6T9VeDPVuhPt/J+qvBnoFQn+9k/dVgzyqoz3ey/mqwZwrU5ztZfzXY3v/1+U7WXw22R399vpP1V4PtpV+f72T91WB73tfnO1l/Ndje9PX5TtZfDbaHfH2+k/VXg+31Xp/vZP3VYPu31+c7WX812P7t9flO1l8Ntn97fb6T9VeT7d++TrZ/+zrZ/u3rZPu3x8n2b4+T7d8eJ9u/PU62f3tcZLL5ztVfxcn2b4+T7d8eJ9u/PU62f3ucbP/2ONn+7XGy/dvjZPu3x8n2b4+T7d8eR9u/XfJ2cFydP5jvYP1VSLu+txMrL50X+To4h7If64s/OLbk7YVL+fXYO8fB+jY1joP1g1ocR9vHXo3jYP2rGsfB+mI1joP122ocBY5NOA7mD9Q4DuY71DjiZ9pwxM+04YifacJxtOdGqHHEz7ThiJ9pwxE/80OOcTvWLYs/ACmAbAMSR9MIJJamEUg8TSOQmJo2IEd76saaywYyuhpIt5YlbNNciwuPF/+iM9it+ITOfb6D3TGr8x3rxpZS2g5O6alHP35pn+L6dbRPKTy/9B3OWDerxnDGugE1hjNWVNYWzmDPnWgMZ6x2pDGcsZKqxnDGip8aw5Gp4RS/wclPXeAOZ6ymtzGcuTvkCpyZO+Tgl81cBe/Tdzgzd8hVODN3yDU4gz05pDGcmTvkG5zlFI7MDEfcdnQQv3yHM3OfU4Uzc59ThTN1n1ODM3WfE0re4bjl/KXXkrZb21rKwdV76qbod0jGZb8PxuXAmAz2bJDP1OQxyanbLQl7Lyqr+2uf7sGeZ/IZksc1OXPUGWT/qkSQkr/DEeC8hjO3BajAmdsCVODMbQEecNanb1HtcKa2ADU4U3f1FTiDPWSmMZype+/wGMjq0vlLu1shbUiSPG0OI+UL5dQtY9q3zgmphL9mYwZ7rMwbSdZCisEeWPOZmjwmOXXn+njp8HeL9AcXyqXsX/h2YTm4UE7d52YvO8pSeWnZiYj/9Y5zgP0RyblbnL4fHXbsU3fQetin7s3VsA/26KNusE/tJ/SwTx3862Gf2vLpYRew/xB72OyhPM9wBzm1PWwJcrAfnbf9ie9oj8FqTGewTa+a0kmjPWKrMR22FjijM9i2U43pDLaZVGM6Ap0TOvNsYnGFzmB7Of0unSAPOuvTmvOLo/3T0fEby8k766YsJ+/Dm7KcvGv/DZbi9jxH/PPXLO4kR3vImyLJyd1AQ5KTO4eGJCd3GQ1JCiQbkZzcvTQkidNpRRKf04okLqcVSTxOI5KjPWBQkeTsHudVKnHw2nn/xUIKTz/SfvHaJW+TvGF/ethvdF/kZ/dEeuRn91BtyN9ZCiybsZzdR50mxI0eCuf2JxEE70uFjsvLtkmpy+6ZZT6kszzoLPGZzn0Gxf4M/GMG3zcrS40ehKY5A9f9DHz3Mwjdz0Dsz0Di40pd+YmZl/2W4UXk+3TXuaYb55pummu6HfQRLafbQdPRcLrSQYfScrodtDMtp9tB7/Nb0/X5Md3vhkE6aJRaTlfmmu5gXdW6bj2zX+Nf22gjyWAt2O+wqWydkWSwfm11YWeTKvtM5mV74SxPY/763ViSwXq7lmgG6wMbolkH6xlbohmsv2yJZrBetCWa0Tqb30GzbsPIKf6C5uCFXXisVD5tsSxHj0X2j923ll8OvSMfrWHqAPnMfZgS8pn7OyXkM/eNOsjjzP2oDvI0czP3O8iXx+Ml3dNXHA6R57wNorjqJkW3996//pFveuzHhyV9aTRYGjqkRoJG5jXCndnXCDtnXyP8n32NMIz2NcJhmtcoY0ntazTzWk0vGpEz2NeInMG+RoJG5jUiZ7CvETmDfY3IGexrRM5gXyNyBvMaFXIG+xqRM9jXiJzBvkbkDPY1EjQyrxE5g32NyBnsa0TOYF8jcgb7GpEzWNcoL+QM9jUiZ7CvETmDfY3IGexrJGhkXiNyBvsakTPY14icwb5G5Az2NSJnMK+RI2ewrxE5g32NyBnsa0TOYF8jQSPzGpEz2NeInMG+RuQM9jUiZ7CvETmDeY08OYN9jcgZ7GtEzmBfI3IG+xoJGpnXiJzBvkbkDPY1ImewrxE5g32NyBnMa9TDA+Cn14icwb5G5Az2NSJnsK+RoJF5jcgZ7GtEzmBfI3IG+xqRM9jXiJzBvEZCzmBfI3IG+xqRM9jXiJzBvkaCRuY1ImewrxE5g32NyBnsa0TOYF8jcgbzGq3kDPY1ImewrxE5g32NyBnsayRoZF4jcgb7GpEz2NeInMG+RuQM9jUiZzCvUSRnsK8ROYN9jcgZ7GtEzmBfI0Ej8xqRM9jXiJzBvkbkDPY1ImewrxE5g3mNEjmDfY3IGexrRM5gXyNyBvsaCRqZ14icwb5G5Az2NSJnsK8ROYN9jcgZzGuUyRnsa0TOYF8jcgb7GpEz2NdI0Mi8RuQM9jUiZ7CvETmDfY3IGexrRM5gXqNCzmBfI3IG+xqRM9jXiJzBvkaCRuY1ImewrxE5g32NyBnsa0TOYF8jcgbrGpWFnMG+RuQM9jUiZ7CvETmDfY0EjcxrRM5gXyNyBvsakTPY14icwb5G5AzmNXLkDPY1ImewrxE5g32NyBnsayRoZF4jcgb7GpEz2NeInMG+RuQM9jUiZzCvkSdnsK8ROYN9jcgZ7GtEzmBfI0Ej8xqRM9jXiJzBvkbkDPY1ImewrxE5g3mNAjmDfY3IGexrRM5gXyNyBvsaCRqZ14icwb5G5Az2NSJnsK8ROYN9jcgZzGsk5Az2NSJnsK8ROYN9jcgZ7GskaGReI3IG+xqRM9jXiJzBvkbkDPY1Imcwr9FKzmBfI3IG+xqRM9jXiJzBvkaCRuY1ImewrxE5g32NyBnsa0TOYF8jcgbzGkVyBvsakTPY14icwb5G5Az2NRI0Mq8ROYN9jcgZ7GtEzmBfI3IG+xqRM5jXKJEz2NeInMG+RuQM9jUiZ7CvkaCReY3IGexrRM5gXyNyBvsakTPY14icwbxGmZzBvkbkDPY1ImewrxE5g32NBI3Ma0TOYF8jcgb7GpEz2NeInMG+RuQM5jUq5Az2NSJnsK8ROYN9jcgZ7GskaGReI3IG+xqRM9jXiJzBvkbkDPY1ImcwrlFYFnIG+xqRM9jXiJzBvkbkDPY1EjQyrxE5g32NyBnsa0TOYF8jcgb7GpEzmNfIkTPY14icwb5G5Az2NSJnsK+RoJF5jcgZ7GtEzmBfI3IG+xqRM9jXiJzBvEaenMG+RuQM9jUiZ7CvETmDfY0EjcxrRM5gXyNyBvsakTPY14icwb5G5AzmNQrkDPY1ImewrxE5g32NyBnsayRoZF4jcgb7GpEz2NeInMG+RuQM9jUiZzCvkZAz2NeInMG+RuQM9jUiZ7CvkaCReY3IGexrRM5gXyNyBvsakTPY14icwbxGKzmDfY3IGexrRM5gXyNyBvsaCRqZ14icwb5G5Az2NSJnsK8ROYN9jcgZzGsUyRnsa0TOYF8jcgb7GpEz2NdI0Mi8RuQM9jUiZ7CvETmDfY3IGexrRM5gXqNEzmBfI3IG+xqRM9jXiJzBvkaCRuY1ImewrxE5g32NyBnsa0TOYF8jcgbzGmVyBvsakTPY14icwb5G5Az2NRI0Mq8ROYN9jcgZ7GtEzmBfI3IG+xqRM5jXqJAz2NeInMG+RuQM9jUiZ7CvkaCReY3IGexrRM5gXyNyBvsakTPY14icwbpGbiFnsK8ROYN9jcgZ7GtEzmBfI0Ej8xqRM9jXiJzBvkbkDPY1ImewrxE5g3mNHDmDfY3IGexrRM5gXyNyBvsaCRqZ14icwb5G5Az2NSJnsK8ROYN9jcgZzGvkyRnsa0TOYF8jcgb7GpEz2NdI0Mi8RuQM9jUiZ7CvETmDfY3IGexrRM5gXiMZ2cPm84NT3I5N6RfqdzIjO8e/RmZkv/bXyEgHZNyDTGWyZy99n28PjqPlfHvo3lvOt4dOuOV8e+gqW863hw6t4XzXHlZVfme+63abc8WHykvf1C7b0etTL3h76TucHlpBNTg9dINqcHpoCN8Fx+e0t4+5lMrRwZe8TTK4p870i6RAshHJ0VpTPZKjNb1vJBli2Unm9ETy+7HiduriXfpGfbTWuw/qoxmA36O+z9IXt1SOzvscc3hM0Zej0LLkbRil/HrsnfpoNqQL6nFmM6RHfWaXpUd9ZvumR31uX6hFXaCuQH1uv6lFfW5vqkV9bm+qRR1vqkEdb6pAPeFNNajjTTWo403fQj1ux7pl8QfYMacq2AXsGtixpyrY8acq2DGoKtindqjlsQq9VLE7STvL1T29djkaSVy2Revon/AV+eI+tUfV456ndqmK3Kf2qYrcp3aqityntqqK3Kfu3t/JXbaD4+oOuNPPvIn7/nPgGPN37l08rN0I99Xtw16D/ML9zpIepR1L+o52LOkl2rEUWP74PrUP5MZyrdynbm+f5TGU8u17+l08InxM8vTEWuSnDrVVyZNra5Gf2QmGJaSdfKkN5PyXbb6LB2T3QXJmZ9eW5My+7vdIOhfXHYqLT9vPOe+OXv30N92+i0dIj0leIK9EfmbP+GbyzX6B77t44DMqzexFf1el5PcXvy2xhIpKPqX961vpeTvKL/Ize1Fd8nhRJfJdPHS5T/Itvy/hu3jwMjr5Lh6+jE6+iwcwo5Pv4iHM6OS7eBAzOvkuHiI7hU6n39P0XTwAcwqdTr/X6bt4CGanOlW+I+a7eLjlqOwF9mrs6bX02LOG8r77csvvN/kuHjWJUn8ohSfpRSnWaTpRKrCu04tSOP0fK+WXdUd/W7qUilL+puzX4bfg6wnKHyp8Pzot+9HJ+2864fT70IlUoA+dBJ0UdLqzJ0HQY0+CoMeeTECPPS5fjz2+XY294MTfxt7vX3a4LcQuB+zx1nrs8ct67Onv9djT57yN/SrLxn5dj9jT56ixX+lz2rC/06RzaUmTXqQlTRL2n9P0ruw0/fN188rv7FeBvBJ5Omot8uTlbyPfbteClWS9B5XwphdViu6gD8JtNqQZ8Y8taeIff04z5LzTFKnuqBH9ngDG8DjaL/6LPW7zM+zTAXu86UfYiz9gL7B/G/t9LD7G9Rf2R2OJyz6WWJ6OXg7nmfbAJ+dQOTr7bZpZ3C/H3msAn0wN4NipAfIAaoC0gRogI5m+BhLJDjVAHkUNkItNUAPr9nX4vKaDGiCfm6AGZL8OPAF81IBQAzPVQAwHNUA+0GMN+DVsUPy6+gNd8fx96vp4SkB064Gu+Pghdc148zF1xW+PqSseekxd8cVj6iroOqSu+JwuM4zy+OJsOcqoMz5nSF0LPmdMXfE5Y+qKzxlTV3zOmLoKug6oa1jom4zo6mXdEea1omuIOWxHx1wOdKVvGlNX+qYxdaVvGlNXQdcOdZWwPxZUQg4HuvI7yC51LXvuLyXnA135bWPnuq7LcnQd5vuIY+rKOt2YurJON6SujrxpTF3Jm8bUlbxpTF3Jm8bUVdB1SF3Jm8bUlbxpTF3Jm8bUlbxpTF3Jm4bU1ZM3jakredOYupI3jakredOYugq6DqkredOYupI3jakredOYupI3jakredOQugZ8jhFd3f40q9viafV3HGHXNYSj74UHQdfedS0Hv+MI+JwxdcXnjKkrPmdMXfE5Y+qKzxlSV2FdfUxdWVcfU1fW1cfUlbxpTF0FXYfUlbxpTF3Jm8bUlbxpTF3Jm8bUlbxpSF1X8qYxdSVvGlNX8qYxdSVvGlNXQdchdSVvGlNX8qYxdSVvGlLXiM/5iK7JV3RNcduwP6UHbvFfMmFbupAJF9KFTIJM75Ippe1wn5dQkamEvCEssqTHax8OPOTyuJc9HZyOxlGy22e5+PODnVvSLo77BUr+qhjsikbF3NljKd7GPvuys1+XA/YsW72PfZSd/RPCnX3iLvVz9mvYx+3X5CrsS9qeouQW93RzuA38jp7L/c/Rx8Xt6NPzwA/R315yvzH7J7f7quvL21NFb69dakffhrgd7SRVjs5lg1LcwaUvcduhBki9qAG+kTV+DZQS9oZgyb8UwfeDY9lnGYuruNZ8awW/Ds4++m/OMtFhU17vK6/M99MorzeWF8tHlNcby4tlL8rrjeXFch3l9cbyEsqL8npfeRFSU15vLC/y76nL614EBOAUQSYBpwgyOfX4ReAWv+xVIEul3XAl7l94KWWY7/oVQqcJKv0W/jzU9N+vd4VsiCoIRaiCyaqgHFQBSQtVcFOYKqAKCokIVRAKkQjd4a0yqILpq0AWvmJHFcjCN+GoAlnIDqkCWcgOqQJZhCqgChayQ6rgtt5JFVAFC6lRl1Xgl32XFO9/rYK7ruRAQ+rqSHbG1JWsZkxdSV/G1JU8ZUxdBV271FXWXde0HOhK5jGmrnwDakxd8a9D6urph/vUdf89iw9/N5K7rvTDXeoa1v3z+vwwjoeugq5D6ko/PKau9MNj6spq7Zi6sv46pq741yF1Day/jqkr669d6iph+36TlxwqR0fZnrES42PtJ6SjWeZ1Q5Jz+eXYe72QY1Evv1Mv5GPUy+/Ui1Av1MvTseXxJLfFlcrB6604Nm1clsrRMYZlH0dwB8VIWEgxmilGEk6K0UwxEstSjGaKkSyZYjRTjATgFKOVYhRSe4rRTDGy1EAxmilG1jEoRjPFyCIJxWimGIVipBitFCMrMBSjmWJkBYZiNFOMrMBQjGaKkRUYitFMMbICQzFaKcaVFRiK0UwxsgJDMX6oGFPYqyTdiBwUIyswFKOZYmQFhmI0U4zkjBTjx4oxr3sxPuF+FCPRDsX4qWIUv18Zb+P/XowRA0MxmilGoRgpxg8VY143ICnHo2LkixIU4/VilH17+FXcclBeWBLK643lxZcZKK83lhcelvK6Xl5pj0jWvBwsq0W+cEB5va+8El8hoLz+QnnFZS8vX/OZLix+Vycsf+c0j4A/pL/9HV3t+HXdGbo1Lgc364STpdztlvs+yz/KvTYaJ3ndBy85HayvZKHcKfdPlbvz+4sHtx5cfTNXX8rRUDmSO1KOhsqRnJJyNFSO5JqU418ox2dt0kF5kWtSXu8rr0KuSXm9sbz4riDl9cby4udLlNcby4sfJFFebywvobwor/eVFzkZ5XW9vMr+jLC15PWgvMi9KK83lhe5F+X1tvJaF3IvyutyecVl/7podC4dlBe5F+X1xvIi96K83lhe5F6U1xvLSygvyut95cW3ZymvN5YX34alvN5YXqT2lNf7yssJ5UV5XS4vJ2kvr4MdkFZH70V5vbG86L0orzeWF70X5fXG8uIbE5TXG8uLb0xQXu8rL883Jiivv1Be+9HR/93PaL8fnb1sVZJ99I9Bb7XI1yuoRSu1yHcxqEUrtcgXN6hFK7Uo1CK1aKQWWZagFq3UImsY1OKHatHFdX/Aze3vp2p8xDqseVCOhsqRNRLK0VA5sqZCOdopx8AaDOX4uXJM7lGO+agciRspx4+VY8yyl2NaDr7bHIRypBw/VY7JP27WSeJBORI6Uo6GypHckXI0VI7kjpSjoXIkd6QcDZUjuSPlaKcchdyRcjRUjnz9m3L8XDnm+CjHJ+CPcuQb4JSjoXJkVYZyNFSOQjlSjp8qx7wsezlm5w7KkVUZytFQObIqQzkaKkdWZSjHz/WOT18wy87XjvcP6W9/R1c7fl3zHiStaykH5c6qD+U+UbmzqkS5z1PuK6tWlPtE5c6qGOU+Ubmz6ka5T1TurOpR7hOVu1DulPs85c6qJOU+ULnvy0xrXJaDcmfVk3K3W+77LP8o99ponOSHQPL3r/9nuUeSGcp9nHJf86PcUz4od5IZyn2icieZodwnKneh3Cn3ecqdb0RS7p8r9/Xp1zTxqBz5xiLlaKgc+UYh5WinHBPf+KMcDZUjuS/laKgcyWUpR0PlSG5KORoqR6EcKUc75cg3wijHj5Vj3nnf/l4Pnq2Q+MYW5WioHFmVoRwNlSOrMpSjoXJkVYZytFOOmRiccvxYOZbHj1ViiXJQjsTglKOhciTooRw/V47xcbMu6eCXqIWvUFCOnyrH5N3+TNfb3+tBObJISDl+rhzX8CjHfPDD5SKUI+V4uRz9mvZyzOkvHH0vRjpHitFMMbJASDF+qBhdjo+fed3+PnDVhQVCytFQObJASDkaKkcWCClHM+UYFzJHytFQObJeTTkaKkfWqylHQ+XIigzlaKgchXKkHO2UI2sylOPHyjG5h/BpdQflyKoM5WioHFmVoRwNlSOrMpSjoXJkVYZytFOOjlUZytFQObIqQzkaKkdWZShHQ+XIqgzlaKgcyR0px4+VY172x6vm7JaDcsRZU44fK8fydHUs4eDq6HHWRsoxiezlKL8efVcK09mLUvixXpTCqvSilKBUJ0rxtaNelMIZW1EqPaxIcgdK8WWVXpTiexy9KEUQ04lSgYyiF6XIKHpRSlDKiFLl0aWXeKAUvZ8RpbJsSb3PazhQit6vF6Xo/doo9SdNoT9rSZMeqiVN1mJa0mS9pCVNgWZDmqw7/Jxm8fvXlHwpqdJPxeWxdfUTwCJf5FlH0CKPN9Qij9fTIo93UyK/4vO0yNN3v438/iWJ+PTrgQd5epu3kY+PL0nnA/L0Nj8mH0LyOxRZfYX87VUeT5dxOT1+phAPVyiW7cV98v7p2LtOdEJ96ETf1IVOkS5LQ6c7e7J3PfYk9Xrs8Rd67AX2auxZM9Bjj7N+I/v9t83OlcWd9qPFpW3kxT39pnjTCR/eh0748C50SniMPnQSdLKhk9/zkuJ9/qYTPVwfOtHv9aET/V4bne406cpa0mQNoyHNzEpDS5r09S1pshrQkib5/s9pru5Bc33KLR80BZoNaeLfWtLEZbWkiRdqSRMv1JImXqghzYIXakkTL9SSJl6oJU28UEuaAs2GNPFCP6d5u2fvUJL7lebBq/uy/cQqBPd4XPbXqkfBN2mRx2NpkcePvY387fid/C/fLfl+rLhdJfHu2/dQCj7PvkppwT9eVMl/74PSgn/8DZq5PNGMBzTxjz+nmYJ70FzdX7rDpgWvqUVeIK9EHg/7NvIN+xX8bg8q4Y0vqhTdQR+E3/2drjI/0fQHNPGlP6YpS9rHLU7+2m5QN18LeSXy+FIt8nhYLfJ4WC3yAnkl8vTdbyN/ut9i4nnk7yN/ut9i4vniv0E+hH0FQ8LfPbXp+/E+pe3Vb3/mv3f5PC9cjTy9jRZ5gfybyLsUwz7PFOU7exJ6Pfbk7nrs6er12JO9q7HnqbxvZJ8euxze/i7f2Avs38c+5Qf7HL+xp8/5OXt5sJTVyy/s7zTpXFrSpBdpSZPuoiVNVvYb0uTpyE1p0su2pEny3JImaXJLmgLNH9OMsv8GRGIOv9D83ePv9PFOmvTxWpr08Wbvon8DsQ3ch+XpGwu3d7qzx8npscf3qbHn2cqK7PGUH2Hv/AF7HKgee/yqHnuB/bvYhz1a8KGsv7A/OPr0abxpxQf3oROOuQ+d8NYaOt3Z46312OOt1dhHvLUee7y1Hnu8tR57vPXb2K+yTdOvz/u87OwF9mrs8ct67PHAeuzp79XYJ/qcd7G/rZf5/dWfj97Z0+fosZeZ2QfZ2d8uv5WjS9zm6JblEUr64r9QTt22tEU5dRfSFuXUYflvoXzaBf2PH/49XVqXL5ZTh9+NWU7d7LZlOfdD2BuznDpsbsxyalPVmOXUJqkxS4FlM5a4nnYssT3tWOJ72rHE97Rjie9pxnLuB643ZonvaccS39OOJb6nHUuBZTOW+J52LPE97Vjie9qxxPe0Y4nvacUyz/2g8N9iKYvb9tYVJ3LAEt/TjiW+px1LfM+PWbpUdpZl+YXlwWufPno6LwJ3Fe74KR3ueK83cW/2CO889yO8O9EIr/hjjXzYex//9FivY40kl+21pXhfOXpN20uv5Qlf/hIJE2pfpLkfTd6LSNjmDkTCj3cgEkb/TSKV9SFSLN8jlrmfja5KHrP/LvJlv9Ys/iBWdNj9t5H3O3nJB+Qx8W8jvw97WeMBeay5Fnn8thJ5j4n+Mfmw7zYq4e9Y/t7Rd/I4Yy3y2F0t8njY95B3kvbtHVb3vH/L0bjjsq1QRP/0ykW+VBJU6kAlvHEPKuGje1AJz92DSvjzDlQK+BoTKsl2cFzdgUqCShZUittLx5gPVKLHe5NKq9snuQb5RaU7efo2LfL0Ylrk6a+0yLP+8a678T7sG/m1cje+DTbLY+Dl25d3hdWSPnTCg/ShEysxfejEuk0fOsnUOuXt6CB+/eXoO52pnUXev2sZyiLf6awz9zbi9qPFlXhAZ+Yr4O0itX/nKLnlgM7M1506nZlTvDqdmZM2SY9v8+VlqRyd9zneEoP92D8e4fH92LLfDEv59dg79ZnvhXrUZ07Y9KjPnK6pUZ/6Sdh61GdOvvSoz5xj6VGf2pOpUReoK1Cf2kOqUcebalDHm2pQx5tqUMebKlBPeNO3UD9/xnBOmFMV7LhTFezYUxXsAnYN7BhUFexTe6XatzbS1J6mSmdq71Gjk6f2CH6fpXjJB3SmbuWrdKbuuKt0pm6Mq3QEOid0pm4zq3SmXq8I6zZskade+fjoGPddDPKjYffha6eqqR8L35bk1D14U5JT9+sn3yM+sM37vuvOlaeXjl8op34ifGOUU/+Gr/armrkfS16lI9A5oTP17i9l3zPhNsna0S5td06/PI49jlQbriPP/UDyLhSa+jefXSg09a4zNhSqLDLN/Uz2HiQqcz/qvQ+Jpt6Upg+JpvayfUg0taHuQyKZWqJ9/1dxUgvXfArbbkE+PT+G2sVDkdYtuLuxlF+OvpOfOzHQJD93EqBJfm6H/0bybt9CPHsXD8jP7dw1yc9tyBXJz/3QeVXyc9tnTfJzu2JN8nObXU3yAnkl8nhYLfJ4WC3yeFgt8nhYLfJ4WCXycz/zXZU8HlaLPB5WizweVou8QF6JPB5WizweVos8HlaLPB5Wizwe9k3k4z7JnLL/Tj7gYbXI42G1yONh30T+Rm0jX7I7II+H1SIvkFcij4fVIo+H1SKPh9Uij4fVIo+HVSIveFgt8nhYLfJ4WC3yeFgt8gL5t5Avi1++ji5LWA/I42G1yONhtcjjYbXI42G1yONhlciveFgt8nhYLfJ4WC3yeNh3kU9lI/8ntG/kBfJK5PGwWuTxsFrk8bBa5PGwWuTxsErkIx5WizweVos8HlaLPB72p+TD4xm9wedYIe/SYyQpyvOw7+AF8DrgcbBK4DGwSuDxr0rgsa9K4HGvOuAT5lUJPN71TeBL2Y72y1IZdlyWbckwLu5AJXyuAZXWspviY5XwxO9SaX/GrF+CPx+27LTFP/38XMrh1bG4x+Wx+Meww5K+RBVEHU9UvPyAopITDCgqGcSAopJvDCgq2cl4omZymQFFJfMZUFQiogFFJVEaUFRB1PFEJVEaUFQSpQFFJVEaUFQSpQFFJVEaT9RCojSgqCRKA4pKojSgqCRKA4oqiDqeqCRKA4pKojSgqCRKA4pKojSgqCRKo4kqy0KiNKCoJEoDikqiNKCoJEoDiiqIOp6oJEoDikqiNKCoJEoDikqiNKCoJErjiepIlAYUlURpQFFJlAYUlURpQFEFUccTlURpQFFJlAYUlURpQFFJlAYUlURpPFE9idKAopIoDSgqidKAopIoDSiqIOp4opIoDSgqidKAopIoDSgqidKAopIojSdqIFEaUFQSpQFFJVEaUFQSJQuihu2xiZLyL6LeRRJEsi8Sic97RPJun6R3TyO5P67yBp5URgk8yYkSeNINJfAkEO8CH8IOvpSGLXAoeZuiOPdogLfbtpA/DCcp6cNwkpI9DCcpycNwkgqSjiYpqcZwkpKXDCcpSYwFSc8DYiG1sS/SOnUcEPKOXfz6y9F3OlM76yqdqU1qlc7Ufk/Cg06KlaNd2m73t1XJ/Vhf/MGxeeeRQ6kcW3aJSvn12LtCgkLGFZrajXWh0NTmyoZCcTvWLYs/kGhqs9SHRFNbpT4kmnopvAuJ4tRetg+JpjbUfUg0tas/kehOB1d/Rkegc0Jnbjebt1mGLK528fN5v0qFIE9HHyK5BXA7eYm/HH0nP7dL1SQ/t/nUJD+3p3wj+XX/kVlY83JAfm6rqEg+ze0ANcnPbew0yc/t1zTJz+0FNckL5JXI42G1yONhtcjjYbXI42G1yONhlchnPKwWeTysFnk8rBZ5PKwWeYG8Enk8rBZ5PKwWeTysFnk8rBZ5PKwS+YKHfRP5Evaf0S8lH5DHw2qRx8NqkcfDvoe8+Ad5v/oD8gJ5JfJ4WC3yeFgt8nhYLfJ4WC3yeFgd8m7Bw2qRx8NqkcfDvot8Khv58Hfkf+/ou0443j50EnTqQifctAWdnOybZrrVPY27HM0yLtsGCdE/SVPkS1N8+niakgCMpynZwniakloMp6kjDxlPU3xkh5rKdnBc3YGm9L0dahr9pmnMB5rS95rQdHU7kvX5tcv6pRO9bB860Z92oZOn5/znLnRixc6ETrJP8qbTWuk5blN7DKX4kh5QvlRlNXBEVfF8I6oqqDqgqqxLjqgqCc2PVQ0P8nEJNZ1Ojr6TJ0fRIk8yokWerOM95L1ftkeregkH3yoKpBda5MkjtMiTGWiRx9drkRfIK5HHH2uRx8NqkcfDapHHw2qRx8MqkRc8rBZ5PKwWeTysFnk8rBZ5gbwSeTysFnk8rBZ5PKwWeTzsm8ivfjvar0d7DAge9k3kJZSdfFwqR+edXw4PfL74g2NL3qZYyq/H/qnoijceTVE892iK4uVHU5SMYDRFBUUHU5RMYzRFyUpGU5QMZjRFyXZGU5TMaDBFI5nRaIqSGY2mKJnRaIqSGXWnaNx/Q70s/kBSQdLRJCU1Gk5SYqPhJCU3Gk5SgqPRJE240jdJusa0S1rqOyeWJWwvvpanfYC/9gJK8/Q89/nO0xDc5zvY3bKEvZyLSOWlfYrbQHxK4fml73AGu++0hTNY9t8UTh4sRm8LZ7B7f1s4g4W7beEMlpO2hSPAeQ1nsD72N+GU7fEdPjv5DmewprctnLk75AqcmTvk4JfyGHb6DmfmDrkGp8zcIVfhzNwhV+HM3CGHxw9oj+HM3OfcgtLtpYP45TucmfucKpyZ+5wqnKn7nBqcqfucUPIOxy3nL72W/bEOaynfrt63azskf0YyLvt9MC7fjYlfpu6gLtbkMcmp263HAnmQp6fZXvt0z5xeXiV5XJMyNckUd5Ilf4cztwWowJnbAlTgzG0BKnDmtgAPOOvT97l2OFNbgAocN3VXX4MzdaNegzN17x38/i3J1aXKS8e8+UGX5Olrj1K+UMrMKFPeE5xUwl+zMW7q/vJ3SNZCCjd1M3qxJo9JTt25Pl46/N0i/cFLL2V/aReWgwvl1H1u9vuwc6m8tOxExP96xzkYxiOSc7c4fT867Nin7qDVsPupe3M97FN3/XrYp/YTetinDv71sAvYNbBP7Q9/C3vY7KGk/L0T91Pbw5Yg+f34F0jTPza+QUWnHnQKbBLYh05ssmBEpyAPnZ4evhNfHO2fjo7fVGX7vxFVZQvAEVUVVO1O1T++7r/b4eeF5y9N2QZwPE3ZB3A8TdkIcDxNSXLG05TUZzhNhYRoPE1Jk8bTlCxpPE1JksbTVNB0OE3JkcbTlBzJiqavcvmD185h/xWWexbn+LXLPstbATzNMrqvGiB3ogbIqcaqgbuqJFUDqrqSVVlX9a4TvvbHOvm8t7QhSIW8+P3HlRLWqk6SHu3y03fOXDn8CaxsB8enTX9ckS9NBU370zRt/GJeDzTF146nKb52PE3xqeNpiu/sUVO3axoPNMV1DqdpxHOOpynfj+hQ07hlDjHmA035fsR4mpIjjaepoOlwmpIjjacpOdJ4mpIjjacpOdJwmqap/WmQXdOQYuVoCYt/qPR09B9Pv/qrKp2viKapHacdlc5z9jS1h+xGJUGlDlSa2ud1o9LUzs2QSqdrEGlqL9aNSlO7q25Umnrd3Y5K5642T72S3o1KZA89qET20INKZA89qCSo1IFKZA89qET20INKU/ulJewqLaU2ECdRtmXA29/56dW9Ozjer3nbdeL25xOU2zv9yb5M7YKU2U/tbZTZT+1YlNlP7UOU2Qvs1dhP7Rneyz7tW3HdFu+XA/ZTOwFl9lOvLSqzn3rFUJk9vlaL/S3MgP272MeyDfz2ZzhgT5/zNvY5b4ffopv1gD19zrvY364pj1f35YA9fY4ee/ocPfb0Oe9jn/z+6vnXe+3vHf2nUo60vxelWBuwoVTM6/6zq/y0Y3P80gmf0YdOrDn0oZOgkw2dyg4lFp++6YTH70Mn8oA+dCI76EMncoY+dCKT6EInTyLRh07kEVZ0emwDU9bvOpFH9KETeUQfOgk6daETeUQfOpFH9KETeYSGTn+yD3iid7Gvfnct4HP02ONd9NjjR97G/pfvKssBe4G9Gnt8gx57vIAee/r797H3D/ah5sOCL9uvRm/Np/y9DwusN/ahE+uNXegkeGsjOoVYdp3yc/70O8feNcWzj6cpWcB4mpIx9KepuP1+Kt5911TQdDhNyUTG05SsRUPTO3uylvexj2lnn/IBe/KT97HP+5pSKge/CxcykY/U/RH7lZxDjz15hB57gf272Od1m+btzyP2+AY99vT3euzp7/XY09+/j734U/aRPud97Cv7/EXWR/TYs46hx15gr8aeHlOPPVnaz9mHsOzsb1Qq7F1Ka9iOv/39wPK1dpLI0vTY02PqsafHfCP7lB/sn54ivrGnx9RjL7BXY0+GrMee/l6PPRmyHnsyZD32+Fo19hlfq8ee/v7n7Je0j1ucpAr7+NjYZnVPSZp8kRfIv4v8fnTM6wF5enst8nT2WuTp67XI09W/j7zbyccD8vT0SuQLHb0Wedap3kY+bl9DizEfkGeVSos8HlaLvEBeiTweVos8HlaLPB5WizweVos8HlaHvCz08z8mH8K+lbwLsvoK+dur5H0Vy5Xl+emr348uLm0jL+7bbk6y0P33oZOgkw2dvNugFO+/64Sz6EMnfEgfOuFa+tAJj2NFp+B2nUL5phOOqAudHGuAfejEimEfOpFH9KETeUQfOgk6GdFp8Y++PH/TiTyiD53II/rQiTyiD53II/rQiTyiC508eUQfOpFH9KETeUQfOpFH9KET/unHOvni910NfSl/7ZfY4nFEbyN/+ttI8XgcLfK4FiXyAR+iRR5n8T7yZ79KlYBX0CJP969FXiD/LvLnv9wIrBhqkcfDapHHw2qRx8NqkcfDKpEXPKwWeTysFnmB/I/Jx8Xt5NPzwA/J317S7VDiWjnap/J4zv3f7YB7V4r+34hS2W/LYz6HfKAUfqEXpfAXvSiFH7Gi1E7cZ5cOlMK/dKLUit/pRSn8US9KsSbYi1KsIfailKBUJ0qRUfSiFBlFL0qRUfSiFBmFFaX2Hzzc/jxIk1Yyik6UimQUvShFRtGLUmQUVpTaR35TqhwoRUbRi1KCUp0oRUZhRSnJu1JrOFCKjKIXpcgoelGKjKIXpcgoOlEqkVH0ohQZRS9KkVH0ohR+yohScd+26fbapXa0hLAdLTlUjo7y+BXJY+UrpKNZlrwVjFuehnF8cPTrBjD6XHvpP3am2n/8krNbfjn+Xo6YRsrxc+UoD+Gfr46PcsQZU46GyhH7TzkaKkcyDspRpxyj/16OmSCHcvxgOcqjHNNae/Wy847l+duHRwdnv7929k+V7rZCJwej0P91hkInRqTQpyh0vilGoU9R6EKhU+gzFDrrahT6FIXOih2FPkWhsxZIoU9R6KwyUugfK/Tid4C3v+Mvx/9ZjoW0m3L83HW3PL6hVpaDb6gVoRwpx49dHd1D+BLcQTnSlVKOhq6O9I6Uo07vGI7KkW+oUY5mynFd+IYa5WioHHHWlKOhcuTbXpTj58oxPAL2InJQjnwni3I0VI5COVKOdsqR7zdRjobKkW8hUY6GypFVGcrRUDmyKkM5fq4cK2vW68KqDOVopxwdqzKUo6FyZFWGcjRUjqzKUI6GypFVGcrRUDkK5Ug52ilHVmUoR0PlyKoM5WioHMkdKcfr5ej2o2+VudTKMfmwv3i6TeF7OXpyR8rRUDmSO1KOnyvHGB7lmMpBOZI7Uo6GypHckXI0VI5COVKOdsqR3JFy/Fg5hmVXJ90K5aAcyR0pR0PlyLfBKUdD5ci3wSnHz5WjPJXjuh6UI6sylKOdcgysylCOhsqRVRnK0VA5sipDORoqR1ZlKEdD5SiUI+VopxxZlaEcP1eO4bkc40E5sipDORoqR1ZlKEdD5ciqDOX4uXLc5/jH3wff6AmsylCOdspRWJWhHA2VI6sylKOhcmRVhnI0VI6sylCOhspRKEfK0U45sipDOX6uHNNTOZaDp24JqzKUo6FyZFWGcjRUjqzKUI4fK0dx+4M8kviDPXqEVRnK0U45rqzKUI6GypFVGcrRUDmyKkM5GipHVmUoR0PlKJQj5WinHFmVoRw/V47LczkePLF1ZVWGcjRUjqzKUI6GypFVGcrxY+Xo82P3Wwlr7XgJbj9eDjfgW1nFoXztlm9YH+W7uurxed0HLznl7+UeWSWi3O2W+yqPco8HyUBkVYny7eNqfVi+rEJRvh2XL6tWlG/H5SuUL+Xbb/myKkb52i3fFB/lW3yDpIJVN8rdbrmXx9X6tkRyUL6s0lG+XVytj8uXVT3Kt+PyZVWP8u23fBOrdJRvx+XLKh3la7Z8xaVH+Ybw15OKxKoe5W633MPT1VoOnkySWNWjfPu4Wh+Wr1C+lG+/5cuqHuXbcfmySkf5dly+rNJRvibK916OrLpRjobKkVU0ytFOOWZWxSjHz5Xj+ihHnw+2I86sclGOhsqRVSjK0VA5sqpEORoqR6EcKUc75ciqD+VoqBxZxaEcDZUjqzKUo6FyZFWGcrRTjoXckXL8VDnGEveqiiWVg3Ikd6QcP3Z1XB7C3/6OB+VI7kg5GipHoRwpRzvlSO5IOX6udyzLUzkebL5eyB0pR0PlSO5IORoqR3JHytFQOfJtcMrRTDnGhW+DU46GypFVGcrRUDmyKkM5GipHVmUoR0PlSO5IOV4ux/VWHJs2Lkvl6CRxe+3bn+WgGEkdKUYzxUjmSDGaKUYSR4rxU8UY3aZ7ij59L0ZH3kgxmilG0kaK0UwxkjVSjGaKkaSRYjRTjOSMFOOninHNW5WktRyE3g43TTF+qhhT2QadcnDfi9HjpilGM8WIm6YYzRQjbppiNFOMuGmK0UwxCsVIMX6oGPPq9mKM4aAY+SU1xWimGMkZKUYzxcj3GSlGM8XI9xkpRjPFyAoMxWilGAMrMBSjmWJkBYZiNFOMrMBQjGaKkZyRYvxUMT5/n/FoBSaQM1KMZoqRnJFiNFOM5IwUo5liJGekGD9WjHH/1k5M+XsxilCMFOOHijHt/FJyclCMuGmK0Uwx4qYpRjPFiJumGD/WM5b0KMb1oBhx0xSjmWLETVOMVopxZW2aYvxYz7g/ivr250HPuPLrQIrxY8X49OtAFypHO8nrPhTJR7nkKhQvxfuh4s0u7sV7tGKzkktSjBpX0sNiJJekGM0UI7kkxWimGMklKUYzxUguSTFaKcbIrwkpRjPFSC7ZZTF62RB6n5Zfjr7rKujao67Bb6/tg4QDXUm/xtSVIGlMXclk+ry/5oeufzeSu67EG2PqSlIwpK4J0z2mruyGM6aufHlvTF3Jm8bUVdB1SF3Jm8bUFf/6c12X9aHrbcZV9kves3n/lM2X9MUej6nGPuMD9djj1d7HXvbFab+GX9gfjMWXTakQnn7hHL90wnv1oRNeyohOIZZdp5yedPqdY++aCpoOpykeajxNWa/vT1Nx+/1UvPuuKWv142lKzjGepuQnb9M0PL5XGtJS0XRNWwGs5Qng11eLC1FLFzKRynQhE6FMFzKRyXQhkyDTu2SSx9KjPL/6oUy3LmE7+nYnSs9CfT84e9l4Zx/9d1UJWkZUlahlRFUJW0ZUlbhlRFUJXMZTNS3kMyOqSpwzoqqCqu9SdfX7Msbq119UvbOnU30fe9m/1Lyu378ymBz3qPex3w/3a8wH7LmT6LEn7ddjT4Svcb2/cncQlOpEKZJ5G0rFvG4IY06PDeHil05k7X3ohCfpQyfycCM6lR1KLD5904mEuwudPHlAHzqRHfShEzlDHzqRSfShk6BTFzqRR1jRaV/4jGX9rhN5RB86kUf0oRN5RB86kUd0oVMgj+hDJ/IIDZ3u7AX2P2Xvbh3v9uKuLLWnTDlJGxS3uuef4B+NPD4+Iqt7Ola+dMITGdEp7dY1rwc64Yn60AlP1IdOeKI+dMITWdFp/2FDjt91EjxRHzrhifrQiTVaIzrFxzN984FOrNH2oZOgUxc6kUf0oRN5RB86kUf0oRN5RB86kUd0odM6s3/y5bHt8uKWmk4t15PWmf3QW7mf56SrwF2F+8x+RZP7zP5Dk/vMfuK93E/z4HVmf6DJfeZ+X5F7nHk98a3cz31TnHl9UJM7flWHO35Vh7vAXYU7flWHO35Vhzt+VYV7Ouae9ofFPy0H+OIP3iDvyHMolWNL3qiU8uux98FkS4MphgaTF0uDcZYG4y0NJlgajFgazGppMNHSYCxdgbOlK3D+7BU47nfVZfHfR1MWU6NxpkbjTY0mmBqNmBrN8dVGStlbytWf97Z52T61WZ5a7Nvf93fIb3+H8uZ3yC+evtPyHdzb38G//R3CX3+HdXNgOcVf3uHAJS1lszLeLY+j5fAzk7fnhhTnay98c5bbC8vyWEwN+0Rllomus0w0zjLR+vU+/TLR+1n50lnlylkuvPs65eTt77C+/R3i298hvf0d8tvfoUzysfbLLBN1s0zUzzLRcOUu4eXSWeuVs4732gm+bJYtBPfYeCl+nRSvnJSunHR4GQ3hsYYQ8vMeW//4G8fe36C8+Q2ONyFo+Qbur76BuF0D8e77G/h3v0F48xushxr424LQ9um9Lcd8O8ldOclfOenFVeJ3lr5uR3wdvD6vBX4tfeUXX8Vv+hbr+98ivv8tUtO3kOXgLfL736K8/S1efBmy6Vu4v/4WcdkuDNHHg7fw73+L8P63kPe/xfr+t4jvf4v0/rfI73+L8va3SMv73+L9n+70/k93ev+nO73/053e/+lO7/90p/d/unOLz8Xpr1VzblFRp1+Eyi++LbG6/Stia5Bf3uJ+2nrttHjttHTttBfX3/0LbbfT1go+V3zeaRdfvhmKF6v1bd/kxSJ84zdxn3gT/4k3Wd/+0SwtrmGnv2XMJb3/LfL736K8+y3Ksrz/Ldz738K//y1a3E9OfxhXFnn/W6zvf4v47htvWdL73yK//y3K29/CLe9/C/f+t/Dvf4vw/reQ97/FYdGu65aarvm503NfJ5ULJx0vJtZOOi6VJe2z+uPv8ncdSXmxzLWksrewy22x+9tp4dppcu209dppxxfLJYfwOO3pIRzbaenaafnaaeXSaeGFbuXxOJKlRPfttBckS94eS+Lcsnwj+eIpCtXT0rXTyqW5vdhKu3raiw9OKeFpkOu30/y108K10+Taaeu10+K109K1044/OLdDy+M0/1wl//j7NfVi/7m2b3K8htf6Tdxff5PztcjyYhO4pm8R3v8W8rtvcT9tvXZavHbatUvki/W56mnl0mlxuXaau3aav3ZauHaaXDvt2o00XruRvljqSOt+YU3p+WeqR+2tT8v+DaPk/be3cO9/C//+twjvfwt5/1us73+L+P63SO9/i/z+tyhvf4v8/k93fv+nO7//053f/+nO7/905/d/uvP7P935/Z/u/P5Pd37/p7v89qf7fpq7dpq/dlq4dppcO229dlq8dlq6dlq+dlq5cNq6LMu109y10/y108K10+Taaeu10+K109K10/K1065VibtWJe5albhrVeKuVYm7ViXuWpW4a1XirlWJu1Yl7lqV+GtV4q9Vib9WJf5alfhrVeKvVYm/ViX+WpX4a1Xir1VJuFYl4VqVhGtVEq5VSbhWJeFalYRrVRKuVUm4ViXhWpXItSqRa1Ui16pErlWJXKsSuVYlcq1K5FqVyLUqkWtVsl6rkvValazXqmS9ViXrtSpZr1XJeq1K1mtVsl6rkvValcRrVRKvVUm8ViXxWpXEa1USr1VJvFYl8VqVxGtVEq9VSbpWJelalaRrVZKuVUm6ViXpWpWka1WSrlVJulYl6VqV5GtVkq9VSb5WJflaleRrVZKvVUm+ViX5WpXka1WSr1VJuVYl5VqVlGtVUq5VSblWJeValZRrVVKuVUm5ViXXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17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",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "get_l1_token",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "aztec_token",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "7f3druu8kqUJ30se54FIBv/6VhofCvWTXUggkVnIqvqARiHvvb1eT8lee8rSXNq0I0g+Jxvz3UuyyWeEpRiDNvV//uG//dN/+d///T/987/+P//2P//h//q//88//Mu//df//L/++d/+9fZf/+c//vEf/su///O//Ms///f/9Px//8Py63+cX/464X/+j//8r7/++3/+r//87//rH/4vt4gL//gP//Sv/+2vv7O/vcj/88//8k+//qv+xz9+Oz6X9HV0WWQ7NqedQ6OPX4fGuDxeNrr/+P/94204rsVwSsjrcGI9Ho6E+nWopPJ9OL7JcIqsw6nleDhpWekkn74PJ7QYTvX+6+ga4slwyvJ1aF52xJLd4YSyrPhdqCmdDMfXxX0dHpbno93Xu8SPvEv6yLvkj7xL+ci71E+8S1g+8i7uI+/iP/Iu4SPv8pHPfvjIZz985LMfPvLZDx/57IePfPblI599+chnXz7y2ZePfPblI599+chnXz7y2ZePfPblI599+chnP37ksx8/8tmPH/nsx4989uNHPvvxI5/9+JHPfvzIZz9+5LMfP/LZTx/57KePfPbTRz776SOf/fSRz376yGc/feSznz7y2U8f+eynj3z280c++/kjn/38kc9+/shnP3/ks58/8tnPH/ns54989vNHPvv5I5/98pHPfvnIZ7985LNfPvLZLx/57JePfPZLk89+WGLa3qXmp3eR+7vkj7xL+ci71E+8S10+8i7uI+/S5LMfbmt567t4X397l+9H38zsOqabs3laAnRlb9WzrAuGMTyNI90/IzUojL9sK5+3K3Q5GX9MeVtFTiVsR6d4n4D0PoHY+wRS7xPIvU+g9D6B2vcE/LL0PgHX+wR87xPo/E7sF/t34ixr4xRzlOcJ7LiLuH3Tysfsjg8ucR1GyU8zlF3b4ravrPlfX69ajxa/d3B5WJzfDv2LuP3WYTTi9nud0Yjbb85GI26/mxyNuP32dzDizn6/Phpx+wZjNOL2HdFoxO1buNGIC8Q/TBzP+WnieM5PE8dzfpo4nvPTxPGcHybu8ZyfJo7n/DRxPOenieM5P01cIP5h4njOTxPHc36aOJ7z08TxnJ8mjuf8MPGA5/w0cTznp4n34Dndg3g5hujK9osTV304eekb3HVTOxeftoP7+k5m6MEdarER2Lxk04Pj0mLTgzfSYtODi9Fi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xd732Iq977EVe99jK/a+x1bsfY+t2PseW7H3PbZi73tsxd732Iq977EVe99jK/a+x1bsfY+t2PseW7H3PbZi73tsxd732Iq977EVe99jK/a+x1bsfY+t2PseW7H3PbZi73tsxd732Iq977EVe99jK/a+x1bsfY+t2PseW7H3PbZi73tsxd732Iq977EVe99jK/a+x1bsfY+t2PseW7H3PbZi73tsxd732Iq977EVe99jK/a+x1bsfY+t2PseW7H3PbZi73tsxd732Iq977EVe99jK/a+x1bsfY+t2PseW7H3PbZi73tsxd732Iq977EVe99jK/a+x1bsfY+t2PseW7H3PbZi73tsxd732Iq977EVe99jK/a+x1bsfY+t2PseW7H3PbZi73tsxd732Iq977EVe99jK/a+x1bsfY+t2PseW7H3PbZi73tsxd732Iq977EVe99jK/a+x1bsfY+t2PseW7H3PbZi73tspd732Erm99h6vHTK1f02gb2j12Gnkh7HVvmarPW7dtPJWr/DN52szDRZ651D08la7zKaTtZ4R3JrWstjsv5kspLrOhApoWxHhyXvjtvlbdhBHkdL+YJjvNvRhWO8k1KFY33/tRzFfx2dbxe8EzghrAcHeRq136Oe4jrmmJeng2XvaF/r9srLUn47+s7ReLPYDUfjfWg3HI23uN1wFDg24Wi8Me+Go/GevxuOxu1ENxyNO49uOBo3Kb1wtL6LZTcc8TNtOOJn2nDEz7ThKHBswhE/04YjfqYNR/xMG474mTYc8TNNOFrfC7gbjviZNhzxM2044mfacBQ4NuGIn2nDET/ThiN+pg1H/EwbjviZJhyt76jeDUf8TBuO+Jk2HPEzbTgKHJtwxM+04YifacMRP9OGI36mDUf8TBOO1p9L0Q1H/EwbjviZNhzxM204ChybcMTPtOGIn2nDET/ThiN+pg1H/EwTjtaf7tMNR/xMG474mTYc8TNtOAocm3DEz7ThiJ9pwxE/04YjfqYNR/xME47Wn5HWDUf8TBuO+Jk2HPEzbTgKHJtwxM+04YifacMRP9OGI36mDUf8TBOO1p802Q1H/EwbjviZNhzxM204ChybcMTPtOGIn2nDET/ThiN+pg1H/EwTjtaf19sNR/xMG474mTYc8TNtOAocm3DEz7ThiJ9pwxE/04YjfqYNR/xMC47Z+lPPu+GI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",
      "brillig_names": [
        "get_l1_token"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "939615093317106671": {
            "error_kind": "string",
            "string": "Invalid response from registry"
          },
          "1149705418984161792": {
            "error_kind": "string",
            "string": "Invalid nonce"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7069518359247663558": {
            "error_kind": "string",
            "string": "Function _claim_public can only be called internally"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8459146718181593566": {
            "error_kind": "string",
            "string": "L1 portal address cannot be zero"
          },
          "8606784891595333955": {
            "error_kind": "string",
            "string": "Token contract class cannot be zero"
          },
          "11430482739715627628": {
            "error_kind": "string",
            "string": "Function _log_claim can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14788743618517749904": {
            "error_kind": "string",
            "string": "Function _register_public can only be called internally"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "is_registered_l1",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "eth_token",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "is_registered_l1"
      ]
    },
    {
      "name": "_claim_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "eth_token",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "message_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7069518359247663558": {
            "error_kind": "string",
            "string": "Function _claim_public can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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CqcuAIADgAUBAIAFAAKADi4CgAuADiMAAArsKACADwQAAwEAgAmAD4AOLgAAAYAFAQAAAYAOAAEoAYAFBAABAQCABQACgA4uAoALgA4BAIAOAAKADi4CgAmADiMAAArsIwAAC0UoAIAPBAACBQCAC4APgA4oAIAQBAADAQCADoAQgA8uAAABgAUBAAABgA8AASgBgAUEAAEBAIAFAAKADy4CgAuADwEAgA8AAoAPLgKADoAPIwAAC0UoAIANBAADAQCABYANgAwLAIADgAWADSQAgA0AAAupAQCACoAIgA8uAIAKgBAuAIAMgBELAIAQgA+AEiQAgBIAAAupLgGAEIAOLgKADoARAQCAEAACgBABAIARAAKAESMAAAt4AQCADIAIgAYmLgGAA4AHAQCAAwACgAsuAYALgAgBAIALAAKACy4BgAuACQEAgAsAAoAKAQCACIAEgAsPAIALgAmADAsAgAcAAoANJACADAAADAEjAAAMcSQAgA0AAAwOIwAADCcuAIADgAUBAIAFAAKADi4CgAuADiMAAAxsKACADwQAAwEAgAmAD4AOLgAAAYAFAQAAAYAOAAEoAYAFBAABAQCABQACgA4uAoALgA4BAIAOAAKADi4CgAmADiMAAAxsIwAADMUoAIAPBAACBQCAC4APgA4oAIAQBAADAQCADoAQgA8uAAABgAUBAAABgA8AASgBgAUEAAEBAIAFAAKADy4CgAuADwEAgA8AAoAPLgKADoAPIwAADMUoAIANBAADAQCABYANgAwBAIAMgASADQMAgAgAAoAOAQCADYAOgA8BAIAKgA6AEA0AgBCACoAOJACADgAADSUuAYAQgBEuAoARgA8DAIAQAAKAEAMAgA8AAoAPIwAADPQuAIAMgAYmKgEAAQXFa8RaDhAAAjwBAQImLgGAA4AGCwCABgACgAckAIAHAAANWSMAAA1kLgCAA4AFIwAADcsuAAABgAUBAAABgAQAAQEAgAOABIAJLgCAA4AKLgCABYALCwCACoAJgAwkAIAMAAANty4BgAqACC4CgAiACwEAgAoAAoAKAQCACwACgAsjAAANhigBgAUEAAEDAIAGAAKABiMAAA3LJioBAAEFRafKcRlB5BU8AQECJg==",
      "debug_symbols": "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",
      "brillig_names": [
        "_claim_public"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Beacon"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "target",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "overrides",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "minter",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "shield_gateway_beacon",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "shielded_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000009"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000b"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000d"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Portal"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "l1_portal",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "l1_tokens",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "l2_tokens",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "token_contract_class_id",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "shield_gateway_beacon",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "events": [
        {
          "fields": [
            {
              "name": "token",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
              }
            },
            {
              "name": "from",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "to",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
              }
            },
            {
              "name": "amount",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::Withdraw"
        },
        {
          "fields": [
            {
              "name": "eth_token",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
              }
            },
            {
              "name": "aztec_token",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::Register"
        },
        {
          "fields": [
            {
              "name": "eth_token",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
              }
            },
            {
              "name": "recipient",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "amount",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            },
            {
              "name": "message_leaf_index",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::Deposit"
        }
      ],
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "eth_token",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "message_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::claim_shielded_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::claim_shielded_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "eth_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "message_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::_log_claim_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::_log_claim_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "eth_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "withdrawNonce",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "burnNonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::withdraw_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::withdraw_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "eth_token",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "aztec_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "name",
                    "type": {
                      "kind": "string",
                      "length": 31
                    }
                  },
                  {
                    "name": "name_len",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "symbol",
                    "type": {
                      "kind": "string",
                      "length": 31
                    }
                  },
                  {
                    "name": "symbol_len",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "decimals",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "message_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::register_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::register_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "eth_token",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "message_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::claim_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::claim_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "l1_portal",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "token_contract_class",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "shield_gateway_beacon",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "aztec_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "eth_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::_register_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::_register_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "eth_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "message_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::_claim_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::_claim_public_abi"
        }
      ]
    }
  },
  "file_map": {
    "101": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    macros::{\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_notes` utility function PXE requires in order to discover notes.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_notes = generate_sync_notes();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_notes\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_notes() -> Quoted {\n    // TODO(https://github.com/noir-lang/noir/issues/7912): Doing the following unfortunately doesn't work. Once\n    // the issue is fixed uncomment the following and remove the workaround from TS (look for the issue link in the\n    // codebase).\n    // let utility: fn(FunctionDefinition) -> () = crate::macros::functions::utility;\n    // quote {\n    //     #[$utility]\n    //     unconstrained fn sync_notes() {\n    //     }\n    // }\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[aztec::macros::functions::utility]\n        unconstrained fn sync_notes() { }\n    }\n}\n"
    },
    "102": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "103": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/events.nr",
      "source": "use super::utils::{compute_event_selector, get_trait_impl_method};\nuse protocol_types::meta::generate_serialize_to_fields;\n\ncomptime fn generate_event_interface(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n    let typ = s.as_type();\n    let (serialization_fields, _) = generate_serialize_to_fields(quote { self }, typ, false);\n    let content_len = serialization_fields.len();\n\n    let event_type_id = compute_event_selector(s);\n\n    let from_field = get_trait_impl_method(\n        quote { crate::protocol_types::abis::event_selector::EventSelector }.as_type(),\n        quote { crate::protocol_types::traits::FromField },\n        quote { from_field },\n    );\n\n    quote {\n        impl aztec::event::event_interface::EventInterface<$content_len> for $name {\n            fn get_event_type_id() -> aztec::protocol_types::abis::event_selector::EventSelector {\n                $from_field($event_type_id)\n            }\n\n            fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n                _emit(self);\n            }\n        }\n    }\n}\n\npub comptime fn event(s: TypeDefinition) -> Quoted {\n    let event_interface = generate_event_interface(s);\n    s.add_attribute(\"abi(events)\");\n    quote {\n        $event_interface\n    }\n}\n"
    },
    "105": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_slice, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_view,\n};\nuse std::meta::{type_of, unquote};\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_SLICE_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n    let is_void = f.return_type() == type_of(());\n\n    if is_fn_private(f) {\n        if is_static_call {\n            if is_void {\n                create_private_static_void_stub(f)\n            } else {\n                create_private_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_private_void_stub(f)\n            } else {\n                create_private_stub(f)\n            }\n        }\n    } else {\n        if is_static_call {\n            if is_void {\n                create_public_static_void_stub(f)\n            } else {\n                create_public_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_public_void_stub(f)\n            } else {\n                create_public_stub(f)\n            }\n        }\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args =  &[];\n    // serialized_args = serialized_args.append(aztec::protocol_types::traits::Serialize::serialize(target_address));\n    // serialized_args = serialized_args.push_back(fee_juice_limit_per_tx as Field);\n    // ```\n    let serialized_args_slice_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_SLICE_NAME = &[];\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append = add_to_field_slice(SERIALIZED_ARGS_SLICE_NAME, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n"
    },
    "106": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "109": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "111": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "112": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\nuse super::utils::is_note;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract. Only a single struct in the entire contract\n/// should have this macro (or `storage_no_init`) applied to it.\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot }, false);\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n/// Only a single struct in the entire contract should have this macro (or `storage`) applied to it.\npub comptime fn storage_no_init(_s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(\n    typ: Type,\n    slot: Quoted,\n    parent_is_map: bool,\n) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot }, true);\n        (quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }, 1)\n    } else {\n        let storage_size = if parent_is_map {\n            // Variables inside a map do not require contiguous slots since the map slot derivation is assumed to result\n            // in slots very far away from one another.\n            1\n        } else {\n            let (_, container_struct_generics) = typ.as_data_type().unwrap();\n            let stored_struct = container_struct_generics[0];\n\n            if is_note(stored_struct) {\n                // Private notes always occupy a single slot, since the slot is only used as a state variable\n                // identifier.\n                1\n            } else {\n                get_storage_size(typ)\n            }\n        };\n\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        (quote { $struct_name::new(context, $slot)}, storage_size)\n    }\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "113": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/utils.nr",
      "source": "use std::meta::unquote;\n\npub(crate) comptime fn get_fn_visibility(f: FunctionDefinition) -> Quoted {\n    if f.has_named_attribute(\"private\") {\n        quote { private }\n    } else if f.has_named_attribute(\"public\") {\n        quote { public }\n    } else {\n        panic(f\"Function is neither private nor public\")\n    }\n}\n\npub(crate) comptime fn is_fn_private(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"private\")\n}\n\npub(crate) comptime fn is_fn_public(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"public\")\n}\n\npub(crate) comptime fn is_fn_utility(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"utility\")\n}\n\npub(crate) comptime fn is_fn_contract_library_method(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"contract_library_method\")\n}\n\npub(crate) comptime fn is_fn_test(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"test\")\n}\n\npub(crate) comptime fn is_fn_view(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"view\")\n}\n\npub(crate) comptime fn is_fn_internal(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"internal\")\n}\n\npub(crate) comptime fn is_fn_initializer(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"initializer\")\n}\n\npub(crate) comptime fn fn_has_noinitcheck(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"noinitcheck\")\n}\n\n/// Takes a function body as a collection of expressions, and alters it by prepending and appending quoted values.\npub(crate) comptime fn modify_fn_body(body: [Expr], prepend: Quoted, append: Quoted) -> Expr {\n    // We need to quote the body before we can alter its contents, so we fold it by quoting each expression.\n    let mut body_quote = body.fold(quote {}, |full_quote: Quoted, expr: Expr| {\n        let expr_quote = expr.quoted();\n        quote {\n                $full_quote\n                $expr_quote\n            }\n    });\n    body_quote = quote {\n        {\n            $prepend\n            $body_quote\n            $append\n        }\n    };\n    let body_expr = body_quote.as_expr();\n    body_expr.expect(f\"Body is not an expression: {body_quote}\")\n}\n\npub(crate) comptime fn add_to_field_slice(slice_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $slice_name = $slice_name.push_back($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        // We invoke serialize as a static trait function rather than calling $name.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote { $slice_name = $slice_name.append(aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        // We invoke serialize as a static trait function rather than calling x.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote {\n            let $serialized_name = $name.map(|x: $element_type | aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $slice_name = $slice_name.append($serialized_name[i].as_slice());\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $slice_name = $slice_name.append($name.as_bytes().map(| byte: u8 | byte as Field).as_slice());\n        }\n    } else {\n        panic(\n            f\"Cannot add to slice: unsupported type {typ} variable {name}\",\n        )\n    }\n}\n\n/// Adds a value to a hash::ArgsHasher. Structs and values inside arrays are required to implement the Serialize trait.\npub(crate) comptime fn add_to_hasher(hasher_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $hasher_name.add($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        quote { $hasher_name.add_multiple(dep::aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        quote {\n           let $serialized_name = $name.map(|x: $element_type | dep::aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $hasher_name.add_multiple($serialized_name[i]);\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $hasher_name.add_multiple($name.as_bytes().map(| byte: u8 | byte as Field));\n        }\n    } else {\n        panic(\n            f\"Cannot add to hasher: unsupported type {typ} of variable {name}\",\n        )\n    }\n}\n\ncomptime fn signature_of_type(typ: Type) -> Quoted {\n    if typ.is_field() {\n        quote {Field}\n    } else if typ.as_integer().is_some() {\n        let (is_signed, bit_size) = typ.as_integer().unwrap();\n        if is_signed {\n            f\"i{bit_size}\".quoted_contents()\n        } else {\n            f\"u{bit_size}\".quoted_contents()\n        }\n    } else if typ.is_bool() {\n        quote {bool}\n    } else if typ.as_str().is_some() {\n        let str_len_typ = typ.as_str().unwrap();\n        let str_len = str_len_typ.as_constant().unwrap();\n        f\"str<{str_len}>\".quoted_contents()\n    } else if typ.as_array().is_some() {\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let element_typ_quote = signature_of_type(element_type);\n        f\"[{element_typ_quote};{array_len}]\".quoted_contents()\n    } else if typ.as_data_type().is_some() {\n        let (s, generics) = typ.as_data_type().unwrap();\n        let field_signatures = s\n            .fields(generics)\n            .map(|(_, typ): (Quoted, Type)| signature_of_type(typ))\n            .join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else if typ.as_tuple().is_some() {\n        // Note that tuples are handled the same way as structs\n        let types = typ.as_tuple().unwrap();\n        let field_signatures = types.map(|typ: Type| signature_of_type(typ)).join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else {\n        panic(f\"Unsupported type {typ}\")\n    }\n}\n\npub(crate) trait AsStrQuote {\n    fn as_str_quote(self) -> (Self, u32);\n}\n\nimpl<let N: u32, Env> AsStrQuote for Quoted {\n    // Used to convert an arbitrary quoted type into a quoted string, removing whitespace between tokens\n    comptime fn as_str_quote(self) -> (Quoted, u32) {\n        let tokens = self.tokens();\n        let mut acc: [u8] = &[];\n        let mut total_len: u32 = 0;\n        for token in tokens {\n            let token_as_fmt_str = f\"{token}\";\n            let token_as_str = unquote!(quote {$token_as_fmt_str});\n            let token_len = unquote!(quote { $token_as_str.as_bytes().len() });\n            let token_as_bytes = unquote!(quote { $token_as_str.as_bytes().as_slice() });\n            total_len += token_len;\n            acc = acc.append(token_as_bytes);\n        }\n        let result = unquote!(\n            quote {\n                let signature_as_array: [u8; $total_len] = $acc.as_array();\n                signature_as_array.as_str_unchecked()\n            },\n        );\n        (quote { $result }, total_len)\n    }\n}\n\npub(crate) comptime fn compute_fn_selector(f: FunctionDefinition) -> Field {\n    // The function selector is computed from the function signature, which is made up of the function name and types of\n    // parameters, but not including the return type. For example, given:\n    //\n    // fn foo(a: Field, b: AztecAddress) -> Field\n    //\n    // The signature will be \"foo(Field,AztecAddress)\".\n    let fn_name = f.name();\n    let args_signatures =\n        f.parameters().map(|(_, typ): (Quoted, Type)| signature_of_type(typ)).join(quote {,});\n    let signature_quote = quote { $fn_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::function_selector::FunctionSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\npub(crate) comptime fn compute_event_selector(s: TypeDefinition) -> Field {\n    // The event selector is computed from the type signature of the struct in the event, similar to how one might type\n    // the constructor function. For example, given:\n    //\n    // struct Foo {\n    //   a: Field,\n    //   b: AztecAddress,\n    // }\n    //\n    // The signature will be \"Foo(Field,AztecAddress)\".\n    let event_name = s.name();\n    let args_signatures = s\n        .fields_as_written()\n        .map(|(_, typ): (Quoted, Type)| {\n            // signature_of_type can handle structs, so this supports nested structs\n            // FIXME: Field generics are not handled here!\n            signature_of_type(typ)\n        })\n        .join(quote {,});\n    let signature_quote = quote { $event_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::event_selector::EventSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\n/// Returns how many storage slots a type needs to reserve for itself. State variables must implement the Storage trait\n/// for slots to be allocated for them.\npub(crate) comptime fn get_storage_size(typ: Type) -> u32 {\n    // We create a type variable for the storage size. We can't simply read the value used in the implementation because\n    // it may not be a constant (e.g. N + 1). We then bind it to the implementation of the Storage trait.\n    let storage_size = std::meta::typ::fresh_type_variable();\n    assert(\n        typ.implements(quote { crate::state_vars::Storage<$storage_size> }.as_trait_constraint()),\n        f\"Attempted to fetch storage size, but {typ} does not implement the Storage trait\",\n    );\n\n    storage_size.as_constant().unwrap()\n}\n\npub(crate) comptime fn module_has_storage(m: Module) -> bool {\n    m.structs().any(|s: TypeDefinition| {\n        s.has_named_attribute(\"storage\") | s.has_named_attribute(\"storage_no_init\")\n    })\n}\n\npub(crate) comptime fn module_has_initializer(m: Module) -> bool {\n    m.functions().any(|f: FunctionDefinition| is_fn_initializer(f))\n}\n\npub(crate) comptime fn is_note(typ: Type) -> bool {\n    typ.as_data_type().map_or(false, |struc: (TypeDefinition, [Type])| {\n        let (def, _) = struc;\n        def.has_named_attribute(\"note\")\n            | def.has_named_attribute(\"partial_note\")\n            | def.has_named_attribute(\"custom_note\")\n    })\n}\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `noir-protocol-circuits/crates/types/src/meta/mod.nr`. We maintain separate\n/// copies because importing it here from there would cause the `target_trait` to be interpreted in the context\n/// of the protocol circuits types crate, making it impossible to compile code for traits from this crate\n/// (e.g. NoteType).\npub(crate) comptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Type does not implement trait\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n"
    },
    "114": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod pending_tagged_log;\npub mod private_logs;\npub mod private_notes;\n\nuse private_notes::MAX_NOTE_PACKED_LEN;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "115": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash =\n            compute_unique_note_hash(nonce, compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash));\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.nonce, note_and_data.nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == first_note_and_data.nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == second_note_and_data.nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "116": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle::message_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    pending_partial_notes.for_each(|i, pending_partial_note: DeliveredPendingPartialNote| {\n        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public logs have an extra field at the beginning with the contract address, which we use to verify\n            // that we're getting the logs from the expected contract.\n            // TODO(#10273): improve how contract log siloing is handled\n            assert_eq(\n                log.log_content.get(0),\n                contract_address.to_field(),\n                \"Got a public log emitted by a different contract\",\n            );\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log sans the extra\n            // fields) to get the complete packed content.\n            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                packed_public_note_content,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                // temporary node connectivity issue - is simply throwing good enough here?\n                assert(\n                    deliver_note(\n                        contract_address,\n                        pending_partial_note.storage_slot,\n                        discovered_note.nonce,\n                        complete_packed_note,\n                        discovered_note.note_hash,\n                        discovered_note.inner_nullifier,\n                        log.tx_hash,\n                        pending_partial_note.recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n            // being completed.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "118": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/private_logs.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{\n            ComputeNoteHashAndNullifier,\n            partial_notes::process_partial_note_private_msg,\n            pending_tagged_log::{PENDING_TAGGED_LOG_ARRAY_BASE_SLOT, PendingTaggedLog},\n            private_notes::process_private_note_msg,\n        },\n        encoding::decode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        msg_type::{\n            PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n        },\n    },\n    oracle::{logs::store_private_event_log, message_discovery::sync_notes},\n    utils::array,\n};\n\nuse protocol_types::{\n    abis::event_selector::EventSelector,\n    address::AztecAddress,\n    debug_log::{debug_log, debug_log_format},\n    traits::FromField,\n};\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `syncNotes` oracle.\n    // This makes PXE synchronize tags, download logs and store the pending tagged logs in capsule array which are then\n    // retrieved and processed here.\n    sync_notes(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    // Get the logs from the capsule array and process them one by one\n    let logs =\n        CapsuleArray::<PendingTaggedLog>::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n    logs.for_each(|i, log: PendingTaggedLog| {\n        process_log(contract_address, compute_note_hash_and_nullifier, log);\n        logs.remove(i);\n    });\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.\n///\n/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the\n/// transaction hash in which the notes would've been created (typically the same transaction in which the log was\n/// emitted), along with the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier`\n/// function.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\nunconstrained fn process_log<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    pending_tagged_log: PendingTaggedLog,\n) {\n    debug_log_format(\n        \"Processing log with tag {0}\",\n        [pending_tagged_log.log.get(0)],\n    );\n\n    // The tag is ignored for now.\n    let ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n    let log_plaintext = AES128::decrypt_log(ciphertext, pending_tagged_log.recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // have 3 log types: private note logs, partial note logs and event logs.\n\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(log_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.unique_note_hashes_in_tx,\n            pending_tagged_log.first_nullifier_in_tx,\n            pending_tagged_log.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            pending_tagged_log.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        // In the case of events, the msg metadata is the event selector.\n        let event_selector = EventSelector::from_field(msg_metadata as Field);\n\n        store_private_event_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            event_selector,\n            msg_content,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.log_index_in_tx,\n            pending_tagged_log.tx_index_in_block,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "119": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle,\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n        // issue, and we should perhaps not have marked the tag index as taken.\n        assert(\n            oracle::message_discovery::deliver_note(\n                contract_address,\n                storage_slot,\n                discovered_note.nonce,\n                packed_note,\n                discovered_note.note_hash,\n                discovered_note.inner_nullifier,\n                tx_hash,\n                recipient,\n            ),\n            \"Failed to deliver note\",\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "120": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\nglobal MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "121": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_CIPHERTEXT_LEN,\n            PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) as bool;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
    },
    "132": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messaging.nr",
      "source": "use crate::{\n    hash::{compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash},\n    oracle::get_l1_to_l2_membership_witness::get_l1_to_l2_membership_witness,\n};\n\nuse dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    merkle_tree::root::root_from_sibling_path,\n};\n\npub fn process_l1_to_l2_message(\n    l1_to_l2_root: Field,\n    contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    chain_id: Field,\n    version: Field,\n    content: Field,\n    secret: Field,\n    leaf_index: Field,\n) -> Field {\n    let secret_hash = compute_secret_hash(secret);\n    let message_hash = compute_l1_to_l2_message_hash(\n        portal_contract_address,\n        chain_id,\n        contract_address,\n        version,\n        content,\n        secret_hash,\n        leaf_index,\n    );\n\n    // We prove that `message_hash` is in the tree by showing the derivation of the tree root, using a merkle path we\n    // get from an oracle.\n    // Safety: The witness is only used as a \"magical value\" that makes the merkle proof below pass. Hence it's safe.\n    let (_leaf_index, sibling_path) =\n        unsafe { get_l1_to_l2_membership_witness(contract_address, message_hash, secret) };\n\n    let root = root_from_sibling_path(message_hash, leaf_index, sibling_path);\n    assert_eq(root, l1_to_l2_root, \"Message not in state\");\n\n    compute_l1_to_l2_message_nullifier(message_hash, secret)\n}\n"
    },
    "142": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
    },
    "145": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "148": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "149": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "150": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "151": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "152": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "153": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "154": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/get_l1_to_l2_membership_witness.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, constants::L1_TO_L2_MSG_TREE_HEIGHT};\n\n/// Returns the leaf index and sibling path of an entry in the L1 to L2 messaging tree, which can then be used to prove\n/// its existence.\npub unconstrained fn get_l1_to_l2_membership_witness(\n    contract_address: AztecAddress,\n    message_hash: Field,\n    secret: Field,\n) -> (Field, [Field; L1_TO_L2_MSG_TREE_HEIGHT]) {\n    get_l1_to_l2_membership_witness_oracle(contract_address, message_hash, secret)\n}\n\n// Obtains membership witness (index and sibling path) for a message in the L1 to L2 message tree.\n#[oracle(getL1ToL2MembershipWitness)]\nunconstrained fn get_l1_to_l2_membership_witness_oracle(\n    _contract_address: AztecAddress,\n    _message_hash: Field,\n    _secret: Field,\n) -> (Field, [Field; L1_TO_L2_MSG_TREE_HEIGHT]) {}\n"
    },
    "157": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n"
    },
    "158": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "159": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: x_coordinates_match,\n        };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
    },
    "160": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
      "source": "use crate::messages::encoding::MAX_MESSAGE_CONTENT_LEN;\nuse protocol_types::{abis::event_selector::EventSelector, address::AztecAddress};\n\n/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\npub unconstrained fn notify_created_contract_class_log<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {\n    notify_created_contract_class_log_private_oracle(contract_address, message, counter)\n}\n\n#[oracle(notifyCreatedContractClassLog)]\nunconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {}\n\npub unconstrained fn store_private_event_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {\n    store_private_event_log_oracle(\n        contract_address,\n        recipient,\n        event_selector,\n        msg_content,\n        tx_hash,\n        log_index_in_tx,\n        tx_index_in_block,\n    )\n}\n\n#[oracle(storePrivateEventLog)]\nunconstrained fn store_private_event_log_oracle(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {}\n"
    },
    "161": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr",
      "source": "use crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\n};\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn sync_notes(pending_tagged_log_array_base_slot: Field) {\n    sync_notes_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "163": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::{\n    note::{note_interface::NoteType, note_metadata::NoteMetadata, retrieved_note::RetrievedNote},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::IndexedTaggingSecret,\n    traits::{FromField, Packable},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {\n    // This wrapper exists to extract the ORACLE_RETURN_FIELD_LENGTH generic numeric param into a value and pass it to\n    // the oracle, so that it knows how big the return array must be.\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        ORACLE_RETURN_FIELD_LENGTH,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let MAX_NOTES: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    _placeholder_fields: [Field; ORACLE_RETURN_FIELD_LENGTH], // TODO: Compute this value automatically from MAX_NOTES\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let fields: [_; ORACLE_RETURN_FIELD_LENGTH] = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n\n    let mut opt_notes = [Option::none(); MAX_NOTES];\n    for i in 0..opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let maybe_nonce = fields[read_offset];\n            let maybe_note_hash_counter = fields[read_offset + 1] as u32;\n            let packed_note = array::subarray(fields, read_offset + 2);\n\n            let note = Note::unpack(packed_note);\n            let retrieved_note = RetrievedNote {\n                note,\n                contract_address,\n                metadata: NoteMetadata::from_raw_data(maybe_note_hash_counter != 0, maybe_nonce),\n            };\n\n            opt_notes[i] = Option::some(retrieved_note);\n        };\n    }\n    opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "165": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "166": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "168": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<N> for Map<K, T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "176": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::Packable};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n///\n/// Leverages `WithHash<T>` to enable efficient private reads of public storage. `WithHash` wrapper allows for\n/// efficient reads by verifying large values through a single hash check and then proving inclusion only of the hash\n/// in the public storage. This reduces the number of required tree inclusion proofs from O(M) to O(1).\n///\n/// This is valuable when T packs to multiple fields, as it maintains \"almost constant\" verification overhead\n/// regardless of the original data size.\n///\n/// # Optimizing private reads in your contract\n/// Given that reading T from public immutable in private has \"almost constant\" constraints cost for different sizes\n/// of T it is recommended to group multiple values into a single struct when they are being read together. This can\n/// typically be some kind of configuration set up during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\n/// `WithHash<T>` stores both the packed value (using N fields) and its hash (1 field), requiring N = M + 1 total\n/// fields.\nimpl<T, Context, let M: u32, let N: u32> Storage<N> for PublicImmutable<T, Context>\nwhere\n    WithHash<T, M>: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T> PublicImmutable<T, &mut PublicContext> {\n    // docs:start:public_immutable_struct_write\n    pub fn initialize<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T> PublicImmutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::utility_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PrivateContext> {\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::historical_public_storage_read(\n            self.context.get_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "190": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/unencrypted_logs/unencrypted_event_emission.nr",
      "source": "use crate::{context::PublicContext, event::event_interface::EventInterface};\nuse protocol_types::traits::ToField;\n\nfn emit<Event, let N: u32>(context: &mut PublicContext, event: Event)\nwhere\n    Event: EventInterface<N>,\n{\n    let selector = Event::get_event_type_id();\n\n    let serialized_event = event.serialize();\n    let mut emitted_log = [0; N + 1];\n\n    // We put the selector in the \"last\" place, to avoid reading or assigning to an expression in an index\n    for i in 0..serialized_event.len() {\n        emitted_log[i] = serialized_event[i];\n    }\n\n    emitted_log[serialized_event.len()] = selector.to_field();\n\n    context.emit_public_log(emitted_log);\n}\n\npub fn encode_event<Event, let N: u32>(\n    context: &mut PublicContext,\n) -> fn[(&mut PublicContext,)](Event) -> ()\nwhere\n    Event: EventInterface<N>,\n{\n    |e: Event| { emit(context, e); }\n}\n"
    },
    "191": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "194": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "195": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "197": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "198": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "200": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "202": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "206": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "213": {
      "path": "/home/twt/nargo/github.com/noir-lang/poseidon/v0.1.0/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "230": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "232": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "275": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "276": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr",
      "source": "use crate::{\n    constants::ETH_ADDRESS_LENGTH,\n    traits::{Deserialize, Empty, Packable, Serialize, ToField},\n};\n\npub struct EthAddress {\n    inner: Field,\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl Packable<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn pack(self) -> [Field; ETH_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size::<160>();\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "278": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr",
      "source": "use crate::{\n    address::{aztec_address::AztecAddress, salted_initialization_hash::SaltedInitializationHash},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_ADDRESS_LENGTH: u32 = 1;\n\n// Partial address\npub struct PartialAddress {\n    pub inner: Field,\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n        PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress,\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer),\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n    ) -> Self {\n        PartialAddress::from_field(poseidon2_hash_with_separator(\n            [contract_class_id.to_field(), salted_initialization_hash.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "280": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr",
      "source": "use crate::{\n    address::aztec_address::AztecAddress, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\npub struct SaltedInitializationHash {\n    pub inner: Field,\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(poseidon2_hash_with_separator(\n            [salt, initialization_hash, deployer.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "284": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_class_id.nr",
      "source": "use crate::constants::GENERATOR_INDEX__CONTRACT_LEAF;\nuse crate::traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField};\n\npub struct ContractClassId {\n    pub inner: Field,\n}\n\nimpl Eq for ContractClassId {\n    fn eq(self, other: ContractClassId) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl ToField for ContractClassId {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for ContractClassId {\n    fn from_field(value: Field) -> Self {\n        Self { inner: value }\n    }\n}\n\nimpl Serialize<1> for ContractClassId {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<1> for ContractClassId {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] }\n    }\n}\n\nimpl Empty for ContractClassId {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n// Implement the Packable trait so ContractClassId can be stored in contract's storage.\nimpl Packable<1> for ContractClassId {\n    fn pack(self) -> [Field; 1] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; 1]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl ContractClassId {\n    pub fn compute(\n        artifact_hash: Field,\n        private_functions_root: Field,\n        public_bytecode_commitment: Field,\n    ) -> Self {\n        let hash = crate::hash::poseidon2_hash_with_separator(\n            [artifact_hash, private_functions_root, public_bytecode_commitment],\n            GENERATOR_INDEX__CONTRACT_LEAF,\n        ); // TODO(@spalladino): Update generator index\n        ContractClassId::from_field(hash)\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "290": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "292": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "293": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "303": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "307": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint =\n        quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_pack & typ.implements(packable_constraint)) {\n        // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n        let name_at_one_token = collapse_to_one_token(name);\n        let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n        // We add the individual fields to the fields array\n        let pack_method = get_trait_impl_method(\n            typ,\n            quote { crate::traits::Packable<$packed_len> },\n            quote { pack },\n        );\n        let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n        for i in 0..packed_len {\n            fields = fields.push_back(quote { $packed_struct_name[$i] });\n        }\n\n        // We add the new auxiliary variable to the aux_vars array\n        aux_vars = aux_vars.push_back(packed_struct);\n    } else if typ.is_field() {\n        // For field we just add the value to fields\n        fields = fields.push_back(name);\n    } else if typ.as_integer().is_some() | typ.is_bool() {\n        // For integer and bool we just cast to Field and add the value to fields\n        fields = fields.push_back(quote { $name as Field });\n    } else if typ.as_data_type().is_some() {\n        // For struct we pref\n        let nested_struct = typ.as_data_type().unwrap();\n        let params = nested_struct.0.fields(nested_struct.1);\n        let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n            let maybe_prefixed_name = if name == quote {} {\n                // Triggered when the param name is of a value available in the current scope (e.g. a function\n                // argument) --> then we don't prefix the name with anything.\n                param_name\n            } else {\n                // Triggered when we want to prefix the param name with the `name` from function input. This\n                // can typically be `self` when implementing a method on a struct.\n                quote { $name.$param_name }\n            };\n            generate_serialize_to_fields(quote {$maybe_prefixed_name}, param_type, should_pack)\n        });\n        let struct_flattened_fields = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n        );\n        let struct_flattened_aux_vars = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n        );\n        fields = fields.append(struct_flattened_fields);\n        aux_vars = aux_vars.append(struct_flattened_aux_vars);\n    } else if typ.as_array().is_some() {\n        // For array we recursively call `generate_serialize_to_fields(...)` for each element\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        for i in 0..array_len {\n            let (element_fields, element_aux_vars) =\n                generate_serialize_to_fields(quote { $name[$i] }, element_type, should_pack);\n            fields = fields.append(element_fields);\n            aux_vars = aux_vars.append(element_aux_vars);\n        }\n    } else if typ.as_str().is_some() {\n        // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n        // then we add each byte to fields as a Field\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let as_member = name.as_expr().unwrap().as_member_access();\n        let var_name = if as_member.is_some() {\n            as_member.unwrap().1\n        } else {\n            name\n        };\n        let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n        let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n        for i in 0..str_len {\n            fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n        }\n        aux_vars = aux_vars.push_back(as_bytes);\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "309": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "310": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "319": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "330": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "344": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n"
    },
    "348": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "349": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "365": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "366": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "368": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "374": {
      "path": "/home/twt/nargo/github.com/noir-lang/sha256/v0.1.3/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\npub(crate) mod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        // Safety: test function\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "378": {
      "path": "/home/twt/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "395": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER},\n        hash::poseidon2_hash_with_separator,\n        traits::{Deserialize, Hash, Packable, Serialize, ToField},\n        utils::arrays::array_concat,\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// The returned `PartialUintNote` value must be sent to public execution via a secure channel, since it is not\n    /// possible to verify the integrity of its contents due to it hiding information. The recommended ways to do this\n    /// are to retrieve it from public storage, or to receive it in an internal public function call.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient, sender);\n        context.emit_private_log(encrypted_log);\n\n        PartialUintNote { commitment }\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nimpl PartialUintNote {\n    pub fn commitment(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, value: u128, context: &mut PublicContext) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; 2] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialUintNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "46": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n"
    },
    "51": {
      "path": "/home/twt/turnstile/turnstile-contracts/aztec/contracts/portal/src/encoding/deposit.nr",
      "source": "use aztec::{\n    protocol_types::{\n        address::{AztecAddress, EthAddress},\n        hash::sha256_to_field,\n        traits::{FromField, ToField},\n    },\n};\n\n// bytes4(keccak256(\"deposit(address,bytes32,uint256)\")) = 0xeb2243f8\nglobal DEPOSIT_SIGNATURE: [u8; 4] = [0xeb, 0x22, 0x43, 0xf8];\n\npub fn deposit_content_hash(\n    eth_token: EthAddress,\n    recipient: AztecAddress,\n    amount: Field,\n) -> Field {\n    let encoded = abi_encode_deposit(eth_token, recipient, amount);\n    let content_hash = sha256_to_field(encoded);\n    content_hash\n}\n\npub fn abi_encode_deposit(\n    eth_token: EthAddress,\n    recipient: AztecAddress,\n    amount: Field,\n) -> [u8; 100] {\n    // abi.encodeWithSignature(DEPOSIT_SIGNATURE, tokenAddr, recipient, amount)\n    // This encodes the following data:\n    // offset - data\n    // 0x00 - 4 bytes for the signature\n    // 0x04 - 32 bytes for the token address\n    // 0x24 - 32 bytes for the recipient\n    // 0x44 - 32 bytes for the amount\n    // Total: 100 bytes\n    let mut encoded = [0; 100];\n    for i in 0..4 {\n        encoded[i] = DEPOSIT_SIGNATURE[i];\n    }\n\n    let eth_token_bytes: [u8; 32] = eth_token.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let amount_bytes: [u8; 32] = amount.to_be_bytes();\n\n    for i in 0..32 {\n        encoded[i + 0x4] = eth_token_bytes[i];\n        encoded[i + 0x24] = recipient_bytes[i];\n        encoded[i + 0x44] = amount_bytes[i];\n    }\n\n    encoded\n}\n\n// For testing purposes, enables printing the ABI-encoded data\npub unconstrained fn field_from_encoded_bytes(encoded: [u8; 100], offset: u32) -> Field {\n    let mut arr = [0; 31];\n    for i in 0..31 {\n        if offset + i >= 100 {\n            break;\n        }\n        arr[i] = encoded[offset + i];\n    }\n    aztec::protocol_types::utils::field::field_from_bytes(arr, true)\n}\n\n#[test]\nfn test_abi_encode_deposit() {\n    let eth_token = EthAddress::from_field(0x2458675Deb5E0691da2D2bA8dCaF58CFD2C2651F);\n    let recipient = AztecAddress::from_field(\n        0x1e571fd19f8f3aab48fd795e1b39f72dd61f44735c88a7576721be8a5065f863,\n    );\n    let amount = 0x1234567890abcdef1234567890abcdef;\n    let encoded = abi_encode_deposit(eth_token, recipient, amount);\n\n    // abi.encodeWithSignature(\"deposit(address,bytes32,uint256)\", address(0x2458675Deb5E0691da2D2bA8dCaF58CFD2C2651F), bytes32(hex\"1e571fd19f8f3aab48fd795e1b39f72dd61f44735c88a7576721be8a5065f863\"), 0x1234567890abcdef1234567890abcdef) =\n    // 0xeb2243f80000000000000000000000002458675deb5e0691da2d2ba8dcaf58cfd2c2651f1e571fd19f8f3aab48fd795e1b39f72dd61f44735c88a7576721be8a5065f863000000000000000000000000000000001234567890abcdef1234567890abcdef\n    let expected: [u8; 100] = [\n        0xeb, 0x22, 0x43, 0xf8, // Function selector - deposit(address,bytes32,uint256)\n        // Eth Token Address\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Padding\n        // Address: 0x2458675Deb5E0691da2D2bA8dCaF58CFD2C2651F\n        0x24, 0x58, 0x67, 0x5d, 0xeb, 0x5e, 0x06, 0x91, 0xda, 0x2d, 0x2b, 0xa8, 0xdc, 0xaf, 0x58,\n        0xcf, 0xd2, 0xc2, 0x65, 0x1f,\n        // Aztec Recipient Address\n        0x1e, 0x57, 0x1f, 0xd1, 0x9f, 0x8f, 0x3a, 0xab, 0x48, 0xfd, 0x79, 0x5e, 0x1b, 0x39, 0xf7,\n        0x2d, 0xd6, 0x1f, 0x44, 0x73, 0x5c, 0x88, 0xa7, 0x57, 0x67, 0x21, 0xbe, 0x8a, 0x50, 0x65,\n        0xf8, 0x63,\n        // Amount\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab,\n        0xcd, 0xef,\n    ];\n\n    if encoded != expected {\n        std::println(f\"test_abi_encode_deposit: got: {encoded}\");\n        std::println(f\"test_abi_encode_deposit: expected: {expected}\");\n    }\n    assert_eq(encoded, expected);\n}\n\n#[test]\nfn test_deposit_content_hash() {\n    let content: [u8; 100] = [\n        0xeb, 0x22, 0x43, 0xf8, // Function selector - deposit(address,bytes32,uint256)\n        // Eth Token Address\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Padding\n        // Address: 0x2458675Deb5E0691da2D2bA8dCaF58CFD2C2651F\n        0x24, 0x58, 0x67, 0x5d, 0xeb, 0x5e, 0x06, 0x91, 0xda, 0x2d, 0x2b, 0xa8, 0xdc, 0xaf, 0x58,\n        0xcf, 0xd2, 0xc2, 0x65, 0x1f,\n        // Aztec Recipient Address\n        0x1e, 0x57, 0x1f, 0xd1, 0x9f, 0x8f, 0x3a, 0xab, 0x48, 0xfd, 0x79, 0x5e, 0x1b, 0x39, 0xf7,\n        0x2d, 0xd6, 0x1f, 0x44, 0x73, 0x5c, 0x88, 0xa7, 0x57, 0x67, 0x21, 0xbe, 0x8a, 0x50, 0x65,\n        0xf8, 0x63,\n        // Amount\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab,\n        0xcd, 0xef,\n    ];\n\n    // sha256(content) = 0x5a05320993a46599dc6c5605c5f2bf139d6fb5f3709e23c5af2b530f1e883aa8\n    // sha256_to_field uses the first 31 bytes of the hash\n    let expected: Field = 0x5a05320993a46599dc6c5605c5f2bf139d6fb5f3709e23c5af2b530f1e883a;\n    let content_hash = sha256_to_field(content);\n    if content_hash != expected {\n        std::println(f\"test_deposit_content_hash: got: {content_hash}\");\n        std::println(f\"test_deposit_content_hash: expected: {expected}\");\n    }\n    assert_eq(content_hash, expected);\n}\n"
    },
    "53": {
      "path": "/home/twt/turnstile/turnstile-contracts/aztec/contracts/portal/src/encoding/register.nr",
      "source": "use aztec::{\n    protocol_types::{\n        address::EthAddress,\n        hash::sha256_to_field,\n        traits::ToField,\n    },\n};\n\n// bytes4(keccak256(register(address,string,string,uint8))) = 0x611a7a19\ncomptime global REGISTER_SIGNATURE: [u8; 4] = [0x61, 0x1a, 0x7a, 0x19];\n\npub fn register_content_hash(\n    eth_token: EthAddress,\n    name: str<31>,\n    name_len: u8,\n    symbol: str<31>,\n    symbol_len: u8,\n    decimals: u8,\n) -> Field {\n    let encoded = abi_encode_register(eth_token, name, name_len, symbol, symbol_len, decimals);\n    let content_hash = sha256_to_field(encoded);\n\n    // Debug log the ABI-encoded data\n    // let field_array: [Field; 9] = aztec::utils::bytes::bytes_to_fields::<260, 9>(encoded);\n    // dep::aztec::oracle::debug_log::debug_log_format(\"ABI Encoded: {}\", field_array);\n    content_hash\n}\n\npub fn abi_encode_register(\n    eth_token: EthAddress,\n    name: str<31>,\n    name_len: u8,\n    symbol: str<31>,\n    symbol_len: u8,\n    decimals: u8,\n) -> [u8; 260] {\n    // abi.encodeWithSignature(REGISTER_SIGNATURE, tokenAddr, token.name(), token.symbol(), token.decimals())\n    // This encodes the following data:\n    // offset - data\n    // 0x00 - 4 bytes for the signature\n    // 0x04 - 32 bytes for the token address\n    // 0x24 - 32 bytes for the name offset\n    // 0x44 - 32 bytes for the symbol offset\n    // 0x64 - 32 bytes for the decimals\n    // 0x84 - 32 bytes for the name length\n    // 0xa4 - 32 bytes for the name // Limited to 31 bytes\n    // 0xc4 - 32 bytes for the symbol length\n    // 0xe4 - 32 bytes for the symbol // Limited to 31 bytes\n    // Total: 260 bytes\n    let mut encoded = [0; 260];\n\n    let eth_token_bytes: [u8; 32] = eth_token.to_field().to_be_bytes();\n    let decimals_bytes: [u8; 32] = decimals.to_field().to_be_bytes();\n\n    let name_len_bytes: [u8; 32] = name_len.to_field().to_be_bytes();\n    let symbol_len_bytes: [u8; 32] = symbol_len.to_field().to_be_bytes();\n\n    // Fixed offsets for name and symbol\n    // Offset for the name is 0x80 per the ABI encoding, but 0x84 in the raw data\n    let name_offset_bytes: [u8; 32] = 0x80.to_field().to_be_bytes();\n    // Offset for the symbol is 0xc0 per the ABI encoding, but 0xc4 in the raw data\n    let symbol_offset_bytes: [u8; 32] = 0xc0.to_field().to_be_bytes();\n\n    let name_bytes: [u8; 31] = name.as_bytes();\n    let symbol_bytes: [u8; 31] = symbol.as_bytes();\n\n    for i in 0..32 {\n        // First 4 bytes are the function signature\n        if i < 4 {\n            encoded[i] = REGISTER_SIGNATURE[i];\n        }\n\n        encoded[i + 0x4] = eth_token_bytes[i];\n        encoded[i + 0x24] = name_offset_bytes[i];\n        encoded[i + 0x44] = symbol_offset_bytes[i];\n        encoded[i + 0x64] = decimals_bytes[i];\n        encoded[i + 0x84] = name_len_bytes[i];\n        encoded[i + 0xc4] = symbol_len_bytes[i];\n\n        // Copy name & symbol\n        if i < name_len {\n            encoded[i + 0xa4] = name_bytes[i];\n        }\n        if i < symbol_len {\n            encoded[i + 0xe4] = symbol_bytes[i];\n        }\n    }\n\n    encoded\n}\n\nunconstrained fn pad_31<let N: u32>(s: str<N>) -> str<31> {\n    let mut padded = [0; 31];\n    let s = s.as_bytes();\n    for i in 0..31 {\n        if i < N {\n            padded[i] = s[i];\n        }\n    }\n    padded.as_str_unchecked()\n}\n\n#[test]\nunconstrained fn test_abi_encode_register() {\n    let eth_token = EthAddress::from_field(0xbbEda607223492F9dce036A21C459fE1dcab56c7);\n    let name = pad_31(\"Test Token\");\n    let symbol = pad_31(\"TT\");\n    let decimals = 18;\n    let encoded = abi_encode_register(eth_token, name, 10, symbol, 2, decimals);\n\n    // abi.encodeWithSignature(\"register(address,string,string,uint8)\", address(0xbbEda607223492F9dce036A21C459fE1dcab56c7), \"Test Token\", \"TT\", 18) =\n    // 0x611a7a19000000000000000000000000bbeda607223492f9dce036a21c459fe1dcab56c7000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000a5465737420546f6b656e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000025454000000000000000000000000000000000000000000000000000000000000\n    let expected: [u8; 260] = [\n        0x61, 0x1a, 0x7a, 0x19, // Function selector - register(address,string,string,uint8)\n        // Eth Token Address\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Padding\n        // Address: 0xbbEda607223492F9dce036A21C459fE1dcab56c7\n        0xbb, 0xed, 0xa6, 0x07, 0x22, 0x34, 0x92, 0xf9, 0xdc, 0xe0, 0x36, 0xa2, 0x1c, 0x45, 0x9f,\n        0xe1, 0xdc, 0xab, 0x56, 0xc7,\n        // Name Offset\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x80,\n        // Symbol Offset\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0xc0,\n        // Decimals: 18\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x12,\n        // Name Length: 10\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x0a,\n        // Name: Test Token\n        0x54, 0x65, 0x73, 0x74, 0x20, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00,\n        // Symbol Length: 2\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x02,\n        // Symbol: TT\n        0x54, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00,\n    ];\n\n    if encoded != expected {\n        std::println(f\"test_abi_encode_register: got: {encoded}\");\n        std::println(f\"test_abi_encode_register: expected: {expected}\");\n    }\n    assert_eq(encoded, expected);\n}\n\n#[test]\nunconstrained fn test_register_content_hash() {\n    let content: [u8; 260] = [\n        0x61, 0x1a, 0x7a, 0x19, // Function selector - register(address,string,string,uint8)\n        // Eth Token Address\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Padding\n        // Address: 0xbbEda607223492F9dce036A21C459fE1dcab56c7\n        0xbb, 0xed, 0xa6, 0x07, 0x22, 0x34, 0x92, 0xf9, 0xdc, 0xe0, 0x36, 0xa2, 0x1c, 0x45, 0x9f,\n        0xe1, 0xdc, 0xab, 0x56, 0xc7,\n        // Name Offset\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x80,\n        // Symbol Offset\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0xc0,\n        // Decimals: 18\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x12,\n        // Name Length: 10\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x0a,\n        // Name: Test Token\n        0x54, 0x65, 0x73, 0x74, 0x20, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00,\n        // Symbol Length: 2\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x02,\n        // Symbol: TT\n        0x54, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00,\n    ];\n    // sha256(content) = 0x0448b4e27885c9528619c3ccd291634a7aa4f66d562d479904429803f535d9f4\n    // sha256_to_field uses the first 31 bytes of the hash\n    let expected: Field = 0x0448b4e27885c9528619c3ccd291634a7aa4f66d562d479904429803f535d9;\n    let content_hash = sha256_to_field(content);\n    if content_hash != expected {\n        std::println(f\"test_register_content_hash: got: {content_hash}\");\n        std::println(f\"test_register_content_hash: expected: {expected}\");\n    }\n    assert_eq(content_hash, expected);\n}\n"
    },
    "54": {
      "path": "/home/twt/turnstile/turnstile-contracts/aztec/contracts/portal/src/encoding/withdraw.nr",
      "source": "use aztec::protocol_types::{\n    address::EthAddress,\n    hash::sha256_to_field,\n    traits::ToField,\n};\n\n// bytes4(keccak256(\"withdraw(address,address,uint256)\")) = 0xd9caed12\nglobal WITHDRAW_SIGNATURE: [u8; 4] = [0xd9, 0xca, 0xed, 0x12];\n\npub fn withdraw_content_hash(eth_token: EthAddress, recipient: EthAddress, amount: Field) -> Field {\n    let encoded = abi_encode_withdraw(eth_token, recipient, amount);\n    let content_hash = sha256_to_field(encoded);\n    content_hash\n}\n\npub fn abi_encode_withdraw(\n    eth_token: EthAddress,\n    recipient: EthAddress,\n    amount: Field,\n) -> [u8; 100] {\n    // abi.encodeWithSignature(WITHDRAW_SIGNATURE, tokenAddr, recipient, amount)\n    // This encodes the following data:\n    // offset - data\n    // 0x00 - 4 bytes for the signature\n    // 0x04 - 32 bytes for the token address\n    // 0x24 - 32 bytes for the recipient\n    // 0x44 - 32 bytes for the amount\n    // Total: 100 bytes\n    let mut encoded = [0; 100];\n    for i in 0..4 {\n        encoded[i] = WITHDRAW_SIGNATURE[i];\n    }\n\n    let eth_token_bytes: [u8; 32] = eth_token.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let amount_bytes: [u8; 32] = amount.to_be_bytes();\n\n    for i in 0..32 {\n        encoded[i + 0x4] = eth_token_bytes[i];\n        encoded[i + 0x24] = recipient_bytes[i];\n        encoded[i + 0x44] = amount_bytes[i];\n    }\n\n    encoded\n}\n\n#[test]\nfn test_abi_encode_withdraw() {\n    let eth_token = EthAddress::from_field(0xbbEda607223492F9dce036A21C459fE1dcab56c7);\n    let recipient = EthAddress::from_field(0x52b1D2CEBF3C80813f82dC4B5F56fCB4e04aC439);\n    let amount = 0x1234567890abcdef;\n    let encoded = abi_encode_withdraw(eth_token, recipient, amount);\n\n    // abi.encodeWithSignature(\"withdraw(address,address,uint256)\", address(0xbbEda607223492F9dce036A21C459fE1dcab56c7), address(0x52b1D2CEBF3C80813f82dC4B5F56fCB4e04aC439), 0x1234567890abcdef) =\n    // 0xd9caed12000000000000000000000000bbeda607223492f9dce036a21c459fe1dcab56c700000000000000000000000052b1d2cebf3c80813f82dc4b5f56fcb4e04ac4390000000000000000000000000000000000000000000000001234567890abcdef\n    let expected: [u8; 100] = [\n        0xd9, 0xca, 0xed, 0x12, // Function selector - withdraw(address,address,uint256)\n        // Eth Token Address\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Padding\n        // Address: 0xbbEda607223492F9dce036A21C459fE1dcab56c7\n        0xbb, 0xed, 0xa6, 0x07, 0x22, 0x34, 0x92, 0xf9, 0xdc, 0xe0, 0x36, 0xa2, 0x1c, 0x45, 0x9f,\n        0xe1, 0xdc, 0xab, 0x56, 0xc7,\n        // Recipient Address\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Padding\n        // Address: 0x52b1D2CEBF3C80813f82dC4B5F56fCB4e04aC439\n        0x52, 0xb1, 0xd2, 0xce, 0xbf, 0x3c, 0x80, 0x81, 0x3f, 0x82, 0xdc, 0x4b, 0x5f, 0x56, 0xfc,\n        0xb4, 0xe0, 0x4a, 0xc4, 0x39,\n        // Amount: 0x1234567890abcdef\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab,\n        0xcd, 0xef,\n    ];\n\n    assert_eq(encoded, expected);\n}\n"
    },
    "55": {
      "path": "/home/twt/turnstile/turnstile-contracts/aztec/contracts/portal/src/main.nr",
      "source": "mod constants;\nmod encoding;\n\nuse aztec::macros::aztec;\n\n#[aztec]\npub contract Portal {\n    use std::meta::derive;\n\n    use aztec::{\n        event::event_interface::EventInterface,\n        hash::hash_args,\n        macros::{\n            events::event,\n            functions::{\n                initialization_utils::compute_initialization_hash, initializer, internal, private,\n                public, utility,\n            },\n            storage::storage,\n        },\n        protocol_types::{\n            address::{AztecAddress, EthAddress, PartialAddress},\n            contract_class_id::ContractClassId,\n            public_keys::PublicKeys,\n            traits::{FromField, Serialize, ToField},\n        },\n        state_vars::{Map, PublicImmutable},\n        unencrypted_logs::unencrypted_event_emission::encode_event,\n    };\n\n    use authwit::auth::assert_current_call_valid_authwit_public;\n\n    use token::Token;\n\n    use crate::{\n        constants::PUBLIC_NOT_SECRET_SECRET,\n        encoding::{\n            deposit::deposit_content_hash, register::register_content_hash,\n            withdraw::withdraw_content_hash,\n        },\n    };\n\n    #[storage]\n    struct Storage<Context> {\n        l1_portal: PublicImmutable<EthAddress, Context>,\n        l1_tokens: Map<EthAddress, PublicImmutable<AztecAddress, Context>, Context>,\n        l2_tokens: Map<AztecAddress, PublicImmutable<EthAddress, Context>, Context>,\n        token_contract_class_id: PublicImmutable<ContractClassId, Context>,\n        shield_gateway_beacon: PublicImmutable<AztecAddress, Context>,\n    }\n\n    #[derive(Serialize)]\n    #[event]\n    struct Register {\n        eth_token: EthAddress,\n        aztec_token: AztecAddress,\n    }\n\n    #[derive(Serialize)]\n    #[event]\n    struct Deposit {\n        eth_token: EthAddress,\n        recipient: AztecAddress,\n        amount: u128,\n        message_leaf_index: Field,\n    }\n\n    #[derive(Serialize)]\n    #[event]\n    struct Withdraw {\n        token: EthAddress,\n        from: AztecAddress,\n        to: EthAddress,\n        amount: u128,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor(\n        l1_portal: Field,\n        token_contract_class: Field,\n        shield_gateway_beacon: AztecAddress,\n    ) {\n        assert(l1_portal != 0, \"L1 portal address cannot be zero\");\n        assert(token_contract_class != 0, \"Token contract class cannot be zero\");\n\n        storage.l1_portal.initialize(EthAddress::from_field(l1_portal));\n        storage.token_contract_class_id.initialize(ContractClassId::from_field(\n            token_contract_class,\n        ));\n        storage.shield_gateway_beacon.initialize(shield_gateway_beacon);\n    }\n\n    #[private]\n    fn register_private(\n        eth_token: Field,\n        aztec_token: AztecAddress,\n        name: str<31>,\n        name_len: u8,\n        symbol: str<31>,\n        symbol_len: u8,\n        decimals: u8,\n        message_leaf_index: Field,\n    ) {\n        aztec::oracle::debug_log::debug_log_format(\n            \"Registering L1 token {0} as L2 token {1}\",\n            [eth_token, aztec_token.to_field()],\n        );\n\n        let eth_token = EthAddress::from_field(eth_token);\n\n        assert(storage.l1_tokens.at(eth_token).read().is_zero(), \"Token already registered\");\n\n        // L1->L2 message content hash from token name, symbol, decimals\n        let content_hash =\n            register_content_hash(eth_token, name, name_len, symbol, symbol_len, decimals);\n        aztec::oracle::debug_log::debug_log_format(\"Register content hash: {0}\", [content_hash]);\n\n        // Set the shield gateway beacon\n        Token::at(aztec_token)\n            .set_shield_gateway_beacon(storage.shield_gateway_beacon.read())\n            .enqueue(&mut context);\n\n        // Ensure the supplied token address matches the expected address. This ensures its deployed with\n        // the correct code and initialization parameters.\n        let initializer = Token::interface().init(context.this_address(), name, symbol, decimals);\n        let args_hash = hash_args(initializer.args);\n        let init_hash = compute_initialization_hash(initializer.selector, args_hash);\n        let partial_address = PartialAddress::compute(\n            storage.token_contract_class_id.read(),\n            0x9876543210, // salt, hardcoded\n            init_hash,\n            AztecAddress::from_field(0),\n        );\n\n        let computed_address = AztecAddress::compute(PublicKeys::default(), partial_address);\n        // aztec::oracle::debug_log::debug_log_format(\n        //     \"Supplied Address: {0}, Computed address: {1}\",\n        //     [aztec_token.to_field(), computed_address.to_field()]\n        // );\n        // aztec::oracle::debug_log::debug_log_format(\"Gas left 4: {0}\", [context.l2_gas_left()]);\n        assert(\n            computed_address == aztec_token,\n            \"Expected address did not match supplized token address\",\n        );\n\n        // Consume the message\n        aztec::oracle::debug_log::debug_log_format(\n            \"Consuming message with leaf index {0}\",\n            [message_leaf_index],\n        );\n\n        let l1Portal = storage.l1_portal.read();\n        aztec::oracle::debug_log::debug_log_format(\"L1 Portal: {0}\", [l1Portal.to_field()]);\n\n        context.consume_l1_to_l2_message(\n            content_hash,\n            PUBLIC_NOT_SECRET_SECRET,\n            storage.l1_portal.read(),\n            message_leaf_index,\n        );\n\n        Portal::at(context.this_address())._register_public(aztec_token, eth_token).enqueue(\n            &mut context,\n        );\n    }\n\n    #[public]\n    #[internal]\n    fn _register_public(aztec_token: AztecAddress, eth_token: EthAddress) {\n        // Initialize the token mappings\n        storage.l1_tokens.at(eth_token).initialize(aztec_token);\n        storage.l2_tokens.at(aztec_token).initialize(eth_token);\n        Register { eth_token, aztec_token }.emit(encode_event(&mut context));\n    }\n\n    #[private]\n    fn claim_public(\n        eth_token: Field,\n        recipient: AztecAddress,\n        amount: u128,\n        message_leaf_index: Field,\n    ) {\n        let eth_token = EthAddress::from_field(eth_token);\n\n        let content_hash = deposit_content_hash(eth_token, recipient, amount.to_field());\n        aztec::oracle::debug_log::debug_log_format(\"Deposit content hash: {0}\", [content_hash]);\n\n        // Consume the message\n        context.consume_l1_to_l2_message(\n            content_hash,\n            PUBLIC_NOT_SECRET_SECRET,\n            storage.l1_portal.read(),\n            message_leaf_index,\n        );\n\n        Portal::at(context.this_address())\n            ._claim_public(eth_token, recipient, amount, message_leaf_index)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _claim_public(\n        eth_token: EthAddress,\n        recipient: AztecAddress,\n        amount: u128,\n        message_leaf_index: Field,\n    ) {\n        Token::at(storage.l1_tokens.at(eth_token).read()).mint_to_public(recipient, amount).call(\n            &mut context,\n        );\n\n        Portal::at(context.this_address())\n            ._log_claim(eth_token, recipient, amount, message_leaf_index)\n            .call(&mut context);\n    }\n\n    #[private]\n    fn claim_shielded(\n        eth_token: Field,\n        recipient: AztecAddress,\n        amount: u128,\n        message_leaf_index: Field,\n    ) {\n        let eth_token = EthAddress::from_field(eth_token);\n\n        let content_hash = deposit_content_hash(eth_token, recipient, amount.to_field());\n        aztec::oracle::debug_log::debug_log_format(\"Deposit content hash: {0}\", [content_hash]);\n\n        // Consume the message\n        context.consume_l1_to_l2_message(\n            content_hash,\n            PUBLIC_NOT_SECRET_SECRET,\n            storage.l1_portal.read(),\n            message_leaf_index,\n        );\n\n        Token::at(storage.l1_tokens.at(eth_token).read()).mint_shielded(recipient, amount).call(\n            &mut context,\n        );\n\n        Portal::at(context.this_address())\n            ._log_claim(eth_token, recipient, amount, message_leaf_index)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _log_claim(\n        eth_token: EthAddress,\n        recipient: AztecAddress,\n        amount: u128,\n        message_leaf_index: Field,\n    ) {\n        Deposit { eth_token, recipient, amount, message_leaf_index }.emit(encode_event(\n            &mut context,\n        ));\n    }\n\n    #[public]\n    fn withdraw_public(\n        eth_token: EthAddress,\n        from: AztecAddress,\n        recipient: EthAddress,\n        amount: u128,\n        withdrawNonce: Field,\n        burnNonce: Field,\n    ) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(withdrawNonce == 0, \"Invalid nonce\");\n        }\n\n        // Burn the tokens\n        Token::at(storage.l1_tokens.at(eth_token).read()).burn_public(from, amount, burnNonce).call(\n            &mut context,\n        );\n\n        // Message the L1 Portal\n        let content_hash = withdraw_content_hash(eth_token, recipient, amount.to_field());\n        context.message_portal(storage.l1_portal.read(), content_hash);\n\n        aztec::oracle::debug_log::debug_log_format(\"Withdraw L2ToL1 Message {0}\", [content_hash]);\n\n        Withdraw { token: eth_token, from, to: recipient, amount }.emit(encode_event(&mut context));\n    }\n\n    #[utility]\n    unconstrained fn is_registered_l1(eth_token: Field) -> pub bool {\n        let eth_token = EthAddress::from_field(eth_token);\n        !storage.l1_tokens.at(eth_token).read().is_zero()\n    }\n\n    #[utility]\n    unconstrained fn is_registered_l2(aztec_token: AztecAddress) -> pub bool {\n        !storage.l2_tokens.at(aztec_token).read().is_zero()\n    }\n\n    #[utility]\n    unconstrained fn get_l2_token(eth_token: Field) -> pub AztecAddress {\n        let eth_token = EthAddress::from_field(eth_token);\n        storage.l1_tokens.at(eth_token).read()\n    }\n\n    #[utility]\n    unconstrained fn get_l1_token(aztec_token: AztecAddress) -> pub EthAddress {\n        storage.l2_tokens.at(aztec_token).read()\n    }\n\n    #[utility]\n    unconstrained fn get_l1_portal() -> pub EthAddress {\n        storage.l1_portal.read()\n    }\n}\n"
    },
    "57": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/authwit/src/auth.nr",
      "source": "use dep::aztec::{context::{gas::GasOpts, PrivateContext, PublicContext}, hash::hash_args_array};\nuse dep::aztec::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    constants::{\n        CANONICAL_AUTH_REGISTRY_ADDRESS, GENERATOR_INDEX__AUTHWIT_INNER,\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER, GENERATOR_INDEX__AUTHWIT_OUTER,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::ToField,\n};\n\n/**\n * Authenticaion witness helper library\n *\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties\n * (e.g. protocols or other users) to execute an action on their behalf.\n *\n * This library provides helper functions to manage such witnesses.\n * The authentication witness, is some \"witness\" (data) that authenticates a `message_hash`.\n * The simplest example of an authentication witness, is a signature. The signature is the \"evidence\",\n * that the signer has seen the message, agrees with it, and has allowed it.\n * It does not need to be a signature. It could be any kind of \"proof\" that the message is allowed.\n * Another proof could be knowing some kind of secret, or having some kind of \"token\" that allows the message.\n *\n * The `message_hash` is a hash of the following structure:\n * hash(consumer, chain_id, version, inner_hash)\n * - consumer: the address of the contract that is \"consuming\" the message,\n * - chain_id: the chain id of the chain that the message is being consumed on,\n * - version: the version of the chain that the message is being consumed on,\n * - inner_hash: the hash of the \"inner\" message that is being consumed, this is the \"actual\" message or action.\n *\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be\n * a hash of the \"action\" to approve, along with who made the call. As part of this library, we provide a few\n * helper functions to deal with such messages.\n *\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\n * This can be used to let some contract \"allow\" another contract to act on its behalf, as long as it can\n * show that it is acting on behalf of the contract.\n *\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be\n * derived as:\n * inner_hash = hash(caller, \"transfer\", hash(to, amount))\n *\n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\n * the arguments for the transfer.\n *\n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is\n * allowed to transfer the tokens.\n *\n *\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\n * is executed on the user's device, so we can use `oracles` to \"ask\" the user (not contract) for information. In public\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \"registry\"\n * to store the messages that we have approved.\n *\n * A simple example would be a \"token\" that is being \"pulled\" from one account into another. We will first outline\n * how this would look in private, and then in public later.\n *\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX).\n * `Alice` would make a `deposit` transaction, that she is executing using her account contract.\n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token`\n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to\n * convince the `Token` contract that it is allowed to do so.\n *\n * This is where the authentication witness comes in The `Token` contract computes a `message_hash` from the\n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to\n * execute that call.\n *\n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her\n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\n * funds from `Alice`.\n *\n * To ensure that the same \"approval\" cannot be used multiple times, we also compute a `nullifier` for the\n * authentication witness, and emit it from the `Token` contract (consumer).\n *\n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts.\n *\n *\n *  Person          Contract              Contract               Contract\n *  Alice          Alice Account          Token                   DeFi\n *   |                  |                  |                      |\n *   | Defi.deposit(Token, 1000)           |                      |\n *   |----------------->|                  |                      |\n *   |                  | deposit(Token, 1000)                    |\n *   |                  |---------------------------------------->|\n *   |                  |                  |                      |\n *   |                  |                  | transfer(Alice, Defi, 1000)\n *   |                  |                  |<---------------------|\n *   |                  |                  |                      |\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |<-----------------|                      |\n *   |                  |                  |                      |\n *   | Please give me AuthWit for DeFi     |                      |\n *   | calling transfer(Alice, Defi, 1000) |                      |\n *   |<-----------------|                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\n *   |----------------->|                  |                      |\n *   |                  | AuthWit validity |                      |\n *   |                  |----------------->|                      |\n *   |                  |                  |                      |\n *   |                  |       throw if invalid AuthWit          |\n *   |                  |                  |                      |\n *   |                  |       emit AuthWit nullifier            |\n *   |                  |                  |                      |\n *   |                  |       transfer(Alice, Defi, 1000)       |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  | success              |\n *   |                  |                  |--------------------->|\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |           deposit(Token, 1000)\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *\n *\n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store\n * the messages that we have approved.\n *\n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\n *\n * The `Token` contract can then try to \"spend\" the approval by calling `consume` on the registry. If the message\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\n * registry, see `main.nr` in `auth_registry_contract`.\n *\n * Person          Contract              Contract            Contract               Contract\n * Alice          Alice Account          Registry             Token                   DeFi\n *   |                  |                    |                   |                      |\n *   | Registry.set_authorized(..., true)    |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | set_authorized(..., true)              |                      |\n *   |                  |------------------->|                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |         set authorized to true         |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   | Defi.deposit(Token, 1000)             |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | deposit(Token, 1000)                   |                      |\n *   |                  |-------------------------------------------------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\n *   |                  |                    |                   |<---------------------|\n *   |                  |                    |                   |                      |\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |                    |<------------------|                      |\n *   |                  |                    |                   |                      |\n *   |                  |          throw if invalid AuthWit      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |           set authorized to false      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    | AuthWit validity  |                      |\n *   |                  |                    |------------------>|                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\n *   |                  |                    |                   |<-------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | success              |\n *   |                  |                    |                   |--------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |     deposit(Token, 1000)\n *   |                  |                    |                   |                      |\n *\n *\n * --- FAQ ---\n * Q:   Why are we using a success flag of `poseidon2_hash_bytes(\"IS_VALID()\")` instead of just returning a boolean?\n * A:   We want to make sure that we don't accidentally return `true` if there is a collision in the function selector.\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a collision and we return\n *      a success flag.\n *\n * Q:   Why are we using static calls?\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\n *\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be\n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the\n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\n *\n * Q:   Why is the chain id and the version part of the message hash?\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\n *      chain to avoid a case where the same message could be used across multiple chains.\n */\n\npub global IS_VALID_SELECTOR: Field = 0x47dacd73; // 4 last bytes of poseidon2_hash_bytes(\"IS_VALID()\")\n\n/**\n * Assert that `on_behalf_of` has authorized the current call with a valid authentication witness\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash([\n        context.msg_sender().to_field(),\n        context.selector().to_field(),\n        context.args_hash,\n    ]);\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\n/**\n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\n *\n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n * @param inner_hash The hash of the message to authorize\n */\npub fn assert_inner_hash_valid_authwit(\n    context: &mut PrivateContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context\n        .static_call_private_function(\n            on_behalf_of,\n            comptime { FunctionSelector::from_signature(\"verify_private_authwit(Field)\") },\n            [inner_hash],\n        )\n        .get_preimage();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\n    // Those should already be handled in the verification, so we just need something to nullify, that allows the same inner_hash for multiple actors.\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_nullifier(nullifier);\n}\n\n/**\n * Assert that `on_behalf_of` has authorized the current call in the authentication registry\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit_public\npub unconstrained fn assert_current_call_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n) {\n    let inner_hash = compute_inner_authwit_hash([\n        (*context).msg_sender().to_field(),\n        (*context).selector().to_field(),\n        (*context).get_args_hash(),\n    ]);\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\n/**\n * Assert that `on_behalf_of` has authorized a specific `inner_hash` in the authentication registry\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that has allegedly authorized the `inner_hash`\n */\npub unconstrained fn assert_inner_hash_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    let results: [Field] = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"consume((Field),Field)\") },\n        [on_behalf_of.to_field(), inner_hash].as_slice(),\n        GasOpts::default(),\n    );\n    assert(results.len() == 1, \"Invalid response from registry\");\n    assert(results[0] == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n/**\n * Compute the `message_hash` from a function call to be used by an authentication witness\n *\n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\n * B to transfer T on its behalf.\n *\n * @param caller The address of the contract that is calling the function, in the example above, this would be B\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param selector The function selector of the function that is being called\n * @param args The arguments of the function that is being called\n */\n// docs:start:compute_authwit_message_hash_from_call\npub fn compute_authwit_message_hash_from_call<let N: u32>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N],\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash =\n        compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_authwit_message_hash_from_call\n\n/**\n * Computes the `inner_hash` of the authentication witness\n *\n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\n * that is not necessarily a call, but just some \"bytes\" or text.\n *\n * @param args The arguments to hash\n */\npub fn compute_inner_authwit_hash<let N: u32>(args: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\n/**\n * Computes the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\n *\n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\n *\n * @param on_behalf_of The address that has authorized the `inner_hash`\n * @param inner_hash The hash of the message to authorize\n */\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [on_behalf_of.to_field(), inner_hash],\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER,\n    )\n}\n\n/**\n * Computes the `message_hash` for the authentication witness\n *\n * @param consumer The address of the contract that is consuming the message\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param inner_hash The hash of the \"inner\" message that is being consumed\n */\npub fn compute_authwit_message_hash(\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    inner_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [consumer.to_field(), chain_id, version, inner_hash],\n        GENERATOR_INDEX__AUTHWIT_OUTER,\n    )\n}\n\n/**\n * Helper function to set the authorization status of a message hash\n *\n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\n *\n * @param message_hash The hash of the message to authorize\n * @param authorize True if the message should be authorized, false if it should be revoked\n */\npub unconstrained fn set_authorized(\n    context: &mut PublicContext,\n    message_hash: Field,\n    authorize: bool,\n) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_authorized(Field,bool)\") },\n        [message_hash, authorize as Field].as_slice(),\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n\n/**\n * Helper function to reject all authwits\n *\n * Wraps a public call to the authentication registry to set the `reject_all` flag\n *\n * @param reject True if all authwits should be rejected, false otherwise\n */\npub unconstrained fn set_reject_all(context: &mut PublicContext, reject: bool) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_reject_all(bool)\") },\n        [context.this_address().to_field(), reject as Field].as_slice(),\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "65": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n"
    },
    "66": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n"
    },
    "73": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "74": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "75": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "76": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "80": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "92": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "97": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    }
  }
}
