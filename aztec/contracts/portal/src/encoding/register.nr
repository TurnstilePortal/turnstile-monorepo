use aztec::{
    protocol_types::{
        address::EthAddress,
        hash::sha256_to_field,
        traits::{FromField, ToField},
    },
};

// bytes4(keccak256(register(address,string,string,uint8))) = 0x611a7a19
comptime global REGISTER_SIGNATURE: [u8; 4] = [0x61, 0x1a, 0x7a, 0x19];

pub fn register_content_hash(
    eth_token: EthAddress,
    name: str<31>,
    name_len: u8,
    symbol: str<31>,
    symbol_len: u8,
    decimals: u8,
) -> Field {
    let encoded = abi_encode_register(eth_token, name, name_len, symbol, symbol_len, decimals);
    let content_hash = sha256_to_field(encoded);

    // Debug log the ABI-encoded data
    // let field_array: [Field; 9] = aztec::utils::bytes::bytes_to_fields::<260, 9>(encoded);
    // dep::aztec::oracle::debug_log::debug_log_format("ABI Encoded: {}", field_array);
    content_hash
}

pub fn abi_encode_register(
    eth_token: EthAddress,
    name: str<31>,
    name_len: u8,
    symbol: str<31>,
    symbol_len: u8,
    decimals: u8,
) -> [u8; 260] {
    // abi.encodeWithSignature(REGISTER_SIGNATURE, tokenAddr, token.name(), token.symbol(), token.decimals())
    // This encodes the following data:
    // offset - data
    // 0x00 - 4 bytes for the signature
    // 0x04 - 32 bytes for the token address
    // 0x24 - 32 bytes for the name offset
    // 0x44 - 32 bytes for the symbol offset
    // 0x64 - 32 bytes for the decimals
    // 0x84 - 32 bytes for the name length
    // 0xa4 - 32 bytes for the name // Limited to 31 bytes
    // 0xc4 - 32 bytes for the symbol length
    // 0xe4 - 32 bytes for the symbol // Limited to 31 bytes
    // Total: 260 bytes
    let mut encoded = [0; 260];

    let eth_token_bytes: [u8; 32] = eth_token.to_field().to_be_bytes();
    let decimals_bytes: [u8; 32] = decimals.to_field().to_be_bytes();

    let name_len_bytes: [u8; 32] = name_len.to_field().to_be_bytes();
    let symbol_len_bytes: [u8; 32] = symbol_len.to_field().to_be_bytes();

    // Fixed offsets for name and symbol
    // Offset for the name is 0x80 per the ABI encoding, but 0x84 in the raw data
    let name_offset_bytes: [u8; 32] = 0x80.to_field().to_be_bytes();
    // Offset for the symbol is 0xc0 per the ABI encoding, but 0xc4 in the raw data
    let symbol_offset_bytes: [u8; 32] = 0xc0.to_field().to_be_bytes();

    let name_bytes: [u8; 31] = name.as_bytes();
    let symbol_bytes: [u8; 31] = symbol.as_bytes();

    for i in 0..32 {
        // First 4 bytes are the function signature
        if i < 4 {
            encoded[i] = REGISTER_SIGNATURE[i];
        }

        encoded[i + 0x4] = eth_token_bytes[i];
        encoded[i + 0x24] = name_offset_bytes[i];
        encoded[i + 0x44] = symbol_offset_bytes[i];
        encoded[i + 0x64] = decimals_bytes[i];
        encoded[i + 0x84] = name_len_bytes[i];
        encoded[i + 0xc4] = symbol_len_bytes[i];

        // Copy name & symbol
        if i < name_len {
            encoded[i + 0xa4] = name_bytes[i];
        }
        if i < symbol_len {
            encoded[i + 0xe4] = symbol_bytes[i];
        }
    }

    encoded
}

unconstrained fn pad_31<let N: u32>(s: str<N>) -> str<31> {
    let mut padded = [0; 31];
    let s = s.as_bytes();
    for i in 0..31 {
        if i < N {
            padded[i] = s[i];
        }
    }
    padded.as_str_unchecked()
}

#[test]
unconstrained fn test_abi_encode_register() {
    let eth_token = EthAddress::from_field(0xbbEda607223492F9dce036A21C459fE1dcab56c7);
    let name = pad_31("Test Token");
    let symbol = pad_31("TT");
    let decimals = 18;
    let encoded = abi_encode_register(eth_token, name, 10, symbol, 2, decimals);

    // abi.encodeWithSignature("register(address,string,string,uint8)", address(0xbbEda607223492F9dce036A21C459fE1dcab56c7), "Test Token", "TT", 18) =
    // 0x611a7a19000000000000000000000000bbeda607223492f9dce036a21c459fe1dcab56c7000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000a5465737420546f6b656e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000025454000000000000000000000000000000000000000000000000000000000000
    let expected: [u8; 260] = [
        0x61, 0x1a, 0x7a, 0x19, // Function selector - register(address,string,string,uint8)
        // Eth Token Address
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Padding
        // Address: 0xbbEda607223492F9dce036A21C459fE1dcab56c7
        0xbb, 0xed, 0xa6, 0x07, 0x22, 0x34, 0x92, 0xf9, 0xdc, 0xe0, 0x36, 0xa2, 0x1c, 0x45, 0x9f,
        0xe1, 0xdc, 0xab, 0x56, 0xc7,
        // Name Offset
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x80,
        // Symbol Offset
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0xc0,
        // Decimals: 18
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x12,
        // Name Length: 10
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x0a,
        // Name: Test Token
        0x54, 0x65, 0x73, 0x74, 0x20, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00,
        // Symbol Length: 2
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x02,
        // Symbol: TT
        0x54, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00,
    ];

    if encoded != expected {
        std::println(f"test_abi_encode_register: got: {encoded}");
        std::println(f"test_abi_encode_register: expected: {expected}");
    }
    assert_eq(encoded, expected);
}

#[test]
unconstrained fn test_register_content_hash() {
    let content: [u8; 260] = [
        0x61, 0x1a, 0x7a, 0x19, // Function selector - register(address,string,string,uint8)
        // Eth Token Address
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Padding
        // Address: 0xbbEda607223492F9dce036A21C459fE1dcab56c7
        0xbb, 0xed, 0xa6, 0x07, 0x22, 0x34, 0x92, 0xf9, 0xdc, 0xe0, 0x36, 0xa2, 0x1c, 0x45, 0x9f,
        0xe1, 0xdc, 0xab, 0x56, 0xc7,
        // Name Offset
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x80,
        // Symbol Offset
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0xc0,
        // Decimals: 18
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x12,
        // Name Length: 10
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x0a,
        // Name: Test Token
        0x54, 0x65, 0x73, 0x74, 0x20, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00,
        // Symbol Length: 2
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x02,
        // Symbol: TT
        0x54, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00,
    ];
    // sha256(content) = 0x0448b4e27885c9528619c3ccd291634a7aa4f66d562d479904429803f535d9f4
    // sha256_to_field uses the first 31 bytes of the hash
    let expected: Field = 0x0448b4e27885c9528619c3ccd291634a7aa4f66d562d479904429803f535d9;
    let content_hash = sha256_to_field(content);
    if content_hash != expected {
        std::println(f"test_register_content_hash: got: {content_hash}");
        std::println(f"test_register_content_hash: expected: {expected}");
    }
    assert_eq(content_hash, expected);
}
